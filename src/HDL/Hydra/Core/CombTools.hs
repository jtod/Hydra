{-|
Module       : HDL.Hydra.Circuits.CombTools
Description  : Tools for working with combinational circuits
Copyright    : (c) John O'Donnell 2016
License      : GPL-3
Maintainer   : john.t.odonnell9@gmail.com
Stability    : experimental

 Tools for working with combinational circuits -}

module HDL.Hydra.Core.CombTools
  (

-- * Truth tables
--
-- truthTable11, truthTable21

  ) where

-- Tools for working with combinational circuits.

--  (*) Generating truth table for a circuit

import HDL.Hydra.Core.Signal
import HDL.Hydra.Core.SigStream
import HDL.Hydra.Core.Driver
import HDL.Hydra.Core.SigBool


{- commented out entire module, fix errors later...

-- The following functions offer the simplest way to generate the
-- truth table of a combinational circuit.  They use the Bool signal
-- representation, so they can be used only with circuits using a
-- signal class that contains Bool.


-- The 2^k input lists corresponding to k inputs are generated by
-- enumtt k.

enumtt k
  | k==0 = [[]]
  | k>0  = let xs = enumtt (k-1)
           in map (False:) xs ++ map (True:) xs

gentt :: Int -> ([Bool]->[Bool]) -> [([Bool],[Bool])]
gentt k f = [(xs, f xs) | xs <- enumtt k]

separate s [] = []
separate s [x] = [x]
separate s (x:y:ys) = x : s : separate s (y:ys)

showttline :: ([Bool],[Bool]) -> String
showttline (xs,ys) =
  concat (separate " " (map showSig xs))
  ++ " | " ++
  concat ( separate " " (map showSig ys))

showlines :: String -> [String] -> String
showlines a xs = concat (map ((a++) . (++"\n")) xs)


-- Truth tables with 1 input, 1 output

gentt11 :: (Bool->Bool) -> [([Bool],[Bool])]
gentt11 f = gentt 1 (tupleword1 . wordin1 f)



showtt11 :: (Bool->Bool) -> String
showtt11 f = showlines "    " (map showttline (gentt11 f))

truthTable11Bool :: (Bool->Bool) -> IO ()
truthTable11Bool f = do putStr (showtt11 f)

-- Truth tables with 2 inputs, 1 output

gentt21 :: (Bool->Bool->Bool) -> [([Bool],[Bool])]
gentt21 f = gentt 2 (tupleword1 . wordin2 f)

showtt21 :: (Bool->Bool->Bool) -> String
showtt21 f = showlines "    " (map showttline (gentt21 f))

truthTable21Bool :: (Bool->Bool->Bool) -> IO ()
truthTable21Bool f = do putStr (showtt21 f)

-- Truth tables with 3 inputs, 1 output

gentt31 :: (Bool->Bool->Bool->Bool) -> [([Bool],[Bool])]
gentt31 f = gentt 3 (tupleword1 . wordin3 f)

showtt31 :: (Bool->Bool->Bool->Bool) -> String
showtt31 f = showlines "    " (map showttline (gentt31 f))

truthTable31Bool :: (Bool->Bool->Bool->Bool) -> IO ()
truthTable31Bool f = do putStr (showtt31 f)

-- Truth tables with 4 inputs, 1 output

gentt41 :: (Bool->Bool->Bool->Bool->Bool) -> [([Bool],[Bool])]
gentt41 f = gentt 4 (tupleword1 . wordin4 f)

showtt41 :: (Bool->Bool->Bool->Bool->Bool) -> String
showtt41 f = showlines "    " (map showttline (gentt41 f))

truthTable41Bool :: (Bool->Bool->Bool->Bool->Bool) -> IO ()
truthTable41Bool f = do putStr (showtt41 f)

truthTable :: Int -> ([Bool]->[Bool]) -> IO ()
truthTable k f = do putStr (showlines "    " (map showttline (gentt k f)))

-- Truth tables with 2 inputs, 2 outputs

gentt22 :: (Bool->Bool->(Bool,Bool)) -> [([Bool],[Bool])]
gentt22 f = gentt 2 (tupleword2 . wordin2 f)

showtt22 :: (Bool->Bool->(Bool,Bool)) -> String
showtt22 f = showlines "    " (map showttline (gentt22 f))

truthTable22Bool :: (Bool->Bool->(Bool,Bool)) -> IO ()
truthTable22Bool f = do putStr (showtt22 f)

-- Truth tables with 3 inputs, 2 outputs

gentt32 :: (Bool->Bool->Bool->(Bool,Bool)) -> [([Bool],[Bool])]
gentt32 f = gentt 3 (tupleword2 . wordin3 f)

showtt32 :: (Bool->Bool->Bool->(Bool,Bool)) -> String
showtt32 f = showlines "    " (map showttline (gentt32 f))

truthTable32Bool :: (Bool->Bool->Bool->(Bool,Bool)) -> IO ()
truthTable32Bool f = do putStr (showtt32 f)

truthTable11 = truthTable11Bool
truthTable21 = truthTable21Bool
truthTable22 = truthTable22Bool
truthTable31 = truthTable31Bool
truthTable41 = truthTable41Bool
truthTable32 = truthTable32Bool

-}
