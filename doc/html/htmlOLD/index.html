<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="John T. O'Donnell" />
  <title>Hydra User Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Hydra User Guide</h1>
<h2 class="author">John T. O'Donnell</h2>
<h3 class="date">version:     2.3.0</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#hardware-description-languages">Hardware description languages</a></li>
<li><a href="#modeling-circuits-as-functions">Modeling circuits as functions</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#compiling-and-installing">Compiling and installing</a></li>
<li><a href="#running-without-compiling">Running without compiling</a></li>
<li><a href="#building-the-documentation">Building the documentation</a></li>
</ul></li>
<li><a href="#hello-world-running-a-simulation">Hello world! Running a simulation</a><ul>
<li><a href="#graphical-user-interface-windows-only">Graphical user interface (Windows only)</a></li>
<li><a href="#one-line-command-using-the-haskell-compiler">One-line command using the Haskell compiler</a></li>
<li><a href="#separate-compilation-and-execution">Separate compilation and execution</a></li>
<li><a href="#interacting-with-the-haskell-interpreter">Interacting with the Haskell interpreter</a></li>
</ul></li>
<li><a href="#a-quick-overview-with-examples">A quick overview with examples</a><ul>
<li><a href="#a-minimal-circuit-helloworld">A minimal circuit: helloWorld</a></li>
<li><a href="#connecting-several-logic-gates-mux1">Connecting several logic gates: mux1</a></li>
<li><a href="#producing-several-outputs-halfadd">Producing several outputs: halfAdd</a></li>
<li><a href="#black-box-with-internal-signals-add4">Black box with internal signals: add4</a></li>
<li><a href="#feedback-and-changing-state-bsr4">Feedback and changing state: BSR4</a></li>
</ul></li>
<li><a href="#modules-and-files">Modules and files</a></li>
<li><a href="#connecting-components-with-signals">Connecting components with signals</a><ul>
<li><a href="#logic-gates">Logic gates</a></li>
<li><a href="#connecting-a-circuit-to-inputs">Connecting a circuit to inputs</a></li>
<li><a href="#anonymous-signals">Anonymous signals</a></li>
<li><a href="#named-signals-and-equations">Named signals and equations</a></li>
<li><a href="#constant-signals">Constant signals</a></li>
</ul></li>
<li><a href="#defining-new-circuits">Defining new circuits</a><ul>
<li><a href="#circuit-type">Circuit type</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#internal-signals">Internal signals</a></li>
<li><a href="#multiple-outputs">Multiple outputs</a></li>
<li><a href="#feedback">Feedback</a></li>
</ul></li>
<li><a href="#signal-and-circuit-types">Signal and circuit types</a><ul>
<li><a href="#signal-types-and-classes">Signal types and classes</a></li>
<li><a href="#combinational-signals-bit-a">Combinational signals: Bit a</a></li>
<li><a href="#clocked-signals-bit-a">Clocked signals: Bit a</a></li>
<li><a href="#inputs-and-outputs">Inputs and outputs</a></li>
</ul></li>
<li><a href="#containers">Containers</a><ul>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#words">Words</a></li>
<li><a href="#example-2-a-circuit-with-words-and-internal-signals">Example 2: A circuit with words and internal signals</a><ul>
<li><a href="#building-words">Building words</a></li>
<li><a href="#accessing-parts-of-a-word">Accessing parts of a word</a></li>
</ul></li>
<li><a href="#nested-clusters">Nested clusters</a></li>
</ul></li>
<li><a href="#combinational-simulation">Combinational simulation</a></li>
<li><a href="#synchronous-sequential-simulation">Synchronous sequential simulation</a><ul>
<li><a href="#general-form">General form</a></li>
<li><a href="#parsing-the-inputs">Parsing the inputs</a></li>
<li><a href="#formatting-the-outputs">Formatting the outputs</a></li>
<li><a href="#defining-a-main-program">Defining a main program</a></li>
<li><a href="#modules-and-libraries">Modules and libraries</a></li>
<li><a href="#compilation-and-interpretation">Compilation and interpretation</a></li>
</ul></li>
<li><a href="#standard-library-for-bits">Standard library for bits</a><ul>
<li><a href="#constant-signals-1">Constant signals</a></li>
<li><a href="#logic-gates-1">Logic gates</a></li>
<li><a href="#replicating-a-signal">Replicating a signal</a></li>
<li><a href="#multiplexers-and-demultiplexers">Multiplexers and demultiplexers</a></li>
<li><a href="#bit-addition">Bit addition</a></li>
<li><a href="#flip-flops-and-registers">Flip flops and registers</a></li>
</ul></li>
<li><a href="#standard-library-for-words">Standard library for words</a><ul>
<li><a href="#replication-and-constant-words">Replication and constant words</a></li>
<li><a href="#replicating-a-word">Replicating a word</a></li>
<li><a href="#rearranging-bits-in-a-word">Rearranging bits in a word</a><ul>
<li><a href="#combinational-shifting">Combinational shifting</a></li>
<li><a href="#bit-slice-representation">Bit slice representation</a></li>
</ul></li>
<li><a href="#logic-on-words">Logic on words</a></li>
<li><a href="#conditionals-and-addresses">Conditionals and addresses</a><ul>
<li><a href="#multiplexers">Multiplexers</a></li>
<li><a href="#demultiplexers">Demultiplexers</a></li>
</ul></li>
<li><a href="#arithmetic">Arithmetic</a><ul>
<li><a href="#binary-addition">Binary addition</a></li>
</ul></li>
<li><a href="#registers">Registers</a></li>
<li><a href="#registers-1">Registers</a></li>
</ul></li>
<li><a href="#circuit-generators">Circuit generators</a><ul>
<li><a href="#operating-on-words">Operating on words</a></li>
<li><a href="#recursive-circuit-definitions">Recursive circuit definitions</a></li>
<li><a href="#tree-structured-circuits">Tree structured circuits</a></li>
<li><a href="#memory">Memory</a></li>
</ul></li>
<li><a href="#combinators">Combinators</a><ul>
<li><a href="#map">Map</a><ul>
<li><a href="#sized-map">Sized map</a></li>
</ul></li>
<li><a href="#fold">Fold</a><ul>
<li><a href="#fold-from-the-left">Fold from the left</a></li>
<li><a href="#binary-comparison-using-foldl">Binary comparison using foldl</a></li>
<li><a href="#fold-from-the-right-foldr">Fold from the right: foldr</a></li>
</ul></li>
<li><a href="#scan">Scan</a><ul>
<li><a href="#scan-from-the-left-scanl">Scan from the left: scanl</a></li>
<li><a href="#scan-from-the-right-scanr">Scan from the right: scanr</a></li>
<li><a href="#combining-a-map-with-a-scan">Combining a map with a scan</a></li>
<li><a href="#ripple-carry-addition">Ripple carry addition</a></li>
<li><a href="#bidirectional-scan">Bidirectional scan</a></li>
</ul></li>
</ul></li>
<li><a href="#circuit-semantics">Circuit semantics</a><ul>
<li><a href="#boolean-signals">Boolean signals</a></li>
<li><a href="#streams">Streams</a></li>
<li><a href="#synchronous-circuits">Synchronous circuits</a></li>
<li><a href="#multiple-semantics">Multiple semantics</a></li>
<li><a href="#path-depth">Path depth</a></li>
<li><a href="#netlists">Netlists</a></li>
</ul></li>
<li><a href="#equational-reasoning">Equational reasoning</a><ul>
<li><a href="#substituting-equals-for-equals">Substituting equals for equals</a></li>
<li><a href="#equivalent-ways-to-describe-a-circuit">Equivalent ways to describe a circuit</a></li>
</ul></li>
<li><a href="#summary-of-syntax">Summary of syntax</a><ul>
<li><a href="#indentation">Indentation</a></li>
<li><a href="#names">Names</a></li>
<li><a href="#signal-expressions">Signal expressions</a></li>
<li><a href="#defining-equations-for-signals">Defining equations for signals</a></li>
<li><a href="#defining-equations-for-circuits">Defining equations for circuits</a></li>
</ul></li>
<li><a href="#error-messages-and-runtime-errors">Error messages and runtime errors</a></li>
<li><a href="#implementation-of-hydra">Implementation of Hydra</a><ul>
<li><a href="#files">Files</a></li>
<li><a href="#source-directories">Source directories</a></li>
</ul></li>
<li><a href="#further-information">Further information</a></li>
<li><a href="#solutions-to-the-exercises">Solutions to the exercises</a></li>
<li><a href="#index">Index</a></li>
<li><a href="#colophon">Colophon</a></li>
</ul>
</div>
<h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p>Hydra is a computer hardware description language (CHDL or HDL) that enables you to design, analyse, and simulate digital circuits. It focuses on logic design, not on the physics of electronic components. It is concerned with how to connect logic gates into a system, but not with the electronic characteristics of an individual transistor. Hydra supports <em>synchronous circuits</em>, where a clock keeps all the flip flops synchronised with each other.</p>
<p>This is free and open source software; see LICENSE.txt for details. To use the system you need the ghc compiler suite for Haskell (this is needed to use Hydra, not just to install it). See the sections Getting started and Installation.</p>
<p>The language provides facilities that help to design complex circuits as well as small ones. The notation is concise and readable. Large circuits can be described using <em>circuit generators</em>, which remove most of the repetition in a circuit description without losing any of the detail. New circuit generators can be defined: you aren't limited to the ones that are built in.</p>
<p>Hydra has a semantic foundation for circuits that supports the use of <em>equational reasoning</em>. This is a formal method that can be used to transform a circuit to make it more efficient according to a cost model, as well as to prove that an implementation satisfies a specification. In some cases, it is possible to start with an abstract specification of the desired behavior, and to derive mathematically a circuit that implements it.</p>
<p>Hydra is not suitable for all design problems. It assumes that all the values on wires are digital, rather than continuously varying analogue voltages. There are other hardware description languages that can handle analogue circuits.</p>
<h2 id="hardware-description-languages"><a href="#hardware-description-languages">Hardware description languages</a></h2>
<p>To design a circuit, and to do anything useful with it, we need a way to describe it. The description can take two forms. A <em>specification</em> is a clear statement of what the system is intended to do, while an <em>implementation</em> shows how the primitive operations that are available can achieve that result. Both the specification and implementation need to be clear, complete, and precise.</p>
<p>An implementation may take the form of a diagram or a piece of text. For digital circuits, a pictorial specification is called a <em>schematic diagram</em> while a textual specification uses a <em>hardware description language</em>. Both forms can also be used for software: a textual specification of an algorithm uses a programming language, but there are also visual programming languages that used diagrams to describe algorithms.</p>
<p>A schematic diagram is an abstract picture of a circuit. It shows the components and how they are connected with wires, but it does not directly describe the circuit's function. A schematic diagram implies some geometric information, such as the relative placement of components, and this geometry may be used in fabricating the circuit.</p>
<p>An alternative approach is to use a computer hardware description language (CHDL or HDL). A circuit specification using an HDL is a text document, so it looks superficially like a computer program, but it describes hardware rather than software. Most hardware description languages are based on existing programming languages intended for software, and they model circuits using the paradigms of programming.</p>
<p>Schematic diagrams and hardware description languages each have their merits. A diagram may be easier for a beginner to understand, and it's more obvious that a schematic describes hardware and isn't just a computer program. However, hardware description languages scale up better to large and complex circuits, and fit better with software tools that can analyse a circuit and simulate it.</p>
<h2 id="modeling-circuits-as-functions"><a href="#modeling-circuits-as-functions">Modeling circuits as functions</a></h2>
<p>Some HDLs are based on imperative programming languages, using the assignment statement to model a state change in a circuit. In contrast, Hydra is based on pure functional programming, and it models a circuit as a function that takes inputs and produces outputs. This is natural, because a circuit and a function are both a black box that takes some inputs and produces some outputs. The underlying model -- circuits as functions rather than state changes as assignments -- is the fundamental difference between Hydra and imperative HDLs.</p>
<p>Hydra is an example of an <em>embedded domain-specific language</em> (DSL or EDSL). A domain-specific language is a language intended for one specific application domain, not for general purpose programming. Hydra is suitable specifically for expressing algorithms as digital circuits, but it isn't a general purpose programming language. It is implemented by <em>embedding</em> in Haskell, a general purpose functional language. This means that Hydra doesn't have a separate compiler; instead, its implementation consists of a library of Haskell modules. A circuit specification written in Hydra is compiled by the Haskell compiler and linked with the Hydra library. However, it is best to think of Hydra as a distinct language: designing a circuit is not the same as writing a program in Haskell, and some Haskell programs don't correspond to circuits.</p>
<p>Hydra is implemented using Haskell, a general purpose functional programming language. Hydra is a subset of Haskell, augmented with libraries. A circuit specification is compiled using the Haskell compiler, and there is no separate Hydra compiler. However, it's better to think of Hydra as a distinct language, and some of the software tools will give an error message if you try to step outside of Hydra and write general Haskell code in a circuit specification. You don't need to know how Hydra is implemented in order to use it, but Chapter ?? explains how the implementation works.</p>
<h1 id="installation"><a href="#installation">Installation</a></h1>
<p>You need two pieces of software: ghc, a Haskell compiler, and the Hydra source. Both are free software, and they run on Windows, Macintosh, and Gnu/Linux.</p>
<ul>
<li><p>The ghc compiler for Haskell. To find out whether you have it, enter ghc --version. If it isn't installed, go to www.haskell.org. It's easiest to get the Haskell Platform, not just the ghc compiler. This directory contains the installer, as well as the documentation and a collection of circuit examples.</p></li>
<li><p>The Hydra installation file is Hydra-i.j.k.zip (or .tgz), where i.j.k is the version number. Download it somewhere in your user workspace and uppack it: on Linux, tar -xzf Hydra-i.j.k.tgz and on Windows use 7zip or tar.</p></li>
</ul>
<p>The installation directory contains documentation in index.html. Open it in a browser; the page points to the User Guide (this document) and the API reference.</p>
<p>You can either compile and install Hydra (the recommended approach), or run it from the source files without compiling it. In either case, you need ghc.</p>
<h2 id="compiling-and-installing"><a href="#compiling-and-installing">Compiling and installing</a></h2>
<p>The easiest way to use the system is to build the library and install it in the standard way, using the ghc compiler.</p>
<ol style="list-style-type: decimal">
<li><p>Open a shell and change into the installation directory.</p></li>
<li><p>Compile and install the software with this command: make install. Alternatively you can enter these commands separately: cabal configure, cabal install, cabal haddock.</p></li>
</ol>
<p>To test the installation, go to Loading files.</p>
<h2 id="running-without-compiling"><a href="#running-without-compiling">Running without compiling</a></h2>
<p>It's possible to use the software without compiling it, using ghci to interpret the source. This avoids the need to have binary files installed in the standard location, but on the other hand it's more awkward to use the system. Open a shell and navigate to the installation directory, and enter these commands:</p>
<pre><code>  ghci Hydra
  :cd your_workspace
  :load YourCircuit</code></pre>
<h2 id="building-the-documentation"><a href="#building-the-documentation">Building the documentation</a></h2>
<p>The top level documentation page, index.html, contains links to the User Guide and the API reference. If either link is broken, you can rebuild the documentation:</p>
<pre><code>  cabal haddock   Build the API reference
  make userguide  Build the User Guide (requires mp4, pandoc)</code></pre>
<h1 id="hello-world-running-a-simulation"><a href="#hello-world-running-a-simulation">Hello world! Running a simulation</a></h1>
<p>Let's start by running a circuit simulation. For now, just run the examples, and refer back to them as the subsequent sections explain the language. The examples directory contains a variety of circuits, and the simplest is in examples/helloworld.</p>
<p>To run a circuit, two definitions are needed: the <em>circuit specification</em>, and a <em>simulation driver</em>. The circuit specification states precisely the interface to the circuit, what components it contains, and how they are connected. The simulation driver says how to parse the inputs using a readable input format, and how to format the outputs to make them readable.</p>
<p>It's good practice to place the circuit definition and its simulation driver in separate files. By convention, the filename of the driver ends in &quot;Run&quot;. The files in examples/helloworld are:</p>
<ul>
<li><p>HelloWorld.hs defines a circuit named hello, which takes two input bits and outputs their logical and.</p></li>
<li><p>HelloWorldRun.hs defines a simulation driver for the circuit. Usually, a simulation driver file provides a main program named <em>main</em> which runs the simulation on test data which is also defined in the file. In HelloWorldRun.hs, the test data runs the circuit on all possible inputs 00, 01, 10, 11. Since the hello circuit is really just an and2 gate, the results should be 0, 0, 0, 1.</p></li>
</ul>
<p>There are several ways to run the simulation. There is a graphical user interface for Windows called WinGHCi. Alternatively, you can use commands in a shell.</p>
<h2 id="graphical-user-interface-windows-only"><a href="#graphical-user-interface-windows-only">Graphical user interface (Windows only)</a></h2>
<p>There is a graphical interface to Haskell for Windows computers called WinGHCi. Launch this; it should be available on the Start menu under Haskell Platform. Then you can interact with ghci with a number of graphical aids:</p>
<ul>
<li><p>Open the file browser (the folder icon, or File: Open) and navigate to Hydra-i.j.k/examples/helloworld.</p></li>
<li><p>Click HelloWorldRun.hs.</p></li>
<li><p>Run the program by clicking the red triangle, or using Actions: Run &quot;main&quot;.</p></li>
</ul>
<h2 id="one-line-command-using-the-haskell-compiler"><a href="#one-line-command-using-the-haskell-compiler">One-line command using the Haskell compiler</a></h2>
<p>You can tell ghc, the Haskell compiler, to compile the circuit and simulation driver and to execute the main in the driver, all with one command.</p>
<pre><code>cd examples/helloworld
ghc -e main HelloWorldRun</code></pre>
<p>You are running the driver. It isn't necessary to mention the circuit definition file, because HelloWorldRun.hs imports the circuit. You need to execute this in the directory that contains the circuit and the driver. After running the simulation, the compiled code is discarded.</p>
<h2 id="separate-compilation-and-execution"><a href="#separate-compilation-and-execution">Separate compilation and execution</a></h2>
<p>You can also compile the circuit and driver, and retain the executable, so it can be run again without recompilation.</p>
<pre><code>ghc --make HelloWorldRun
./HelloWorldRun</code></pre>
<p>Since this saves the object code, it will only work in a directory where you have permissions to save files. That's fine in your user workspace, but you might not have file write permissions in the Hydra installation directory.</p>
<h2 id="interacting-with-the-haskell-interpreter"><a href="#interacting-with-the-haskell-interpreter">Interacting with the Haskell interpreter</a></h2>
<p>Go to the directory that contains the circuit and driver, and launch the ghci interpreter. Then you can give it commands, which begin with colon (:).</p>
<pre><code>ghci
:load HelloWorldRun
:main</code></pre>
<p>This is sometimes quicker than using the ghc compiler, but the primary advantage is that it allows interactive testing. You aren't limited to executing <em>main</em>; you can enter expressions interactively.</p>
<h1 id="a-quick-overview-with-examples"><a href="#a-quick-overview-with-examples">A quick overview with examples</a></h1>
<p>This section shows several examples of circuits of increasing complexity. You may be able to design and simulate some circuits on your own by following and modifying these examples. The various design techniques are described in more detail in later sections.</p>
<h2 id="a-minimal-circuit-helloworld"><a href="#a-minimal-circuit-helloworld">A minimal circuit: helloWorld</a></h2>
<p>Files: <em>examples/helloworld/HelloWorld.hs</em> and <em>examples/helloworld/HelloWorldRun.hs</em></p>
<p>The HelloWorld circuit just contains one logic gate.</p>
<pre><code>module HelloWorld where
import HDL.Hydra.Core.Lib

hello :: Bit a =&gt; a -&gt; a -&gt; a
hello x y = and2 x y
</code></pre>
<p>The circuit itself is defined in a module HelloWorld, which is in the file named HelloWorld.hs. A module may contain any number of definitions. The module imports the standard library with <em>import HDL.Hydra.Core.Lib</em>. All circuit modules need this import; some modules will need additional import statements.</p>
<p>The circuit specification has two parts: a <em>type declaration</em> which contains the symbol :: and a <em>defining equation</em> which contains the symbol =.</p>
<p>To test the circuit, we can simulate it with some inputs. This requires a <em>simulation driver</em> which is defined in a separate module in the file HelloWorldRun.hs.</p>
<pre><code>module Main where
import HDL.Hydra.Core.Lib
import HelloWorld

main :: IO ()
main = helloRun testdata

testdata :: [[Int]]
testdata =
  [ [0,  0]
  , [0,  1]
  , [1,  0]
  , [1,  1]
  ]

helloRun input = runAllInput input output
  where
-- Extract input signals  
    x = getbit input 0
    y = getbit input 1
-- The circuit to be simulated
    z = hello x y
-- Format the output
    output =
      [string &quot;  x=&quot;, bit x,
       string &quot;  y=&quot;, bit y,
       string &quot;  output z=&quot;, bit z
      ]
</code></pre>
<p>Simulation drivers can be standalone modules containing the test data, as in HelloWorldRun. In this case, the name of the module should be <em>Main</em>. As well as importing the standard library, the module also needs to import the circuit.</p>
<p>A Main module should define a function <em>main</em> which will run the simulation. This defines one or more actions to perform; in this case there is only one action, which is to execute the simulation driver (helloRun) on the circuit's inputs (testdata).</p>
<p>The test data itself is a list of lists. The outer list gives the inputs for each clock cycle:</p>
<pre><code>testdata =
  [ inputs for clock cycle 0
  , inputs for clock cycle 1
  , inputs for clock cycle 2
  , inputs for clock cycle 3
  ]</code></pre>
<p>For any clock cycle, there is a list of inputs. Since the circuit has two inputs, each clock cycle gets a list of two values.</p>
<pre><code>testdata =
  [ [0,  0]    -- in cycle 0, x=0 y=0
  , [0,  1]    -- in cycle 1, x=0 y=1
  , [1,  0]    -- in cycle 2, x=1 y=0
  , [1,  1]    -- in cycle 3, x=1 y=1
  ]</code></pre>
<p>The simulation driver itself begins with <em>helloRun input = runAllInput input output</em>. See the section on simulation drivers for more details. In brief, the purpose of the driver is to convert inputs and outputs between a readable textual form and the internal signal representations needed by the circuit. It contains three sections. The first section defines the input signals for the circuit (x, y). The second section defines the output from the circuit (z). The third section formats what will be printed, which may include any of the signals along with label strings.</p>
<h2 id="connecting-several-logic-gates-mux1"><a href="#connecting-several-logic-gates-mux1">Connecting several logic gates: mux1</a></h2>
<p>Files: <em>examples/mux/Mux1.hs</em> and <em>examples/mux/Mux1Run.hs</em></p>
<p>The <em>multiplexer</em> is an example of a circuit that can be defined by conecting several logic gates together. It's not just an arbitrary example: the multiplexer is one of the most important building blocks for larger systems. There are many varieties of multiplexer; here we look at the 1-bit multiplexer, called <em>mux1</em>.</p>
<p>A multiplexer is a hardware version of the if-then-else expression, and is used to perform conditional actions in a circuit. It takes three inputs: a control input <em>c</em>, and two data inputs <em>x</em> and <em>y</em>.</p>
<p>The idea is that the multiplexer will choose one of the data inputs (<em>x</em> or <em>y</em>) and output it. The data input that is not chosen is simply ignored. The choice is determined by the value of <em>c</em>. Informally, the behavior of the multiplexer is:</p>
<pre><code>mux1 c x y = if c is zero then x else y</code></pre>
<p>(Aside: Sometimes it's helpful to describe some signals as <em>control signals</em> because they affect what the circuit does, and to describe others as <em>data signals</em> because they carry variable values. Since the behavior of the mux1 is controlled by <em>c</em>, this is a control input. Since <em>x</em> and <em>y</em> are just arbitrary values, these are called data signals. But it's important to realise that this terminology -- control and data signal -- is just a way of talking about the signals. As far as the actual components and wires are concerned, there is no difference between data and control.)</p>
<p>This if-then-else expression is a programming construct, and it doesn't directly correspond to digital hardware. The multiplexer can be implemented with logic gates.</p>
<p>To connect a circuit to an input, write the circuit followed by the input. Thus <em>inv c</em> says there is an inverter, and its input is connected to <em>c</em>, and the entire expression <em>inv c</em> denotes the output signal produced by the inverter. Similarly, <em>and2 (inv c) a</em> denotes the output of an and2 gate; its first input is the output of the inverter and its second input is <em>a</em>.</p>
<pre><code>mux1 c x y = or2 (and2 (inv c) x) (and2 c y)</code></pre>
<p>Here is the complete module defining the multiplexer:</p>
<pre><code>module Mux1 where
import HDL.Hydra.Core.Lib

-- mux1 is defined in the Hydra circuit libraries, so here the circuit
-- is called mymux1 to ensure that we&#39;re actually testing this
-- definition

mymux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mymux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</code></pre>
<p>We can run it with a simulation driver that runs the circuit on all possible inputs, so the outputs form a truth table. It's good practice to write the test data with clean indentation, so the inputs line up in columns, and to include the expected outputs in comments.</p>
<pre><code>module Main where
import HDL.Hydra.Core.Lib
import Mux1

main :: IO ()
main = mux1Run testdata

testdata :: [[Int]]
testdata =
-----------------------------------------
--   c  x  y       expected result
-----------------------------------------
  [ [0, 0, 0]  --  0  (c=0 so output=x)
  , [0, 0, 1]  --  0  (c=0 so output=x)
  , [0, 1, 0]  --  1  (c=0 so output=x)
  , [0, 1, 1]  --  1  (c=0 so output=x)
  , [1, 0, 0]  --  0  (c=1 so output=y)
  , [1, 0, 1]  --  1  (c=1 so output=y)
  , [1, 1, 0]  --  0  (c=1 so output=y)
  , [1, 1, 1]  --  1  (c=1 so output=y)
  ]

mux1Run input = runAllInput input output
  where
-- Extract input signals  
    c = getbit input 0
    x = getbit input 1
    y = getbit input 2
-- The circuit to be simulated
    z = mymux1 c x y
-- Format the output
    output =
      [string &quot;  c=&quot;, bit c,
       string &quot;  x=&quot;, bit x,
       string &quot;  y=&quot;, bit y,
       string &quot;    output z=&quot;, bit z
      ]
</code></pre>
<h2 id="producing-several-outputs-halfadd"><a href="#producing-several-outputs-halfadd">Producing several outputs: halfAdd</a></h2>
<p>Files: <em>examples/adder/HalfAdd.hs</em> and <em>examples/adder/HalfAddRun.hs</em></p>
<p>A half adder circuit takes two inputs <em>x</em> and <em>y</em>, and produces a pair of outputs, the carry output and the sum output. The carry is the logical <em>and</em> of <em>x</em> and <em>y</em>, while the sum is their exclusive <em>or</em>. Here is the circuit specification (file <em>HalfAdd.hs</em>):</p>
<pre><code>module HalfAdd where
import HDL.Hydra.Core.Lib

halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (and2 x y, xor2 x y)
</code></pre>
<p>The module statement gives a name to this module, and the import statement brings in the essential Hydra library definitions. The circuit definition is a one-line equation which says <em>halfAdd</em> is a circuit, gives names <em>x</em> and <em>y</em> to its inputs, and calculates the outputs using <em>and2</em> and <em>xor2</em> logic gates.</p>
<p>To see the circuit working, we can simulate it. This requires three things, all provided in <em>HalfAddRun.hs</em>:</p>
<ul>
<li><p>Suitable test data, expressed as a list of <em>[x,y]</em> inputs</p></li>
<li><p>A <a href="#simulation-drivers">Simulation driver</a>, which converts between human readable input and output and the internal signal representations. The simulation driver is not part of the circuit; it's simply formatting inputs and outputs.</p></li>
<li><p>A main program that runs the simulation driver on the test data.</p></li>
</ul>
<pre><code>module HalfAddRun where
import HDL.Hydra.Core.Lib
import HalfAdd

main :: IO ()
main = run_halfAdd testdata

testdata :: [[Int]]
testdata =
  [[0, 0],
   [0, 1],
   [1, 0],
   [1, 1]]

-- Simulation driver for half adder

run_halfAdd :: [[Int]] -&gt; IO ()
run_halfAdd input = runAllInput input output
  where
-- Extract input signals from simulation input
    x = getbit input 0
    y = getbit input 1
-- Connect the circuit to its inputs and outputs
    (c,s) = halfAdd x y
-- Format the simulation output
    output =
      [string &quot;Input: x = &quot;, bit x, string &quot; y = &quot;, bit y,
       string &quot;  Output: c = &quot;, bit c, string &quot; s = &quot;, bit s]
</code></pre>
<p>Run the simulation using any of the methods given above, e.g. enter <em>ghc -e main HalfAddRun</em>. Here is the result:</p>
<pre><code>$ ghc -e main HalfAddRun
Input: x = 0 y = 0  Output: c = 0 s = 0
Input: x = 0 y = 1  Output: c = 0 s = 1
Input: x = 1 y = 0  Output: c = 0 s = 1
Input: x = 1 y = 1  Output: c = 1 s = 0</code></pre>
<h2 id="black-box-with-internal-signals-add4"><a href="#black-box-with-internal-signals-add4">Black box with internal signals: add4</a></h2>
<p>Files: <em>adder/Add4.hs</em> and <em>examples/Add4Run.hs</em></p>
<pre><code>module Add4 where
import HDL.Hydra.Core.Lib
import HDL.Hydra.Circuits.Combinational

-- A 4-bit binary adder.  The fullAdd circuit is imported from the
-- Combinational library.  There is a better (but more advanced) way
-- to specify this circuit; see User Manual &gt; Combinators &gt; Scan.

add4 :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; (a,[a])
add4 cin [x0, x1, x2, x3] [y0, y1, y2, y3]
  = (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd (x0,y0) c1
    (c1,s1) = fullAdd (x1,y1) c2
    (c2,s2) = fullAdd (x2,y2) c3
    (c3,s3) = fullAdd (x3,y3) cin
</code></pre>
<pre><code>module Main where
import HDL.Hydra.Core.Lib
import Add4

main :: IO ()
main = run_add4 testdata

-- Each test is a list of [c, x, y] where c is the carry input (must
-- be 0 or 1) and x and y are integers between 0 and 15.  A number of
-- such tests are provided.

testdata :: [[Int]]
testdata =
--  c   x   y
  [[0,  5,  8],
   [0,  7,  3],
   [0,  8, 12],
   [0,  8,  1],
   [1, 12,  1],
   [1,  2,  3],
   [1, 15, 15]]

run_add4 :: [[Int]] -&gt; IO ()
run_add4 input = runAllInput input output
  where
-- Extract input signals
    cin = getbit   input 0
    x   = getbin 4 input 1
    y   = getbin 4 input 2
-- The circuit to be simulated
    (cout,s) = add4 cin x y
-- Format the output
    output =
      [string &quot;  x =&quot;, bindec 3 x,
       string &quot;  y =&quot;, bindec 3 y,
       string &quot;  cin = &quot;, bit cin,
       string &quot;    ==&gt;    cout = &quot;, bit cout,
       string &quot;  s =&quot;, bindec 3 s]
</code></pre>
<pre><code>*Main&gt; :main
  x =  5  y =  8  cin = 0    ==&gt;    cout = 0  s = 13
  x =  7  y =  3  cin = 0    ==&gt;    cout = 0  s = 10
  x =  8  y = 12  cin = 0    ==&gt;    cout = 1  s =  4
  x =  8  y =  1  cin = 0    ==&gt;    cout = 0  s =  9
  x = 12  y =  1  cin = 1    ==&gt;    cout = 0  s = 14
  x =  2  y =  3  cin = 1    ==&gt;    cout = 0  s =  6
  x = 15  y = 15  cin = 1    ==&gt;    cout = 1  s = 15
(0.00 secs, 252,808 bytes)
*Main&gt;</code></pre>
<h2 id="feedback-and-changing-state-bsr4"><a href="#feedback-and-changing-state-bsr4">Feedback and changing state: BSR4</a></h2>
<p>Files: <em>BSR4.hs</em> and <em>BSR4Run.hs</em></p>
<p>A bidirectional shift register</p>
<p>Define a shift register that takes an operation code op and data inputs x, li, ri, and performs an a state change depending on op:</p>
<ul>
<li>op=0 -- no state change</li>
<li>op=1 -- load input word x</li>
<li>op=2 -- shift right</li>
<li>op=3 -- shift left</li>
</ul>
<p>The circuit uses a building block srb (&quot;shift register block&quot;) which has an internal state to hold the bit in that position in the word. The inputs to an srb are an input from the left (for shifting to the right), an input from the right (for shifting to the left), and a bit input from the word x (for loading a word). The circuit outputs a triple: the left and right outputs, and the word giving the current state of the register. (Minor point: the left and right outputs aren't essential, as they also appear as the most and least significant bits of the word output, but this approach makes it easier to connect several sr4 circuits together, and it also fits well with the definition of the more general sr circuit below.)</p>
<p>The structure of the 4-bit version comes directly from the data dependencies.</p>
<p>The shift register block uses a dff to hold the state, and it uses a mux2 to determine the new value of the state. This is either the old value, the data bit x from a load, or the input from the left or right in case of a shift.</p>
<pre><code>module BSR4 where
import HDL.Hydra.Core.Lib
import HDL.Hydra.Circuits.Combinational

sr4 :: CBit a =&gt; (a,a) -&gt; a -&gt; a -&gt; [a] -&gt; (a,a,[a])
sr4 op li ri [x0,x1,x2,x3] = (y0, y3, [y0,y1,y2,y3])
  where
     y0 = srb op li y1 x0
     y1 = srb op y0 y2 x1
     y2 = srb op y1 y3 x2
     y3 = srb op y2 ri x3

srb :: CBit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a
srb op li ri x = y
  where y = dff (mux2 op y x li ri)
</code></pre>
<p>The test data and simulation driver are defined in <em>BSR4Run.hs</em>.</p>
<pre><code>module BSR4Run where
import HDL.Hydra.Core.Lib
import BSR4

main :: IO ()
main =  runBSR4 testdata

-- 0   no operation
-- 1   load input word x
-- 2   shift right
-- 3   shift left

testdata :: [[Int]]
testdata =
-----------------------------------
--  op l  r   x        op      y
-----------------------------------
  [[1, 0, 0,  9],  -- load 9   0
   [0, 0, 0,  0],  -- nop      9
   [3, 0, 0,  0],  -- shl 0    9
   [3, 0, 1,  0],  -- shl 1    2
   [0, 0, 0,  0],  -- nop      5
   [1, 0, 0,  4],  -- load 4   5
   [2, 1, 0,  0],  -- shr 1    4
   [2, 0, 0,  0],  -- shr 0    a
   [2, 0, 0,  0],  -- shr 0    5
   [2, 1, 0,  0],  -- shr 1    2
   [0, 0, 0,  0]]  -- nop      9

runBSR4 :: [[Int]] -&gt; IO ()
runBSR4 input = runAllInput input output
  where
-- Extract input signals from the input data
    op = getbit2  input 0
    l  = getbit   input 1
    r  = getbit   input 2
    x  = getbin 4 input 3
-- Connect the inputs and output signals to the circuit
    (lo,ro,y) = sr4 op l r x
-- Format the output signals
    output =
      [string &quot;op=&quot;, bit (fst op), bit (snd op),
       string &quot; l=&quot;, bit l,
       string &quot; r=&quot;, bit r,
       string &quot; x=&quot;, hex x,
       string &quot;   Output lo=&quot;, bit lo,
       string &quot; ro=&quot;, bit ro,
       string &quot; y=&quot;, hex y]

</code></pre>
<p>Running the circuit produces this:</p>
<pre><code>$ ghc -e main BSR4Run
op=01 l=0 r=0 x=9   Output lo=0 ro=0 y=0
op=00 l=0 r=0 x=0   Output lo=1 ro=1 y=9
op=11 l=0 r=0 x=0   Output lo=1 ro=1 y=9
op=11 l=0 r=1 x=0   Output lo=0 ro=0 y=2
op=00 l=0 r=0 x=0   Output lo=0 ro=1 y=5
op=01 l=0 r=0 x=4   Output lo=0 ro=1 y=5
op=10 l=1 r=0 x=0   Output lo=0 ro=0 y=4
op=10 l=0 r=0 x=0   Output lo=1 ro=0 y=a
op=10 l=0 r=0 x=0   Output lo=0 ro=1 y=5
op=10 l=1 r=0 x=0   Output lo=0 ro=0 y=2
op=00 l=0 r=0 x=0   Output lo=1 ro=1 y=9</code></pre>
<h1 id="modules-and-files"><a href="#modules-and-files">Modules and files</a></h1>
<h1 id="connecting-components-with-signals"><a href="#connecting-components-with-signals">Connecting components with signals</a></h1>
<p>A data value in a circuit is called a <em>signal</em>. A signal is carried by a wire, and it transmits information from one component to another. In logic design we don't usually care about the physical characteristics of a wire, although these can be important at the lower levels of chip design. Therefore we will usually refer to signals rather than wires.</p>
<p>The information carried by a signal may be represented as an individual bit or a cluster comprising several bits. We can also describe circuits at a higher level, where signals represent integers or other data types.</p>
<p>A bit (binary digit) can have one of two distinct values. Several names are commonly used for these values, including 0/1, Low/High, False/True, and F/T. In real hardware a bit signal is represented by a voltage, but the precise voltage value is unimportant at the level of logic design. The particular names chosen for the two bit values are also unimportant, although they can affect the readability of a table showing the behavior of a circuit. When Hydra prints out the values of bit signals, it will normally use 0 and 1, but you can tell it to use False and True, or any other names you prefer. One advantage of 0/1 is that they are consistent with treating a bit as a binary digit (False/True suggest treating a bit as a Boolean). Another advantage of 0 and 1 is that they take up only one character and they look different. (Try reading a table showing thousands of F and T characters -- they can be hard to tell apart!).</p>
<h2 id="logic-gates"><a href="#logic-gates">Logic gates</a></h2>
<p>To design a new circuit, you need to take a set of existing circuits and connect them with signals. There are several libraries of existing circuits that you can start with, and you can also define libraries of your own circuits for further use. The Hydra libraries provide as primitives the standard logic gates, summarised in the following table.</p>
<p>The buffer simply produces an output that is the same as the input; it is the identify function. The inverter outputs 0 if its input is 1, and outputs 1 if its input is 0.</p>
<p>Many of the logical operations can be performed on any number of inputs. For example, there is the logical conjunction (<em>and</em>) of two, three, or four inputs. These correspond to distinct logic gates: the <em>and2</em> gate has two input ports and there is no way to connect three inputs to it. Therefore Hydra doesn't have an <em>and</em> gate; it has distinct <em>and2</em>, <em>and3</em>, <em>and4</em> gates. This doesn't go on indefinitely; Hydra does not define the <em>and5</em> gate or the <em>and73</em> gate! (A convenient way to <em>and</em> together large number of inputs is to use <em>andw</em>.)</p>
<table>
<thead>
<tr class="header">
<th align="left">Component</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">buf a</td>
<td align="left">buffer</td>
</tr>
<tr class="even">
<td align="left">inv a</td>
<td align="left">inverter</td>
</tr>
<tr class="odd">
<td align="left">and2 a b</td>
<td align="left">2-input and gate</td>
</tr>
<tr class="even">
<td align="left">and3 a b c</td>
<td align="left">3-input and gate</td>
</tr>
<tr class="odd">
<td align="left">and4 a b c d</td>
<td align="left">4-input and gate</td>
</tr>
<tr class="even">
<td align="left">or2 a b</td>
<td align="left">2-input or gate</td>
</tr>
<tr class="odd">
<td align="left">or3 a b c</td>
<td align="left">3-input or gate</td>
</tr>
<tr class="even">
<td align="left">or4 a b c d</td>
<td align="left">4-input or gate</td>
</tr>
<tr class="odd">
<td align="left">xor2 a b</td>
<td align="left">2-input xor gate</td>
</tr>
<tr class="even">
<td align="left">xor3 a b c</td>
<td align="left">3-input xor gate</td>
</tr>
<tr class="odd">
<td align="left">xor4 a b c d</td>
<td align="left">4-input xor gate</td>
</tr>
<tr class="even">
<td align="left">nand2 a b</td>
<td align="left">2-input nand gate</td>
</tr>
<tr class="odd">
<td align="left">nand3 a b c</td>
<td align="left">3-input nand gate</td>
</tr>
<tr class="even">
<td align="left">nand4 a b c d</td>
<td align="left">4-input nand gate</td>
</tr>
<tr class="odd">
<td align="left">nor2 a b</td>
<td align="left">2-input nor gate</td>
</tr>
<tr class="even">
<td align="left">nor3 a b c</td>
<td align="left">3-input nor gate</td>
</tr>
<tr class="odd">
<td align="left">nor4 a b c d</td>
<td align="left">4-input nor gate</td>
</tr>
<tr class="even">
<td align="left">xnor2 a b</td>
<td align="left">2-input xnor gate</td>
</tr>
<tr class="odd">
<td align="left">xnor3 a b c</td>
<td align="left">3-input xnor gate</td>
</tr>
<tr class="even">
<td align="left">xnor4 a b c d</td>
<td align="left">4-input xnor gate</td>
</tr>
</tbody>
</table>
<p>Most of these logic gates are provided for convenience, but only a few of them are necessary. For example, you can replace <em>and3 a b c</em> by <em>and2 a (and2 b c)</em>. However, logic gates with several inputs can be fabricated on chips, they are slightly more efficient, and most importantly, it's more readable to use <em>and3</em> rather than two <em>and2</em> gates.</p>
<h2 id="connecting-a-circuit-to-inputs"><a href="#connecting-a-circuit-to-inputs">Connecting a circuit to inputs</a></h2>
<p>Suppose we have two signals named <em>x</em> and <em>y</em>, and want to connect them to the inputs of an <em>or2</em> gate. This is done by writing the name of the component, followed by the names of the input signals:</p>
<pre><code>or2 x y</code></pre>
<p>The value of this expression is the output of the <em>or2</em> gate. Such an expression is called an <em>application</em> because the component is applied to its input signals.</p>
<p>Each circuit takes a specific number of inputs, and an application using that circuit must supply the corresponding number of input signals. Here are several applications of logic gates, each with the right number of inputs.</p>
<pre><code>inv x
and2 a one
xor3 p q r
nor4 a zero c d</code></pre>
<h2 id="anonymous-signals"><a href="#anonymous-signals">Anonymous signals</a></h2>
<p>A signal may be given a name, such as <em>x</em> or <em>y</em>, although this is optional. You can also refer to a signal using an application of a component to its inputs, such as <em>inv x</em>; the output of the inverter is an anonymous signal as it has no name.</p>
<p>An anonymous signal is described by an expression with several tokens. When you use it as an input to a circuit, this expression must be enclosed by parentheses, to turn it into a single object. For example, suppose we want to connect the first input to an <em>and2</em> gate to the output of an inverter whose input is <em>x</em>. The second input to the <em>and2</em> gate should be <em>y</em>. Here is the correct way to write it:</p>
<pre><code>and2 (inv x) y</code></pre>
<p>There are two expressions following <em>and2</em>, denoting its two inputs. The following notation would be wrong:</p>
<pre><code>and2 inv x y   -- Wrong!</code></pre>
<p>Here, it looks like the <em>and2</em> gate is being given three inputs, and the first one isn't even a signal.</p>
<p>Parentheses are used in Hydra for grouping, just as in mathematics. You don't need to use parentheses just to specify the arguments to a function (that is, the inputs to a circuit). Some programming languages requires lots of punctuation to indicate function application:</p>
<pre><code>nand3 (x, and2 (p,q), z);   -- Wrong!</code></pre>
<p>In Hydra (as in Haskell) you don't need the extra parentheses and commas, and they will lead to error messages. Use parentheses only when they are necessary to get the right grouping:</p>
<pre><code>nand3 x (and2 p q) z</code></pre>
<p>It can be helpful to give both a schematic diagram and a textual specification for a circuit. Each form of description provides insight, and having both together is often worthwhile. It's important to check that the two descriptions of the circuit are consistent with each other. To do this, check that every box in the diagram corresponds to a circuit (function) in the text, and check that the wires in the diagram correspond to the signals in the text.</p>
<p><a name="exercise:or2-and2"><strong>Exercise</strong></a> <a href="#solution:or2-and2"><em>(Go to solution)</em></a> Write the Hydra notation for this schematic diagram: <img src="figures/xfig/andor.svg" title="schematic diagram" /></p>
<p><a name="exercise:inv-and2"><strong>Exercise</strong></a> <a href="#solution:inv-and2"><em>(Go to solution)</em></a> Draw a schematic diagram for <em>inv (and2 a b)</em>.</p>
<p><a name="exercise:xor2-nand3"><strong>Exercise</strong></a> <a href="#solution:xor2-nand3"><em>(Go to solution)</em></a> Draw a schematic diagram for <em>xor2 (nand3 p q r) (or2 x y)</em>.</p>
<h2 id="named-signals-and-equations"><a href="#named-signals-and-equations">Named signals and equations</a></h2>
<p>Sometimes it's useful to give a name to a signal, rather than using it anonymously. A named signal can be used as an input to several different components, but an anonymous signal cannot. Names can also make it easier to explain the circuit, and well chosen names help document the purpose of a signal.</p>
<p>A signal can be named using an equation. The left hand side of the equation is the name, and the right hand side is an expression that defines the signal. The following equation says that the output of the <em>and3</em> gate has the name <em>x</em>.</p>
<pre><code>x = and3 a (inv b) c</code></pre>
<p>Sometimes the choice between anonymous and named signals is just a matter of style. Here is a signal defined using three anonymous signals:</p>
<pre><code>x = nand2 (xor2 a b) (inv (nor2 c d))</code></pre>
<p>This can be rewritten so as to give every signal an explicit name, by introducing additional equations:</p>
<pre><code>x = nand2 p q
p = xor2 a b
q = inv r
r = nor2 c d</code></pre>
<p>An equation like this is called a <em>defining equation</em>, because the left hand side has to be a signal name whose value is defined to be the right hand side. It would be wrong, for example, to write</p>
<pre><code>nand2 p q = x   -- Wrong!</code></pre>
<p>When using <em>equational reasoning</em> you will encounter equations with a more general form, but in defining signals, the left hand side is always a signal name.</p>
<h2 id="constant-signals"><a href="#constant-signals">Constant signals</a></h2>
<p>A constant signal always carries the same value: either it is always 0, or always 1. The names of these two constants are written as <em>zero</em> and <em>one</em>. Names in Hydra always begin with a lower case letter, never with a digit. Don't use 0/1, or T/F, or True/False in a circuit specification; those notations have other meanings and will lead to bizarre error messages.</p>
<h1 id="defining-new-circuits"><a href="#defining-new-circuits">Defining new circuits</a></h1>
<p>A new circuit can be designed by connecting together a number of existing ones. The examples given so far consist of logic gates, which are primitive components. To design larger scale systems, we need the ability to define a circuit as a new <em>black box</em> component and reuse it. This is similar to using abstraction in a programming language by defining a function or procedure for a commonly used computation. A circuit definition contains up to three parts:</p>
<ol style="list-style-type: decimal">
<li><p>Circuit type (optional)</p></li>
<li><p>Interface (mandatory)</p></li>
<li><p>Internal signals (optional)</p></li>
</ol>
<h2 id="circuit-type"><a href="#circuit-type">Circuit type</a></h2>
<p>The circuit type is covered in a later section. It's optional, although it is generally best to include it. If present, the type can be recognized by the :: symbol and a number of right arrow symbols; a typical example is</p>
<pre><code>halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)</code></pre>
<h2 id="interface"><a href="#interface">Interface</a></h2>
<p>The interface gives the name of the circuit and names its inputs and outputs. A circuit is created with a <em>circuit defining equation</em>. The left hand side of the equation is the name of the circuit followed by the names of the input signals. There may be any number of inputs. The right hand side is an expression giving the value of the output signal:</p>
<pre><code>circ_name input1 input2 = expression</code></pre>
<p>This defines a circuit whose name is <em>circ_name</em>, which takes two inputs named <em>input1</em> and <em>input2</em>, and produces an output with the specified signal value. Here is an example:</p>
<pre><code>mycirc a b c = and3 a (inv b) c</code></pre>
<p>The input names <em>a</em>, <em>b</em>, and <em>c</em>, are local to the definition of <em>mycirc</em>, and they can be used to calculate the value of the output. Another circuit can connect signals with arbitrary names, or no names at all, to the inputs of <em>mycirc</em>.</p>
<h2 id="internal-signals"><a href="#internal-signals">Internal signals</a></h2>
<p>This part of a definition is optional; if present it follows the <em>where</em> keyword.</p>
<p>The expression that defines the circuit's output can become fairly complicated, and it's often simpler to define it using several other named signals. Each of these needs a defining equation which is inside the circuit. To do this, write the keyword <em>where</em> after the equation, and after the <em>where</em> you can write any number of signal defining equations. The general form is:</p>
<pre><code>circuit_name input1 input2 = output
  where
    output = ...
    x = ... (internal signals...)
    y = ...</code></pre>
<p>Here is an example of a circuit named c22 that takes three inputs and produces one output.</p>
<pre><code>c22 a b c = x
  where
    x = xor2 p q
    p = and2 a b
    q = or2 b c</code></pre>
<p>The equations should be indented consistently, and there is no extra punctuation (no curly braces, no semicolons). The compiler determines the structure of a definition from the indentation, not from punctuation. Therefore the indentation is essential, and if it's wrong then the specification will be parsed incorrectly.</p>
<h2 id="multiple-outputs"><a href="#multiple-outputs">Multiple outputs</a></h2>
<h2 id="feedback"><a href="#feedback">Feedback</a></h2>
<p>A register is a circuit with an internal state, and with the ability to load an external value into the state and to read out the state.</p>
<pre><code>reg1 :: CBit a =&gt; a -&gt; a -&gt; a
reg1 ld x = r
  where r = dff (mux1 ld r x)</code></pre>
<p>The reg1 circuit has a feedback loop: the output of the flip flop is connected to one of the inputs to the mux1, whose output in turn is input to the flip flop. Hydra does not allow feedback loops in pure combinational logic, but feedback that goes through a flip flop is fine. When a circuit contains a feedback loop, there will be a circular path in the schematic diagram, and there will be circular equations in its specification. For the reg1 circuit. the feedback loop can be seen in the equation which has r on both the left and right hand side. Thus r is being defined in terms of itself. The way this works, and the reason that r is well-defined, is explained in the section on circuit semantics.</p>
<h1 id="signal-and-circuit-types"><a href="#signal-and-circuit-types">Signal and circuit types</a></h1>
<p>The <em>type</em> of a value determines what operations you can perform on it. This holds for hardware description just as for programming. The type of a signal determines what kind of information it carries, and the type of a circuit specifies the types and organisation of its input and output signals.</p>
<p>A circuit has an interface to the outside world, and an internal organization. To use the circuit, all we need to know about is the interface: what inputs need to be provided and what the outputs mean. The type expresses a useful portion of this information: it describes the number and organization of the inputs and outputs. The meanings of the circuit outputs are not specified by the type; they should be described in documentation for the circuit. Since Hydra models a circuit as a function, a circuit type looks just like a function type.</p>
<p>The type declaration for a circuit is optional, as the compiler can work out the type for itself. If you omit the type, your circuit will still run. However, there are several benefits in writing out the type explicitly:</p>
<ul>
<li><p>The type gives useful information about the interface to the circuit. Later on, if you want to use this circuit in a larger one, you will be more interested in the interface than the internal components inside the circuit.</p></li>
<li><p>There is some redundancy between the type and the defining equation. If there is any inconsistency between the two, the compiler will give a type error message. That may be annoying, but at least you know that the error lies somewhere in the (small) specification of this one circuit. If you omit the type declaration, but there is an error in the defining equation, you may get an error message that says, in effect, `there is an error somewhere in the (large) file', but it's up to you to figure out <em>where</em> the error is.</p></li>
<li><p>If you do get a type error message, the compiler will do its best to give a helpful and informative message. In practice, though, the error messages will be far more understandable if you include type declarations for your circuits.</p></li>
</ul>
<p>If present, the type of a circuit should come immediately before the defining equation. Type declarations are easily recognizable: they always contain the symbol <em>::</em>, and usually contain some arrows <em>=&gt;</em> and <em>-&gt;</em>. A typical example is</p>
<pre><code>reg1 :: CBit a =&gt; a -&gt; a</code></pre>
<p>A type declaration contains several parts:</p>
<ul>
<li>The circuit name (e.g. reg1)</li>
<li>The :: symbol, read as &quot;has type&quot;</li>
<li>The signal class ending with =&gt; (e.g. CBit a =&gt;)</li>
<li>The input and output signal types (e.g. a -&gt; a)</li>
</ul>
<h2 id="signal-types-and-classes"><a href="#signal-types-and-classes">Signal types and classes</a></h2>
<p><em>Short version.</em> If you're writing a routine circuit and just want to simulate it, you can just write <em>CBit a =&gt;</em> for the signal class constraint and then use <em>a</em> as the type for every bit signal. In more complicated situations, or if you want to know what this means, read on.</p>
<p>When a circuit specification is executed, each signal has a specific type. Many types can be used, for example <em>Bool</em> or <em>Stream Lattice</em>. The choice of type determines what happens during execution. Some types lead to combinational simulation, others lead to synchronous simulation, others perform a path depth analysis, or generate a netlist.</p>
<p>It's possible to define a circuit with a specific type, and if you do this the class constraint (the part before =&gt;) is omitted. For example, we could define a Bool version of the mux1 circuit (call it halfAddB) to operate in signals of type Bool:</p>
<pre><code>halfAddB :: Bool -&gt; Bool -&gt; (Bool,Bool)
halfAddB x y = (and2 x y, xor2 x y)</code></pre>
<p>This is a little simpler than the standard definition halfAdd, which (1) uses the type class constraint Bit a =&gt;, and (2) uses <em>a</em> rather than <em>Bool</em> as the bit signal type.</p>
<h2 id="combinational-signals-bit-a"><a href="#combinational-signals-bit-a">Combinational signals: Bit a</a></h2>
<pre><code>halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (and2 x y, xor2 x y)</code></pre>
<p>The main disadvantage of using Bool as the signal type is that combinational simulation is the <em>only</em> thing you can do with the circuit. However, Hydra provides many other options. For example, you can perform synchronous simulations over many clock cycles, but to do that, the signals must have a different type. You can do these other things with <em>halfAdd</em>, but not with <em>halfAddB</em>.</p>
<p>There is several sets of different type that can be used to represent a signal. Each set offers a number of operations that can be performed on the signal. For example, <em>Bit</em> is one of these sets; the notation <em>Bit a =&gt;</em> means that <em>a</em> can be any type in the set <em>Bit</em>, and therefore all of the Bit operations can be performed on a signal of type <em>a</em>.</p>
<p>The commonest signal class constraints are:</p>
<ul>
<li><p>Bit a =&gt; is used when <em>a</em> is a bit signal in a circuit, so logic gates can be used. The circuit may be either combinational or sequential. The Bit class allows combinational simulation tools to be used, but flip flops are not allowed in the circuit.</p></li>
<li><p>CBit a =&gt; is used when <em>a</em> is a bit signal in a circuit, so logic gates may be used. The circuit must be synchronous with a clock, and flip flops may be used.</p></li>
</ul>
<h2 id="clocked-signals-bit-a"><a href="#clocked-signals-bit-a">Clocked signals: Bit a</a></h2>
<p>The signal class constraint Classes</p>
<p>Base signal types</p>
<ul>
<li><p>Bool (defined in Haskell standard libraries)</p></li>
<li><p>Word16 (defined in Haskell standard libraries)</p></li>
<li><p>Word32 (defined in Haskell standard libraries)</p></li>
<li><p>Lattice (defined in Hydra Core library)</p></li>
</ul>
<h2 id="inputs-and-outputs"><a href="#inputs-and-outputs">Inputs and outputs</a></h2>
<p>After the signal class (i.e. after the <em>=&gt;</em> symbol) come the types of the inputs and output of the circuit. In the simplest case, each input or output signal is just a bit of type <em>a</em>. There may be any number of input arguments, and there must be one output result. A single arrow <em>-&gt;</em> must follow each input; thus the number of single arrows in the type is the same as the number of inputs.</p>
<p>The inverter has one input of type <em>a</em>, which is followed by <em>-&gt;</em>, and the type <em>a</em> of the output appears last. The type declaration can be read as &quot;inv uses signals in the Bit class; it takes one input and produces one output&quot;: Thus the entire type declaration <code>*inv :: Bit a =&gt; a -&gt; a*' says</code><em>inv</em> is a circuit that takes an input bit signal, and produces an output bit signal.'</p>
<pre><code>inv :: Bit a =&gt; a -&gt; a</code></pre>
<p>The notation <em>a -&gt; a</em> means &quot;the circuit takes an input signal and produces an output signal&quot;. This is similar to conventional mathematical notation; for example in mathematics there is a function <em>im</em> that is given a complex number (type <span class="math"><em>C</em></span>) and returns its imaginary part (type <span class="math"><em>R</em></span>), and a mathematician might write its type as im : C -&gt; R. (The reason :: is used in Haskell (and Hydra) is that : is used for something else.)</p>
<p>Circuits that take several inputs have a slightly more complicated type. For example, here are the types for the family of and-gates:</p>
<pre><code>and2 :: Bit a =&gt; a -&gt; a -&gt; a
and3 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
and4 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a -&gt; a</code></pre>
<p>There is always one output, but any number of inputs, and every input is followed by <em>-&gt;</em>. To find out how many inputs a circuit takes, just count the number of times <em>-&gt;</em> appears in its type.</p>
<p>If a circuit has several outputs, they must be enclosed in a container, and this is reflected in the type. See the section on Containers.</p>
<h1 id="containers"><a href="#containers">Containers</a></h1>
<p>In a physical circuit, every wire carries one bit, and doesn't have any relationship to any other wire (unless it is actually connected to that other wire). When we design a circuit, however, it takes several wires to carry any data value that isn't just a Boolean. For example, it takes 16 wires to transmit a 16-bit word, and to the designer there is definitely a clear relationship among these wires.</p>
<p>Circuits may contain large numbers of signals, and it would be tiresome to name them all. You can simplify the description of a circuit by defining <em>containers</em> that hold a collection of signals. Then you can use the container as a single object, without referring explicitly to its components.</p>
<p>A design is clearer if related signals together are grouped together, with a name for the entire collection. For example, we could give the name <em>x</em> to a 16-bit word, and just use <em>x</em> to refer to all the wires collectively.</p>
<p>Hydra provides two kinds of container: <em>tuples</em> and <em>words</em>. Tuples are useful for circuits that have multiple inputs and outputs; an example of a tuple is <em>(x, (a,b))</em>. Words are appropriate when several signals are used to represent a number, for example <em>[x0,x1,x2,x3]</em>.</p>
<p>Both kinds of container are written with several elements separated by commas. A quick way to tell them apart is that tuples use round parentheses <em>( ... )</em> but words use square brackets <em>[ ... ]</em>.</p>
<p>Containers are just notations that help to simplify the description of large circuits. If you look at the layout of a chip under a microscope, you won't see any tuples or words---just thousands of individual wires and components. A circuit specification that names each one explicitly would be long and unreadable; containers enable us to write compact and readable descriptions of such large circuits.</p>
<h2 id="tuples"><a href="#tuples">Tuples</a></h2>
<p>Tuples provide the simplest way to give a single name to a bundle of signals.</p>
<p>Suppose we have a couple of signals named <em>a</em> and <em>b</em>. They can be collected together into a tuple by writing <em>(a,b)</em>. The elements are written inside round parentheses ( ... ) and separated by commas.</p>
<p>The elements of the tuple are expressions that describe signals. Any expression can be used; it doesn't have to be a signal name. For example, the tuple <em>(and2 x y, or2 x y)</em> is a tuple consisting of two signals, the outputs of two logic gates. In this example, the actual signals in the tuple don't have names.</p>
<p>A tuple can have any number of elements. Thus <em>(inv x, y, z)</em> is a 3-tuple and <em>(a,b,c,d)</em> is a 4-tuple.</p>
<p>If the basic signal type is <em>a</em>, as usual, then a 2-tuple has type <em>(a,a)</em>, a 3-tuple has type <em>(a,a,a)</em>, and so on. The type shows explicitly the number of elements.</p>
<p>One of the commonest ways to use a tuple is to describe a circuit that has several outputs. Indeed, there is no way to do this without using a cluster (a tuple or a word). Recall that the type of a circuit contains a number of arrows (<em>-&gt;</em>) and the type of the output comes after the last arrow. If there are actually several outputs, we need to combine them into a cluster and give the cluster's type as the type of the output.</p>
<p>Here is an example. Suppose we want to define a circuit that has two input bit signals, called <em>x</em> and <em>y</em>. The circuit produces two outputs, <em>and2 x y</em> as well as <em>or2 x y</em>. Let's name the circuit <em>aor2</em>. Here is a full definition:</p>
<pre><code>aor :: Bit a =&gt; a -&gt; a -&gt; (a,a)
aor x y = (and2 x y, or2 x y)</code></pre>
<p>The definition of <em>aor</em> consists of two parts: a type declaration (the line containing <em>::</em>), and a defining equation (thie line containing the <em>=</em>). In general, every circuit specification should contain these two parts.</p>
<p>Notice that there are two arrows (<em>-&gt;</em>) in the type. This means that there are two inputs, and each has type <em>a</em> --- that is, each input is a bit signal. The type of the output comes after the last arrow, and it is <em>(a,a)</em>, so the output of the circuit is a tuple containing two bit signals.</p>
<p>The signal defining equations we have considered up to now have had a signal name on the left hand side: <em>x = ...</em>. In general, however, the left hand side of an equation is a <em>pattern</em>.</p>
<p>It is also possible to have an input cluster. The <em>aor</em> circuit above has two inputs, and these were treated separately: there are two arrows in the type, one after each input type. An alternative notation is to say that the circuit has just one input, which is a cluster containing two elements:</p>
<pre><code>aorTup :: Bit a =&gt; (a,a) -&gt; (a,a)
aorTup (x,y) = (and2 x y, or2 x y)</code></pre>
<p>Compare the definitions of <em>aorTup</em> and <em>aor</em>. Both of them have two input bits named <em>x</em> and <em>y</em>, but they are organized differently. In <em>aor</em>, the inputs are treated as separate arguments, each of type <em>a</em>, and each followed by an arrow <em>-&gt;</em>. In <em>aorTup</em>, the input bits are collected together into the tuple <em>(x,y)</em> which has type <em>(a,a)</em>, and this tuple is the sole argument.</p>
<p>These two circuits, <em>aor</em> and <em>aorTup</em>, are essentially the same. They would look identical on a VLSI chip under the microscope. The only difference between them is the notation used to describe them.</p>
<p>There is an asymmetry in the notation. If a circuit has several inputs, there is a choice of notation: they can be treated as separate arguments, or they can be collected together into a tuple. However, if a circuit has several outputs, there is no choice: they <em>must</em> be collected together into a tuple.</p>
<p>This notation for types, with the arrows and the (apparently) different treatment of circuit inputs and outputs, may look strange and counterintuitive. There is actually a very good reason the type notation is designed this way, but it involves some techniques we are not ready to discuss yet (see the chapter on design patterns).</p>
<p>There are other uses for tuples besides just handling circuits with multiple outputs. Sometimes tuples are useful just for cutting some of the boilerplate in a specification, making it shorter and easier to read. Suppose we have a circuit where two signals, say <em>x</em> and <em>y</em>, are needed as inputs to several other building block circuits <em>f1</em>, <em>f2</em>, and <em>f3</em>. We could write the specification with all the signals written out explicitly:</p>
<pre><code>circ :: Bit a =&gt; a -&gt; a -&gt; a
circ x y = z
  where
     p = f1 x y
     q = f2 x y
     r = f3 x y
     z = xor3 p q r</code></pre>
<p>But we might be able to simplify this by changing the types of <em>circ</em>, <em>f1</em>, <em>f2</em>, and <em>f3</em> to collect <em>x</em> and <em>y</em> into a tuple.</p>
<pre><code>circ :: Bit a =&gt; (a,a) -&gt; a
circ xy = z
  where
     p = f1 xy
     q = f2 xy
     r = f3 xy
     z = xor3 p q r</code></pre>
<p>In a large and complicated system, this technique can make a big difference. For example, in a processor circuit there may be a number of signals needed to control the arithmetic-logic unit, and those signals travel together. It can cut down on the notation significantly just to combine them into a tuple, give the tuple a name, and pass around the whole cluster without mentioning the individual components.</p>
<p>Sometimes you may have a cluster, but you need to extract its elements and give them individual names. This can be done in a circuit black box definition using a signal defining equation. For example, the following equation defines <em>alpha</em> and <em>beta</em> to be the names of the elements of a tuple named <em>pair</em>:</p>
<pre><code>(alpha,beta) = pair</code></pre>
<p>Tuples can be nested. For example, <em>(p, (x,y,z))</em> is a 2-tuple (<em>not</em> a 4-tuple!). The first element is <em>p</em>, and the second element is a 3-tuple <em>(x,y,z)</em>. The type is</p>
<pre><code>(p, (x,y,z)) :: (a, (a,a,a))</code></pre>
<p>This example shows a crucial property of tuples: their elements may have different types; in this case the type of the first element is <em>a</em> and the type of the second element is <em>(a,a,a)</em> and those types are different, just as a physical wire is not the same thing as a bundle of three physical wires.</p>
<p>Why use a tuple type like <em>(a,(a,a,a))</em> when a simple 4-tuple would seem simpler? The reason is that sometimes, in larger systems, a sub-circuit produces many outputs, and groups of them will then be connected to different destinations. The notation to describe this is simpler if the tuple structure matches the logical organization of the circuit. We will see several examples of this, especially in the design of processors.</p>
<p>It is also possible to have two different signal representations in a specification. Each one needs its own distinct type variable name. For example, suppose we are designing a circuit that has a basic bit signal type <em>a</em>, but the circuit also has some values where we aren't concerned about the bit representation (floating point numbers, perhaps). To abstract away from the bit representation, we could give another type <em>b</em> to these abstract values. Then a black box circuit that outputs both a bit and a floating point number would have the output type <em>(a,b)</em>.</p>
<h2 id="words"><a href="#words">Words</a></h2>
<p>There are two kinds of cluster that allow several signals to be collected together into one entity. The previous section discussed tuples, and now we introduce words. Tuples allow arbitrary groupings, while words have a regular structure and their elements can be accessed by indexing. Words are frequently used for collections of bits that represent binary numbers.</p>
<p>In a word, bit indices are 0, 1, ..., n-1 where bit 0 is most significant. The expression <em>[x0,x1,x2,x3]</em> denotes a word containing the individual signals <em>x0</em>, ..., <em>x3</em>. The syntax is similar to a tuple; the difference is that an expression for a word uses square brackets <em>[  ]</em> while a tuple uses round parentheses <em>(  )</em>.</p>
<p>The basic usage of a word is similar to a tuple. For example, a circuit could collect several signals into a word and output that. Here is an alternative definition of the half adder:</p>
<pre><code>halfAddw :: Bit a -&gt; a -&gt; a -&gt; [a]
halfAddw x y = [c,s]
  where
    c = and2 x y
    s = xor2 x y</code></pre>
<p>There two differences between this definition and the one given earlier. First the output expression here is <em>[c,s]</em>, so it's a word, while the output expression given for the original <em>halfAdd</em> is <em>(c,s)</em>, which is a tuple. The other difference is quite important: the output type is <em>[a]</em>, rather than <em>(a,a)</em> for the original <em>halfAdd</em>.</p>
<p>All the elements of a word must have the same type. If this type is <em>a</em>, then the word has type <em>[a]</em>. The type of a word doesn't specify how many elements the word contains. This is different from a tuple, where <em>(a,a)</em> contains exactly two elements, and <em>(a,a,a,a)</em> contains exactly four elements.</p>
<p>Each element of a word has an index, a natural number that gives its position within the word. You can think of a word as an array or vector. The index of the leftmost position is 0, and the index of the rightmost position is <em>k-1</em>, where <em>k</em> is the length of the word. If we have defined some bit signals <em>x0</em>, <em>x1</em>, <em>x2</em>, and <em>x3</em>, then we could define a word <em>x</em> of these bits with the equation</p>
<pre><code>w = [x0,x1,x2,x3]</code></pre>
<p>There are actually two conventions commonly used in computer systems. One convention starts with position 0 at the left end, and counts up going to the right. This is called <em>big Endian</em> notation. The other convention, naturally called <em>little Endian</em>, starts with 0 as the index of the rightmost element, and the indices count up going to the left.</p>
<pre><code>[x0,x1,x2,x3]   -- Big Endian convention
[x3,x2,x1,x0]   -- Little Endian convention</code></pre>
<p>As you might imagine, neither convention is fundamentally better than the other, but there are all sorts of minor issues that might cause one to be preferred over the other. Hydra allows both conventions, but in this book we will stick to Big Endian consistently.</p>
<p>There seems to be a phenomenon in computer systems, where the less significant an issue is, the more heated debate there is about it. This phenomenon was actually the inspiration for the odd names Big/Little Endian. The names come from Gullivers Travels, by Jonathan Swift, where the citizens of the kingdom of Blefuscu open their eggs at the big end, while the citizens of Lilliput open their eggs at the little end. The application of this story to computer systems comes from an article by Danny Cohen, `On Holy Wars and a Plea for Peach' (IEEE Computer, October 1981).</p>
<p>The point here (aside from an entertaining digression) is that having a standard is a good idea, and arguments for one particular choice are less compelling than having a consistent standard. Nevertheless, there is one situation in hardware description where Little Endian is slightly more convenient than Big Endian (see ref????) and some authors actually combine both conventions. The confusion isn't worth it!</p>
<p>The size or length of a word is the number of elements it contains. If a word contains <span class="math"><em>k</em></span> elements, then their indices range from 0 to <span class="math"><em>k</em> − 1</span>. Hydra provides a meta-function <em>length</em> that takes a word and returns an integer giving its size.</p>
<pre><code>length :: [a] -&gt; Int</code></pre>
<p>For example, <em>length [x0,x1,x2] = 3</em>. With just the parts of Hydra covered so far, there is no way to use the length of a word, but later we will encounter some more powerful features where an algorithm will generate a circuit of a given size, and then the <em>length</em> function will be useful. It's important to remember that <em>length</em> is not a circuit; it is part of the notation used to describe circuits.</p>
<p>There are several notations and operators that can be used to build words from signals, and for extracting the signals within a word. The following sections introduce these notations, and then a couple of example circuits will be presented.</p>
<h2 id="example-2-a-circuit-with-words-and-internal-signals"><a href="#example-2-a-circuit-with-words-and-internal-signals">Example 2: A circuit with words and internal signals</a></h2>
<p>Files: <em>Add4.hs</em> and <em>Add4Run.hs</em></p>
<p>The <em>add4</em> circuit takes two 4-bit binary numbers <em>x</em> and <em>y</em>, and a carry input <em>c</em>. It adds them and outputs a carry output bit and a 4 bit sum. The circuit is defined in <em>Add4.hs</em>.</p>
<pre><code>module Add4 where
import HDL.Hydra.Core.Lib
import HDL.Hydra.Circuits.Combinational

-- A 4-bit binary adder.  The fullAdd circuit is imported from the
-- Combinational library.  There is a better (but more advanced) way
-- to specify this circuit; see User Manual &gt; Combinators &gt; Scan.

add4 :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; (a,[a])
add4 cin [x0, x1, x2, x3] [y0, y1, y2, y3]
  = (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd (x0,y0) c1
    (c1,s1) = fullAdd (x1,y1) c2
    (c2,s2) = fullAdd (x2,y2) c3
    (c3,s3) = fullAdd (x3,y3) cin
</code></pre>
<p>A main program containing test data and a simulation driver is in <em>Add4Run.hs</em>.</p>
<pre><code>module Main where
import HDL.Hydra.Core.Lib
import Add4

main :: IO ()
main = run_add4 testdata

-- Each test is a list of [c, x, y] where c is the carry input (must
-- be 0 or 1) and x and y are integers between 0 and 15.  A number of
-- such tests are provided.

testdata :: [[Int]]
testdata =
--  c   x   y
  [[0,  5,  8],
   [0,  7,  3],
   [0,  8, 12],
   [0,  8,  1],
   [1, 12,  1],
   [1,  2,  3],
   [1, 15, 15]]

run_add4 :: [[Int]] -&gt; IO ()
run_add4 input = runAllInput input output
  where
-- Extract input signals
    cin = getbit   input 0
    x   = getbin 4 input 1
    y   = getbin 4 input 2
-- The circuit to be simulated
    (cout,s) = add4 cin x y
-- Format the output
    output =
      [string &quot;  x =&quot;, bindec 3 x,
       string &quot;  y =&quot;, bindec 3 y,
       string &quot;  cin = &quot;, bit cin,
       string &quot;    ==&gt;    cout = &quot;, bit cout,
       string &quot;  s =&quot;, bindec 3 s]
</code></pre>
<p>To run the simulation, enter <em>ghc -e main Add4Run</em>. Here is the output:</p>
<pre><code>$ ghc -e main Add4Run
  x =  5  y =  8  cin = 0    ==&gt;    cout = 0  s = 13
  x =  7  y =  3  cin = 0    ==&gt;    cout = 0  s = 10
  x =  8  y = 12  cin = 0    ==&gt;    cout = 1  s =  4
  x =  8  y =  1  cin = 0    ==&gt;    cout = 0  s =  9
  x = 12  y =  1  cin = 1    ==&gt;    cout = 0  s = 14
  x =  2  y =  3  cin = 1    ==&gt;    cout = 0  s =  6
  x = 15  y = 15  cin = 1    ==&gt;    cout = 1  s = 15</code></pre>
<h3 id="building-words"><a href="#building-words">Building words</a></h3>
<p>If you have expressions that define some signals, a word comprising the signals can be constructed by writing the expressions in square brackets, separated by commas.</p>
<pre><code>[p,q,r,s]</code></pre>
<p>The length of a word can be any natural number. Thus <em>[]</em> is the empty word, <em>[x]</em> is a word containing just one element, and so on.</p>
<pre><code>[]                          -- length = 0
[x]                         -- length = 1
[x,y]                       -- length = 2
[x0,x1,x2,x3,x4,x5,x6,x7]   -- length = 8</code></pre>
<p>Suppose you have a word <em>w</em>, of any length, and a bit signal <em>x</em>. Thus <em>w :: [a]</em> and <em>x :: a</em>, where <em>a</em> is the basic signal type. Then we can construct a new word which is just like <em>w</em> except that the singleton <em>x</em> is attached to the front. The notation for this is <em>x:w</em>, which is pronounced `<em>x cons w</em>'. For example, suppose <em>w = [p,q,r,s]</em>. Then <em>(x:w) = [x,p,q,r,s]</em>. The properties of the <em>(:)</em> operator are summarized as follows:</p>
<pre><code>x :: a
w :: [a]
(x:w) :: [a]
length (x:w) = 1 + length w</code></pre>
<p>It's often useful to take two words that have already been defined, and to define a bigger one that contains the elements of both. This is called <em>append</em> or <em>concatenation</em>, and is done using the <em>(++)</em> operator. The word <em>w1 ++ w2</em> is a word containing first the elements of <em>w1</em>, and then the elements of <em>w2</em>. Here are some examples and properties of append:</p>
<pre><code>[x0,x1,x2,x3] ++ [y0,y1] = [x0,x1,x2,x3,y0,y1]
length (w1 ++ w2) = length w1 + length w2</code></pre>
<pre><code>(++)</code></pre>
<h3 id="accessing-parts-of-a-word"><a href="#accessing-parts-of-a-word">Accessing parts of a word</a></h3>
<p>Often we can perform operations on entire words, using word-oriented digital circuits, without ever accessing individual elements of a word. Later we will see a family of building block circuits that operate on words. Normally this is the best way to organize a circuit that works with words.</p>
<p>Sometimes, however, it's necessary to extract one or more elements of a word. One way to do this is by <em>indexing</em>. Each element of a word <em>w</em> has an index, ranging from 0 to <span class="math"><em>k</em> − 1</span>, where <em>k = length w</em>. The <em>(!!)</em> operator uses an index to extract the element; thus <em>w!!i</em> gives the <span class="math"><em>i</em></span>th element of the word <em>w</em>. This is well defined if the index <em>i</em> is in range: <span class="math"><em>i</em> ≤ <em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em> <em>w</em></span>. If <span class="math"><em>i</em> &lt; 0</span>, or <span class="math"><em>i</em> ≥ <em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em> <em>W</em></span>, then <em>w!!i</em> is an error.</p>
<pre><code>w!!i                   i&#39;th bit of word w
field w i j            bits i..i+j-1 of word w</code></pre>
<p>There are two special cases for indexing that are supported by specific operators: you can get the least significant (or most significant) bit of a word <em>w</em> using <em>lsb w</em> (or <em>msb w</em>). The least significant bit <em>lsb w</em> is equivalent to <em>w !! (length w -1)</em>, and the most significant bit <em>msb w</em> is equivalent to <em>w !! 0</em>.</p>
<pre><code>w !! i                 (!!) :: [a] -&gt; Int -&gt; a
lsb w                  lsb :: [a] -&gt; a
msb w                  msb :: [a] -&gt; a</code></pre>
<p>There are three functions that give a field from a word; that is, the result is itself a (smaller) word, not just an individual bit. The <em>take</em> and <em>drop</em> functions give a sub-word that is at the beginning or end of a word. Thus <em>take i w</em> gives a word consisting of the leftmost <span class="math"><em>i</em></span> elements of <em>w</em>, while <em>drop i w</em> gives a word consisting of all the elements of <em>w</em> <em>except for</em> the leftmost <span class="math"><em>i</em></span> elements.</p>
<p>More generally, it is sometimes necessary to extract an arbitrary field from a word. A <em>field</em> is a word consisting of any consecutive set of elements. A field has type <em>Field</em>, and it consists of a pair of integers <em>(i,s)</em> where <em>i</em> is the index of the starting position of the field, and <em>s</em> is its size. Thus <em>field (i,s) w = [w!!i, w!!(i+1), ..., w!!(i+s-1)]</em>.</p>
<pre><code>type Field = (Int,Int)
take i w                 take :: Int -&gt; [a] -&gt; [a]
drop i w                 drop :: Int -&gt; [a] -&gt; [a]
field f w                field :: Field -&gt; [a] -&gt; [a]</code></pre>
<p>An example of a circuit that operates on words is the 4-bit word inverter <em>inv4</em>. Its input and output are both 4-bit words, and each output bit is the inversion of the corresponding input bit. The type notation for the word is concise, since the types of the individual bits don't have to be repeated, but on the other hand the type doesn't express the fact that this circuit works only on 4-bit words.</p>
<div class="figure">
<img src="figures/xfig/inv4-wsig.svg" />
</div>
<div class="figure">
<img src="figures/xfig/map4inv.svg" />
</div>
<div class="figure">
<img src="figures/xfig/map4invbox.png" />
</div>
<div class="figure">
<img src="figures/xfig/inv4-wsig.png" />
</div>
<pre><code>inv4 :: Bit a =&gt; [a] -&gt; [a]
inv4 [x0,x1,x2,x3] = [inv x0, inv x1, inv x2, inv x3]</code></pre>
<p>The circuit specification for <em>inv4</em> is simple enough, but it would be painful to extend this to much larger sizes, say 64-bit words. The chapter on design patterns shows a more elegant approach, but for small words the style used here is adequate. The Hydra libraries provide a collection of straightforward circuit specifications written in the same style as <em>inv4</em>, and they also provide circuits that are defined using design patterns and that work for arbitrary word sizes, no matter how large.</p>
<h2 id="nested-clusters"><a href="#nested-clusters">Nested clusters</a></h2>
<p>The cluster types can be nested. A tuple may contain words (or deeper tuples), and a word may contain tuples (or deeper words, although that is unusual).</p>
<p>There is a style of circuit design called <em>bit slice organization</em>. The idea is that a building block circuit is defined for an arbitrary position within a word, and these building blocks can then be combined. Bit slice style often results in complex groupings, with words of tuples, and notwithstanding the relatively complex types it can result in simple specifications of efficient circuits. The essence of bit slice organization is to keep the corresponding bits of several words together. Thus two words <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> could be represented as a word of pairs, rather than two separate words:</p>
<p><span class="math">[(<em>x</em>0, <em>y</em>0), (<em>x</em>1, <em>y</em>1), (<em>x</em>2, <em>y</em>2), (<em>x</em>3, <em>y</em>3)]: : [(<em>a</em>, <em>a</em>)]</span></p>
<p>Collecting a group of signals into a cluster is just a notational convenience; it doesn't affect the actual circuit. However, grouping can simplify the way you <em>describe</em> the circuit, and this is essential for large and complex circuits.</p>
<p>When you are designing a circuit with several input signals, you can decide whether to treat them as separate arguments (each followed by an arrow <em>-&gt;</em>) or as a single argument which is a tuple or word. However, if you are using a circuit that has already been specified, you need to follow the type used in its specification.</p>
<p>When a circuit has several outputs, there is no choice---the output signals must be collected into a tuple or a word. The reason for this is that the underlying functional language requires that each function has one result. This does not limit our ability to express complex circuits; it simply means that we need to use tuples or words.</p>
<p>Grouping is often helpful just to simplify the notation and to make specifications more readable.</p>
<p>A tuple (x, (a,b)) is used to collect several values which may be unrelated to each other. Tuples are used for groups where the components are unrelated, and indexing doesn't make sense. The components may have different types: <span class="math">(<em>a</em>, (<em>a</em>, <em>a</em>), <em>a</em>)</span> A word is used to collect values that belong to specific bit positions, typically to form a binary number. Tuples and words can be combined to form complex clusters.</p>
<p>Example: a 4-Bit ripple carry adder</p>
<p>For the multiplexer (the hardware equivalent of an if-then-else) there is little to gain by grouping the inputs, so we use separate parameters without grouping: *mux1 c x y = ... *</p>
<p>For the full-adder, which adds three bits, it's convenient to group the bits <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> from the <span class="math"><em>i</em></span>th position in a word together, and to keep them separate from the carry input bit <span class="math"><em>c</em></span>. *fullAdd (x,y) c = ... *</p>
<p>Don't worry---the reasons for these decisions will become clear later, when we start making advanced uses of these circuits. It's common to make some changes to the grouping notation for a circuit after you start using it extensively!</p>
<div class="figure">
<img src="figures/xfig/rippleAdd4.svg" />
</div>
<pre><code>rippleAdd4 c [(x0,y0), (x1,y1), (x2,y2), (x3,y3)] =
    (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd c1 (x0,y0)
    (c1,s1) = fullAdd c2 (x1,y1)
    (c2,s2) = fullAdd c3 (x2,y2)
    (c3,s3) = fullAdd c  (x3,y3)</code></pre>
<p><strong>Exercise.</strong> A circuit has the type declaration <em>circ :: Bit a =&gt; a -&gt; (a,a) -&gt; [a] -&gt; (a,[a])</em>. How many groups of input bits are there? How are they structured? How is the output structured?</p>
<p><strong>Exercise.</strong> Modify the definition of <em>rippleAdd4</em> to handle 6-bit words.</p>
<p><strong>Exercise.</strong> Define an 8-bit adder, named <em>rippleAdd8</em>. Don't follow the pattern of <em>rippleAdd4</em>, with eight equations. Instead, use <em>rippleAdd4</em> as a building block circuit. In your definition of <em>rippleAdd8</em>, use two separate internal <em>rippleAdd4</em> circuits, and connect them up appropriately.</p>
<p><strong>Exercise.</strong> Suppose <em>x = [x0,x1,x2]</em>, <em>y = [y0,y1,y2,y3]</em>, and <em>z = x++y</em>. What are the values of <em>z</em>, <em>length z</em>, and <em>z!!4</em>?</p>
<h1 id="combinational-simulation"><a href="#combinational-simulation">Combinational simulation</a></h1>
<p>One way to simulate a combinational circuit is to apply it directly to its inputs. This works best if the circuit is defined with Bool as the signal type. Here is an example:</p>
<pre><code>module HalfAddB where
import HDL.Hydra.Core.Lib

-- Demonstrate a circuit with a concrete type Bool, instead of a type
-- class constraint Bit a =&gt;.

halfAddB :: Bool -&gt; Bool -&gt; (Bool,Bool)
halfAddB x y = (and2 x y, xor2 x y)</code></pre>
<p>To simulate the circuit, the HalfAddB module is loaded, and then the circuit is applied to several values of the input signals. For a bit signal of 0, use False as the input, and use True for a 1 bit.</p>
<pre><code>$ ghci
GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :load HalfAddB
[1 of 1] Compiling HalfAddB     
*HalfAddB&gt; halfAddB False False
(False,False)
*HalfAddB&gt; halfAddB False True
(False,True)
*HalfAddB&gt; halfAddB True False
(False,True)
*HalfAddB&gt; halfAddB True True
(True,False)</code></pre>
<p>This approach works only for combinational circuits because the Bool type does not support clocked signals. For sequential circuits, see the following section.</p>
<h1 id="synchronous-sequential-simulation"><a href="#synchronous-sequential-simulation">Synchronous sequential simulation</a></h1>
<p>A sequential circuit may have feedback and state. A sequential circuit is <em>synchronous</em> if it uses a clock to ensure that all flip flops change state simultaneously.</p>
<p>The execution of a synchronous circuit can be</p>
<h2 id="general-form"><a href="#general-form">General form</a></h2>
<pre><code>simCirc input = runAllInput input output
  where
-- Extract input signals from the input data
     (equation for each input signal)
     ...

-- The circuit to be simulated
    output_signals = circ input_signals

-- Format the outputs
    output =
      [ (formatted signal values)... ]</code></pre>
<pre><code>simCirc input = runAllInput input output
  where
-- Extract input signals from the input data
    cin = getbit input 0
    x   = getbit input 1
    y   = getbit input 2

-- The circuit to be simulated
    (cout,sum) = fullAdd a b c

-- Format the outputs
    output =
      [string &quot;Inputs: cin=&quot;, bit cin,
       string &quot; x=&quot;, bit x,
       string &quot; y=&quot;, bit y,
       string &quot;  Outputs: cout=&quot;, bit cout,
       string &quot; sum=&quot;, bit sum]</code></pre>
<h2 id="parsing-the-inputs"><a href="#parsing-the-inputs">Parsing the inputs</a></h2>
<p>The input data is written as a list of lists. For the outer list, the ith element is a list giving all the input values for clock cycle i. The simulation will run for cycle 0, cycle 1, ..., until it runs out of input data, and then it will terminate. Each element of the outer list is a list of integers from which the input signals are derived.</p>
<p>Each input signal (or container) should be defined with an equation. The left hand side of the equation is the name of the signal, which can be used as an input to the circuit. The right hand side of the equation says how an element of the input list is used to define the signal; this is analogous to an input format specifier.</p>
<ul>
<li>b = getbit input i</li>
<li>xy = getbit2 input i</li>
<li>n = getbin k input i</li>
<li>m = gettc k input i</li>
</ul>
<h2 id="formatting-the-outputs"><a href="#formatting-the-outputs">Formatting the outputs</a></h2>
<h2 id="defining-a-main-program"><a href="#defining-a-main-program">Defining a main program</a></h2>
<h2 id="modules-and-libraries"><a href="#modules-and-libraries">Modules and libraries</a></h2>
<h2 id="compilation-and-interpretation"><a href="#compilation-and-interpretation">Compilation and interpretation</a></h2>
<h1 id="standard-library-for-bits"><a href="#standard-library-for-bits">Standard library for bits</a></h1>
<h2 id="constant-signals-1"><a href="#constant-signals-1">Constant signals</a></h2>
<pre><code>zero                   signal with constant 0 value
one                    signal with constant 1 value</code></pre>
<h2 id="logic-gates-1"><a href="#logic-gates-1">Logic gates</a></h2>
<pre><code>inv                    inverter
and2, and3, and4       and gate with 2, 3, 4 inputs
nand2, nand3, nand4    and gate with 2, 3, 4 inputs
or2, or3, or4          or gate with 2, 3, 4 inputs
nor2, nor3, nor4       nor gate with 2, 3, 4 inputs
xor2, xor3, xor4       xor gate with 2, 3, 4 inputs</code></pre>
<h2 id="replicating-a-signal"><a href="#replicating-a-signal">Replicating a signal</a></h2>
<p>Fanout takes a signal and splits it to several outputs.</p>
<pre><code>fanout2 :: a -&gt; (a,a)
fanout2 x = (x,x)

fanout3 :: a -&gt; (a,a,a)
fanout3 x = (x,x,x)

fanout4 :: a -&gt; (a,a,a,a)
fanout4 x = (x,x,x,x)</code></pre>
<h2 id="multiplexers-and-demultiplexers"><a href="#multiplexers-and-demultiplexers">Multiplexers and demultiplexers</a></h2>
<pre><code>mux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mux1 p a b = x
  where x = or2 (and2 (inv p) a) (and2 p b)

mux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a
mux2 (c,d) p q r s =
  mux1 c  (mux1 d p q)
          (mux1 d r s)

mux3 :: Bit a =&gt; (a,a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a-&gt; a -&gt; a -&gt; a -&gt; a
mux3 (c0,c1,c2) a0 a1 a2 a3 a4 a5 a6 a7 =
  mux1 c0
    (mux1 c1
      (mux1 c2 a0 a1)
      (mux1 c2 a2 a3))
    (mux1 c1
      (mux1 c2 a4 a5)
      (mux1 c2 a6 a7))

mux22 :: Bit a =&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a)
mux22 (p0,p1) (a0,a1) (b0,b1) (c0,c1) (d0,d1) = (x,y)
  where x = mux2 (p0,p1) a0 b0 c0 d0
        y = mux2 (p0,p1) a1 b1 c1 d1</code></pre>
<pre><code>mux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mux1 p a b = x
  where x = or2 (and2 (inv p) a) (and2 p b)</code></pre>
<pre><code>mux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a
mux2 (c,d) p q r s =
  mux1 c  (mux1 d p q)
          (mux1 d r s)</code></pre>
<pre><code>mux3 :: Bit a =&gt; (a,a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a-&gt; a -&gt; a -&gt; a -&gt; a
mux3 (c0,c1,c2) a0 a1 a2 a3 a4 a5 a6 a7 =
  mux1 c0
    (mux1 c1
      (mux1 c2 a0 a1)
      (mux1 c2 a2 a3))
    (mux1 c1
      (mux1 c2 a4 a5)
      (mux1 c2 a6 a7))</code></pre>
<pre><code>mux22 :: Bit a =&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a)
mux22 (p0,p1) (a0,a1) (b0,b1) (c0,c1) (d0,d1) = (x,y)
  where x = mux2 (p0,p1) a0 b0 c0 d0
        y = mux2 (p0,p1) a1 b1 c1 d1</code></pre>
<p>A demultiplexer is an important building block circuit which is related to the multiplexer. It plays a central role in digital circuit design, and we will see many applications that require them. A common application a demultiplexer is to decode binary numbers. For example, we will use them later to implement memories (since the address needs to be decoded), and they are also crucial in a computer's control unit (where they are used to decode instruction opcodes).</p>
<p>A 1-bit demultiplexer, called <em>demux1</em>, takes a control input <em>c</em> and a data input <em>x</em>. It produces two outputs <em>y0</em> and <em>y1</em> --- so it provides a good practical example of the use of tuples.</p>
<pre><code>(y0,y1) = demux1 c x</code></pre>
<p>The idea of <em>demux1</em> is that we want to send the data input <em>x</em> to one of the two outputs, and the choice depends on the control input <em>c</em> --- thus if <em>c=0</em> then <em>y0=x</em>, but if <em>c=1</em> then <em>y1=x</em>. But what happens to the output that is <em>not</em> selected by <em>c</em>? That output has to have a well-defined value too, and we will set it to the constant 0. To summarize, the behavior of the <em>demux1</em> is</p>
<pre><code>y0 = if c==0 then x else 0
y1 = if c==1 then x else 0</code></pre>
<pre><code>  c   x   y0   y1
 --- --- ---- ----
  0   0    0    0
  0   1    1    0
  1   0    0    0
  1   1    0    1</code></pre>
<p>Here is the same thing but without any leading spaces</p>
<table>
<caption>Truth table for <em>(y0,y1) = demux1 c x</em></caption>
<thead>
<tr class="header">
<th align="center">c</th>
<th align="center">x</th>
<th align="center">y0</th>
<th align="center">y1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>The implementation is straightforward. From the truth table, you can see that the <em>y1</em> has the same truth table as the <em>and2</em> gate, and <em>y0=1</em> if <em>c=0</em> and <em>x=1</em>.</p>
<pre><code>demux1 :: Bit a =&gt; a -&gt; a -&gt; (a,a)
demux1 c x = (y0,y1)
  where  y0 = and2 (inv c) x
         y1 = and2 c x</code></pre>
<p>It isn't actually necessary to define the names of the outputs; here is an alternative definition that outputs a tuple of anonymous signals. The two circuits are identical; the only difference is in the way they are described. One advantage of the first definition is that it offers the names <em>y0</em> and <em>y1</em> that may be helpful in discussing how the circuit works, but the definitions yield the same circuit and the choice between them is a matter of style.</p>
<pre><code>demux1 :: Bit a =&gt; a -&gt; a -&gt; (a,a)
demux1 c x = (and2 (inv c) x, and2 c x)</code></pre>
<p>There are several ways that a larger circuit could incorporate a <em>demux1</em>. If the pair <em>(y0,y1)</em> is being connected to the input of some other circuit <em>circ</em> that takes a pair, then we could simply write <em>circ (demux1 c x)</em>. However, if the larger circuit needs explicit access to <em>y0</em> or <em>y1</em>, then they should be given names using an equation.</p>
<p>A demux2 circuit takes a two-bit control and produces <span class="math">2<sup>2</sup> = 4</span> outputs.</p>
<pre><code>demux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a,a,a)
demux2 (c0,c1) x = (y0,y1,y2,y3)
  where  (p,q) = demux1 c0 x
         (y0,y1) = demux1 c1 p
         (y2,y3) = demux1 c1 q</code></pre>
<h2 id="bit-addition"><a href="#bit-addition">Bit addition</a></h2>
<p>When two bits are added together, the result could be 0, 1, or 2. Two bits are needed to represent the result, so a bit adder is an example of a circuit that needs to output several signals. The circuit that does this is called a <code>half adder', and its name is *halfAdd*. (Later we will discuss the</code>full adder', which adds three bits.) The half adder can be specified with a truth table:</p>
<pre><code>| x  y  |  x+y  |  c  s |
|-------+-------+-------|
| 0  0  |   0   |  0  0 |
| 0  1  |   1   |  0  1 |
| 1  0  |   1   |  0  1 |
| 1  1  |   2   |  1  0 |</code></pre>
<table>
<caption>Truth table for halfAdd</caption>
<thead>
<tr class="header">
<th align="right">x</th>
<th align="center">y</th>
<th align="center">x+y</th>
<th align="center">c</th>
<th align="left">s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>From the table, it is clear that the carry function is just <em>and2</em>, and the sum function is <em>xor2</em>.</p>
<pre><code>halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (c,s)
  where
    c = and2 x y
    s = xor2 x y</code></pre>
<p>If you don't want to give names to the outputs <em>c</em> and <em>s</em>, the definition can be shortened by putting the expressions for the signals directly in the output tuple:</p>
<pre><code>halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (and2 x y, xor2 x y)</code></pre>
<p>The choice between these alternative definitions is a matter of style: both are correct and both describe the same circuit. The definition with anonymous signals is shorter, while the definition with named outputs uses simpler expressions and gives standard names for talking about the outputs.</p>
<p>There is another bit adder circuit that illustrates how inputs can be handled using either separate arguments or tuples. This is the <em>full adder</em>, which adds three bits. Full adders are needed to add binary numbers, because we have to add the carry as well as the two data bits at each position.</p>
<pre><code>| x  y  z |  x+y+z  | c  s |
|---------+---------+------|
| 0  0  0 |    0    | 0  0 |
| 0  0  1 |    1    | 0  1 |
| 0  1  0 |    1    | 0  1 |
| 0  1  1 |    2    | 1  0 |
| 1  0  0 |    1    | 0  1 |
| 1  0  1 |    2    | 1  0 |
| 1  1  0 |    2    | 1  0 |
| 1  1  1 |    3    | 1  1 |</code></pre>
<p>Table: Truth table for fullAdd. The three input bits x, y, z are added to produce a two-bit result consisting of a carry c and a sum s. (Note that the input bits do <em>not</em> represent a 3-bit binary number; they are simply three separate variables to be added.)</p>
<p>Since there are two output signals, it is necessary to combine them in a tuple, so the type will have the form <em>... -&gt; (a,a)</em>. We have a choice for handling the three input signals. They could be treated as separate arguments:</p>
<pre><code>(1) fullAdd :: Bit a =&gt; a -&gt; a -&gt; a -&gt; (a,a)</code></pre>
<p>Alternatively, the three inputs could be collected into a tuple:</p>
<pre><code>(2) fullAdd :: Bit a =&gt; (a,a,a) -&gt; (a,a)</code></pre>
<p>But those are not the only possibilities. Another approach is to collect just two of the signals into a tuple, so there would be two arguments, a tuple and a bit. This gives two more ways to organize the inputs:</p>
<pre><code>(3) fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
(4) fullAdd :: Bit a =&gt; a -&gt; (a,a) -&gt; (a,a)</code></pre>
<p>At this point, there is little reason to prefer one of these types over another. Later, however, when design patterns are introduced, it will turn out that the design of larger circuits can be simplified if we choose version (3), so that is the type actually used for the half adder in the Hydra circuit library.</p>
<p>Don't worry about making the `best' choice for such decisions. No one always can make the best choice among the possible alternatives while designing a large system. What happens in the real world is that systems are designed according to experience, judgment, and taste. If it turns out later that the design could be made clearer or more elegant by changing one of these arbitrary choices, then that can be done when the system is cleaned up. The Hydra libraries have going through this process several times.</p>
<p>Now we can define the full adder circuit. For convenience, the calculation of the carry and sum results will be performed by auxiliary circuits, <em>bcarry</em> and <em>bsum</em>.</p>
<pre><code>fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)</code></pre>
<p>It isn't necessary to name the <em>x</em> and <em>y</em> signals individually. Notice that the pair <em>(x,y)</em> comes into the circuit, and is then passed to <em>bcarry</em> and <em>bsum</em>. The <em>fullAdd</em> circuit itself doesn't use either <em>x</em> or <em>y</em> directly. Therefore we could just give a name, such as <em>xy</em>, to the cluster <em>(x,y)</em>. This shortens the notation:</p>
<pre><code>fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd xy c = (bcarry xy c, bsum xy c)</code></pre>
<p>Note that the signals <em>x</em> and <em>y</em> in the previous definition have the bit signal type <em>a</em>. This can be stated as <em>x :: a</em> and <em>y :: a</em>. In the simplified definition, the argument <em>xy</em> is a pair of bits, so <em>xy :: (a,a)</em>.</p>
<p>To complete the circuit, we need to implement <em>bcarry</em> and <em>bsum</em>. There are many ways to do this; the following specifications are reasonable. Since <em>bsum</em> and <em>bcarry</em> have the same type, we can declare those types in one statement. Read this as `<em>bsum</em> and <em>bcarry</em> both have type ...'.</p>
<pre><code>bsum, bcarry :: Bit a =&gt; (a,a) -&gt; a -&gt; a
bsum (x,y) c = xor3 x y c
bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)</code></pre>
<h2 id="flip-flops-and-registers"><a href="#flip-flops-and-registers">Flip flops and registers</a></h2>
<pre><code>dff                    delay flip flop</code></pre>
<pre><code>reg1 :: CBit a =&gt; a -&gt; a -&gt; a</code></pre>
<h1 id="standard-library-for-words"><a href="#standard-library-for-words">Standard library for words</a></h1>
<pre><code>
winv w                 invert the bits in a word
mux1w                  use 1-bit control to select between two words
bitslice2 x y          convert pair of words to word of pairs
mux2                   use two bit control to select one of four inputs</code></pre>
<h2 id="replication-and-constant-words"><a href="#replication-and-constant-words">Replication and constant words</a></h2>
<h2 id="replicating-a-word"><a href="#replicating-a-word">Replicating a word</a></h2>
<p>fanout :: Bit a =&gt; Int -&gt; a -&gt; [a] fanout k x = take k (repeat x) ~~~~~</p>
<p>Buffered fanout takes a signal and splits it to several outputs, and inserts a buffer to ensure the outputs are strong enough.</p>
<pre><code>fanoutbuf2 :: Bit a =&gt; a -&gt; (a,a)
fanoutbuf2 x = (y,y)
  where y = buf x

fanoutbuf3 :: Bit a =&gt; a -&gt; (a,a,a)
fanoutbuf3 x = (y,y,y)
  where y = buf x

fanoutbuf4 :: Bit a =&gt; a -&gt; (a,a,a,a)
fanoutbuf4 x = (y,y,y,y)
  where y = buf x</code></pre>
<pre><code>fanout2 :: a -&gt; (a,a)
fanout2 x = (x,x)

fanout3 :: a -&gt; (a,a,a)
fanout3 x = (x,x,x)

fanout4 :: a -&gt; (a,a,a,a)
fanout4 x = (x,x,x,x)</code></pre>
<pre><code>fanout :: Bit a =&gt; Int -&gt; a -&gt; [a]
fanout n b             connect bit b to n outputs, forming a word</code></pre>
<p>A wiring pattern that replicates a singleton signal to form a word. The input x is a signal, which is replicated n times to form a word w of size n.</p>
<pre><code>w = fanout n x</code></pre>
<p>Representing a boolean bit as a word: boolword takes a bit x, and pads it to the left with 0s to form a word. If the input x is False (0), the result is the integer 0 (i.e. n 0-bits), and if x is True (1) the result is the integer 1 (rightmost bit is 1, all others are 0).</p>
<pre><code>boolword :: Bit a =&gt; Int -&gt; a -&gt; [a]
boolword n x = fanout (n-1) zero ++ [x]</code></pre>
<pre><code>boolword n b           form an n-bit word, lsb = b, other bits = 0</code></pre>
<h2 id="rearranging-bits-in-a-word"><a href="#rearranging-bits-in-a-word">Rearranging bits in a word</a></h2>
<h3 id="combinational-shifting"><a href="#combinational-shifting">Combinational shifting</a></h3>
<p>Shift a word to the right (shr) or to the left (shl). In both cases, this is just a wiring pattern. A 0 is brought in on one side, and the bit on the other side is just thrown away.</p>
<pre><code>shl :: Bit a =&gt; [a] -&gt; [a]</code></pre>
<p>shl is a wiring pattern that shifts a word to the left. A zero is brought in on the right side, and the value on the left is discarded. This is a circuit generator that works for words of any size. It is a wiring pattern; no logic gates are generated. Similar to shr.</p>
<p>Example:</p>
<pre><code>shl [a,b,c,d] = [b,c,d,zero]</code></pre>
<pre><code>shr :: Bit a =&gt; [a] -&gt; [a]</code></pre>
<p>shr is a wiring pattern that shifts a word to the right. A zero is brought in on the left side, and the value on the right is discarded. This is a circuit generator that works for words of any size. It is a wiring pattern; no logic gates are generated. Similar to shl.</p>
<p>Example:</p>
<pre><code>shl [a,b,c,d] = [zero,a,b,c]</code></pre>
<pre><code>shr x = zero : [x!!i | i &lt;- [0..k-2]]
  where k = length x
shl x = [x!!i | i &lt;- [1..k-1]] ++ [zero]
  where k = length x</code></pre>
<h3 id="bit-slice-representation"><a href="#bit-slice-representation">Bit slice representation</a></h3>
<pre><code>bitslice2 :: [a] -&gt; [a] -&gt; [(a,a)]</code></pre>
<pre><code>unbitslice2 :: [(a,b)] -&gt; ([a], [b])</code></pre>
<h2 id="logic-on-words"><a href="#logic-on-words">Logic on words</a></h2>
<p>Calculating a bit from a word</p>
<pre><code>any1                   or the bits in a word: result is 1 if any 1 bit</code></pre>
<pre><code>orw :: Bit a -&gt; [a] -&gt; a</code></pre>
<pre><code>andw :: Bit a -&gt; [a] -&gt; a</code></pre>
<p>And/Or over a word: Determine whether there exists a 1 in a word, or whether all the bits are 0. A tree fold can do this in log time, but for simplicity this is just a linear time fold.</p>
<pre><code>orw, andw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
andw = foldl and2 one</code></pre>
<p>Logic on each bit in a word</p>
<p>Word inverter: winv takes a word and inverts each of its bits</p>
<pre><code>winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x</code></pre>
<h2 id="conditionals-and-addresses"><a href="#conditionals-and-addresses">Conditionals and addresses</a></h2>
<h3 id="multiplexers"><a href="#multiplexers">Multiplexers</a></h3>
<pre><code>mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]</code></pre>
<pre><code>z = mux1w c x y
If c=zero, then z=x, but otherwise z=y</code></pre>
<p>A singleton control signal is used to choose between two data words. If the control is zero the first data word is sent to the output, otherwise the second data word is sent to the output. The two input data words should have the same size, and the output word automatically has that size as well. This is a circuit generator that works for any word size.</p>
<pre><code>mux1w c x y = map2 (mux1 c) x y</code></pre>
<pre><code>mux2w cc = map4 (mux2 cc)</code></pre>
<p><a name="exercise:use-mux1w"><strong>Exercise</strong></a> <a href="#solution:use-mux1w"><em>(Go to solution)</em></a> We have two word signals <em>x</em> and <em>y</em>, which have the same word size (but we don't know or care exactly what the size is). There is a single control bit <em>c</em>. Define a signal <em>z</em> which is a word; on each clock cycle, <em>z</em> is the same as <em>x</em> if <em>c=0</em> during that cycle, but <em>z</em> is the same as <em>y</em> if <em>c=1</em>.</p>
<h3 id="demultiplexers"><a href="#demultiplexers">Demultiplexers</a></h3>
<pre><code>demux1w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux1w [c0] x =
  let (a0,a1) = demux1 c0 x
  in [a0,a1]</code></pre>
<pre><code>demux2w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux2w [c0,c1] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux1w [c1] a0
      w1 = demux1w [c1] a1
  in w0++w1</code></pre>
<pre><code>demux3w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux3w [c0,c1,c2] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux2w [c1,c2] a0
      w1 = demux2w [c1,c2] a1
  in w0++w1</code></pre>
<pre><code>demux4w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux4w [c0,c1,c2,c3] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux3w [c1,c2,c3] a0
      w1 = demux3w [c1,c2,c3] a1
  in w0++w1</code></pre>
<h2 id="arithmetic"><a href="#arithmetic">Arithmetic</a></h2>
<h3 id="binary-addition"><a href="#binary-addition">Binary addition</a></h3>
<pre><code>bsum, bcarry :: Bit a =&gt; (a,a) -&gt; a -&gt; a
bsum (x,y) c = xor3 x y c
bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)</code></pre>
<pre><code>rippleAdd :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])</code></pre>
<p>The ripple carry adder takes a carry input, and two words organised in bit slice form. It produces a carry output and a sum word. This is a circuit generator, which allows input words of any size.</p>
<h2 id="registers"><a href="#registers">Registers</a></h2>
<pre><code>wlatch :: CBit a =&gt; Int -&gt; [a] -&gt; [a]</code></pre>
<p>Defines a register with output r, containing n bits, and with input x. At every clock cycle, the register discards its old state and replaces it with the current value of the input.</p>
<pre><code>r = wlatch n x</code></pre>
<pre><code>reg :: CBit a =&gt; Int -&gt; a -&gt; [a] -&gt; [a]</code></pre>
<pre><code>reg n ld x                 n-bit register with load control ld, data input x</code></pre>
<h2 id="registers-1"><a href="#registers-1">Registers</a></h2>
<pre><code>reg
  :: CBit a =&gt;
  Int             -- ^ k = the word size
  -&gt; a          -- ^ ld = the load control signal
  -&gt; [a]        -- ^ input word of size k
  -&gt; [a]        -- ^ output is the register state

reg k ld x = mapn (reg1 ld) k x</code></pre>
<pre><code>regfile n k ld d sa sb x   register file with 2^k registers, each n-bits wide,
                           load control ld, destination address d,
                           reads out registers sa and sb, data input x</code></pre>
<h1 id="circuit-generators"><a href="#circuit-generators">Circuit generators</a></h1>
<h2 id="operating-on-words"><a href="#operating-on-words">Operating on words</a></h2>
<p>Duplicating a bit to form a word: fanout takes a wordsize k and a signal x, and produces a word of size k each of whose bits takes the value of x.</p>
<pre><code>fanout :: Bit a =&gt; Int -&gt; a -&gt; [a]
fanout k x = take k (repeat x)</code></pre>
<p>Buffered Fanout</p>
<pre><code>fanoutbuf2 :: Bit a =&gt; a -&gt; (a,a)
fanoutbuf2 x = (y,y)
  where y = buf x

fanoutbuf3 :: Bit a =&gt; a -&gt; (a,a,a)
fanoutbuf3 x = (y,y,y)
  where y = buf x

fanoutbuf4 :: Bit a =&gt; a -&gt; (a,a,a,a)
fanoutbuf4 x = (y,y,y,y)
  where y = buf x</code></pre>
<p>Building a constant integer word</p>
<p>Representing a boolean bit as a word: boolword takes a bit x, and pads it to the left with 0s to form a word. If the input x is False (0), the result is the integer 0 (i.e. n 0-bits), and if x is True (1) the result is the integer 1 (rightmost bit is 1, all others are 0).</p>
<pre><code>boolword :: Bit a =&gt; Int -&gt; a -&gt; [a]
boolword n x = fanout (n-1) zero ++ [x]</code></pre>
<p>Combinational shifting</p>
<p>Shift a word to the right (shr) or to the left (shl). In both cases, this is just a wiring pattern. A 0 is brought in on one side, and the bit on the other side is just thrown away.</p>
<pre><code>shr x = zero : [x!!i * i &lt;- [0..k-2]]
  where k = length x
shl x = [x!!i * i &lt;- [1..k-1]] ++ [zero]
  where k = length x</code></pre>
<h2 id="recursive-circuit-definitions"><a href="#recursive-circuit-definitions">Recursive circuit definitions</a></h2>
<pre><code>demux1w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux1w [c0] x =
  let (a0,a1) = demux1 c0 x
  in [a0,a1]

demux2w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux2w [c0,c1] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux1w [c1] a0
      w1 = demux1w [c1] a1
  in w0++w1

demux3w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux3w [c0,c1,c2] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux2w [c1,c2] a0
      w1 = demux2w [c1,c2] a1
  in w0++w1

demux4w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux4w [c0,c1,c2,c3] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux3w [c1,c2,c3] a0
      w1 = demux3w [c1,c2,c3] a1
  in w0++w1</code></pre>
<h2 id="tree-structured-circuits"><a href="#tree-structured-circuits">Tree structured circuits</a></h2>
<pre><code>regfile1 :: CBit a =&gt; Int -&gt; a -&gt; [a] -&gt; [a] -&gt; [a] -&gt; a -&gt; (a,a)

regfile1 0 ld d sa sb x = (r,r)
  where r = reg1 ld x

regfile1 (k+1) ld (d:ds) (sa:sas) (sb:sbs) x = (a,b)
  where
    (a0,b0) = regfile1 k ld0 ds sas sbs x
    (a1,b1) = regfile1 k ld1 ds sas sbs x
    (ld0,ld1) = demux1 d ld
    a = mux1 sa a0 a1
    b = mux1 sb b0 b1</code></pre>
<pre><code>regfile :: CBit a =&gt; Int -&gt; Int
  -&gt; a -&gt; [a] -&gt; [a] -&gt; [a] -&gt; [a] -&gt; ([a],[a])

regfile n k ld d sa sb x =
   unbitslice2 [regfile1 k ld d sa sb (x!!i)  * i &lt;- [0..n-1]]</code></pre>
<h2 id="memory"><a href="#memory">Memory</a></h2>
<pre><code>mem1 :: CBit a =&gt; Int
  -&gt; a -&gt; [a] -&gt; [a] -&gt; a -&gt; a
</code></pre>
<pre><code>mem1 0 ld d sa x = reg1 ld x
mem1 (k+1) ld (d:ds) (sa:sas) x = a
  where
    (ld0,ld1) = demux1 d ld
    a0 = mem1 k ld0 ds sas x
    a1 = mem1 k ld1 ds sas x
    a = mux1 sa a0 a1</code></pre>
<pre><code>mem1a :: CBit a =&gt; Int -&gt; a -&gt; [a] -&gt; a -&gt; a
mem1a 0 sto p x = reg1 sto x
mem1a (k+1) sto (p:ps) x =
  let (sto0,sto1) = demux1 p sto
      m0 = mem1a k sto0 ps x
      m1 = mem1a k sto1 ps x
  in mux1 p m0 m1</code></pre>
<pre><code>memw
  :: CBit a
  =&gt; Int
  -&gt; Int
  -&gt; a
  -&gt; [a]
  -&gt; [a]
  -&gt; [a]

memw n k sto p x =
  [mem1a k sto p (x!!i) | i &lt;- [0..n-1]]</code></pre>
<h1 id="combinators"><a href="#combinators">Combinators</a></h1>
<p>We will generally specify large circuits using a circuit generator, not by drawing every component individually. There are two kinds of circuit generator. Design patterns (higher order functions) are the focus of this chapter. Special languages for special kinds of circuit (e.g. control algorithms) are covered later.</p>
<p>Design patterns use circuits as building blocks</p>
<p>Design patterns are <em>higher order</em> functions: they take one or more <em>circuit specifications</em> as parameters. The pattern defines how to connect up these given circuits in a regular pattern. A pattern definition looks just like an ordinary circuit specification, except It uses recursion to decompose groups of signals. It uses abstract circuits, supplied as parameters, instead of specific circuits. Its type may include building block circuits (these parameters contain an <em>-&gt;</em> in their type) and/or size parameters (with a type like <em>Int</em>).</p>
<h2 id="map"><a href="#map">Map</a></h2>
<p>Word inverter: winv takes a word and inverts each of its bits</p>
<pre><code>winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x</code></pre>
<p>Operating on each element of a word of known size: mapn</p>
<pre><code>wlatch :: CBit a =&gt; Int -&gt; [a] -&gt; [a]
wlatch k x = mapn dff k x</code></pre>
<p>The word register</p>
<pre><code>reg
  :: CBit a =&gt;
  Int             -- ** k = the word size
  -&gt; a          -- ** ld = the load control signal
  -&gt; [a]        -- ** input word of size k
  -&gt; [a]        -- ** output is the register state
reg k ld x = mapn (reg1 ld) k x</code></pre>
<p>Mapping a circuit with multiple inputs</p>
<pre><code>mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y</code></pre>
<pre><code>mux2w cc = map4 (mux2 cc)</code></pre>
<p>Sometimes you have a circuit (it's arbitrary, so call it <span class="math"><em>f</em></span>) that takes an input (say it has type <span class="math"><em>a</em></span>) and produces an output (call its type <span class="math"><em>b</em></span>). You need to take a word of signals, and process each one with the circuit <span class="math"><em>f</em></span>. For example, <em>inv4</em> processes each signal with an <em>inv</em>. The <em>map</em> pattern describes this in general.</p>
<pre><code>map :: (a-&gt;b) -&gt; [a] -&gt; [b]</code></pre>
<p>The first argument to the pattern is a circuit with type <em>a-&gt;b</em> The pattern then generates a circuits, which takes an input word of type <em>[a]</em> and produces an output word of type <em>[b]</em>.</p>
<p>Example of map</p>
<p>We can define a word inverter using the pattern that places an inverter on each input signal, to produce the corresponding output signals.</p>
<pre><code>winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x</code></pre>
<p>Technical note: in a defining equation of the form <em>f a b c = g c</em>, you can `factor out' the rightmost parameter from both sides, giving a slightly shorter form.</p>
<pre><code>winv :: Bit a =&gt; [a] -&gt; [a]
winv = map inv</code></pre>
<p>This is attractive because it describes just the pattern.</p>
<p>Word inverter: ys = map inv xs</p>
<p></p>
<p></p>
<p>Definition of map</p>
<pre><code>map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs</code></pre>
<p>A recursion, based on the word structure of the input.</p>
<p>The base case is an empty input word <em>[]</em>. In this case, the output is also empty.</p>
<p>The recursion (or induction) case has an input word <em>x:xs</em> consisting of an initial bit <em>x</em> followed by the rest of the word, <em>xs</em>. The circuit introduces a copy of the <em>f</em> circuit to process <em>x</em>, and handles the rest recursively.</p>
<p>The following figure illustrates the structure of map recursion</p>
<p></p>
<p>After the recursion has completed:</p>
<p></p>
<p></p>
<p>Extending map to multiple inputs</p>
<p>The <em>map2</em> pattern is similar to <em>map</em>, but it uses a circuit that takes two inputs (thus its type is <em>a-&gt;b-&gt;c</em>). Note that <em>map2</em> is <em>not</em> a bit-slice pattern; it uses separate words.</p>
<pre><code>map2 :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt; [c]</code></pre>
<p>We can extend the basic multiplexor to handle words:</p>
<pre><code>mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y</code></pre>
<h3 id="sized-map"><a href="#sized-map">Sized map</a></h3>
<p>The <em>mapn</em> pattern is similar to <em>map</em>, except it takes a size parameter, and guarantees to produce an output of that size.</p>
<pre><code>mapn :: (a-&gt;b) -&gt; Int -&gt; [a] -&gt; [b]</code></pre>
<p>Registers are defined using <em>mapn</em>, to ensure that the number of flip flops is defined Combinational circuits may be defined using <em>map</em>, so they inherit the word size of their input</p>
<h2 id="fold"><a href="#fold">Fold</a></h2>
<p>The folding patterns define a linear circuit structure.</p>
<p>There is an input word of type <em>[b]</em>.</p>
<p>The elements of the word are combined using a building block <em>f</em>.</p>
<p>There is a `horizontal' signal of some type (call it <em>a</em>), which is goes across the word from left to right.</p>
<p>An initial horizontal input, of type <em>a</em> is provided.</p>
<p>The output is the final horizontal output (produced by the rightmost <em>f</em> circuit).</p>
<p>Folding corresponds to a linear computation from one end of the word to the other, starting with an initial value a (sometimes called an accumulator, but this is not to be confused with accumulator registers!).</p>
<h3 id="fold-from-the-left"><a href="#fold-from-the-left">Fold from the left</a></h3>
<p>In general, a fold can proceed either direction across the word. The <em>foldl</em> pattern describes a <em>fold from the left</em>; i.e. the information flows from left to right across the word.</p>
<pre><code>foldl :: (a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a</code></pre>
<p>The pattern is defined recursively:</p>
<pre><code>foldl f a [] = a
foldl f a (x:xs) = foldl f (f a x) xs</code></pre>
<p></p>
<p></p>

<p>The <em>orw</em> circuit determines whether there is any 1 bit in a word.</p>
<pre><code>orw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero</code></pre>
<p>The <em>andw</em> circuit determines whether all the bits in a word are 1.</p>
<p>And/Or over a word</p>
<pre><code>orw, andw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
andw = foldl and2 one</code></pre>
<pre><code>andw :: Bit a =&gt; [a] -&gt; a
andw = foldl and2 one</code></pre>
<p>The time required (the path depth) is linear in the word size. There are also tree-structured patterns that can do these computations in logarithmic time.</p>
<p>Efficiency</p>
<p>The definitions of <em>orw</em> and <em>andw</em> are not very efficient</p>
<p>If a large number of signals are being combined, a tree structure of logic gates reduces the path depth. If this circuit is on the critical path, that will help. If the technology supplies 3 or 4 input gates, it would likely be faster to use some of those, rather than just the 2 input gates. The <em>foldl</em> pattern uses one extra gate to include the `default' value of zero or one. This is overhead.</p>
<p>This inefficiency is not a concern, because</p>
<p>There are alternative patterns that generate more efficient circuits A circuit optimiser can generate optimal results If the circuit isn't on the critical path, it makes no difference anyway.</p>
<h3 id="binary-comparison-using-foldl"><a href="#binary-comparison-using-foldl">Binary comparison using foldl</a></h3>
<p>The problem: input two binary numbers, in bit slice form: <em>[(x0,y0), (x1,y1), ..., (xk,yk)]</em> Output the result of a comparision: <em>(lt,eq,gt)</em>, giving the values of <span class="math">(<em>x</em> &lt; <em>y</em>, <em>x</em> = <em>y</em>, <em>x</em> &gt; <em>y</em>)</span>. Exactly one of the three output bits must be 1. Idea: start from left, assuming the numbers are equal so far: <em>(0,1,0)</em>. Move over the columns from left to right, updating the results of the comparision using a building block circuit <em>cmp1</em>. Going from left to right, once we have established either <span class="math"> &lt; </span> or <span class="math"> &gt; </span>, that result will never change. If the current result is <span class="math"> = </span> and <span class="math"><em>x</em> = <em>y</em></span>, it's still <span class="math"> = </span>. If the current result is <span class="math"> = </span> but <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> are different, the new result becomes <span class="math"> &lt; </span> or <span class="math"> &gt; </span>.</p>
<p>A bit comparison building block circuit:</p>
<pre><code>cmp1 :: Bit a =&gt; (a,a,a) -&gt; (a,a) -&gt; (a,a,a)
cmp1 (lt,eq,gt) (x,y) =
  (or2 lt (and3 eq (inv x) y),
   and2 eq (inv (xor2 x y)),
   or2 gt (and3 eq x (inv y))
  )</code></pre>
<p>The ripple comparison circuit is defined simply using the pattern:</p>
<pre><code>rippleCmp :: Bit a =&gt; [(a,a)] -&gt; (a,a,a)
rippleCmp = foldl cmp1 (zero,one,zero)</code></pre>
<h3 id="fold-from-the-right-foldr"><a href="#fold-from-the-right-foldr">Fold from the right: foldr</a></h3>
<p>You can also run a fold across a word from the right to the left.</p>
<pre><code>foldr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)</code></pre>
<p>This is symmetric with <em>foldl</em>.</p>
<p>The foldr pattern</p>
<p></p>
<p></p>
<h2 id="scan"><a href="#scan">Scan</a></h2>
<p>A fold calculates a sequence of intermediate values, one for every bit position. A more general kind of pattern---a <em>scan</em>---outputs this word of intermediate values. For every kind of fold, there is a corresponding scan, and there are also some more general patterns that are based on scan. Scans are important because many important computations can be expressed via scans, and a variety of patterns exist that implement scans efficiently.</p>
<h3 id="scan-from-the-left-scanl"><a href="#scan-from-the-left-scanl">Scan from the left: scanl</a></h3>
<p></p>
<pre><code>\[ [y_0, y_1, y_2, y_3, y_4] \ =
  \ *scanl*\ f\ a\ [x_0, x_1, x_2, x_3]
\]

\[ *ys* \ = \ *scanl*\ f\ a\ *xs* \]</code></pre>
<h3 id="scan-from-the-right-scanr"><a href="#scan-from-the-right-scanr">Scan from the right: scanr</a></h3>
<p>The <em>ascanr</em> pattern yields the word of intermediate results that would occur during a <em>foldr</em>. Specifically, it gives the horizontal <em>input</em> to each box in the <em>foldr</em>.</p>
<pre><code>ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; [a]</code></pre>
<p>The value of the output word can be defined directly in terms of <em>foldr</em> of portions of the input word. This is useful for intuition and for formal mathematical reasoning.</p>
<pre><code>ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; (a,[a])
ascanr f a [] = (a,[])
ascanr f a (x:xs) = (f x a&#39;, a&#39;:xs&#39;)
  where (a&#39;,xs&#39;) = ascanr f a xs</code></pre>
<p></p>
<pre><code>\[ [y_0, y_1, y_2, y_3, y_4] \ =
  \ *scanr*\ f\ a\ [x_0, x_1, x_2, x_3]
\]

\[ *ys* \ = \ *scanr*\ f\ a\ *xs* \]</code></pre>
<h3 id="combining-a-map-with-a-scan"><a href="#combining-a-map-with-a-scan">Combining a map with a scan</a></h3>
<p>Many circuits combine a map with a scan: they output a value in each bit position that depends on both horizontal input and the value of the word in that bit position.</p>
<p>The <em>mscanr</em> pattern is useful for such cases (and there is a corresponding <em>mscanl</em>).</p>
<pre><code>mscanr :: (a-&gt;b-&gt;(b,c)) -&gt; b -&gt; [a] -&gt; (b,[c])
mscanr f a [] = (a,[])
mscanr f a (x:xs) = (a&#39;&#39;,y:ys)
  where
    (a&#39;,ys) = mscanr f a xs
    (a&#39;&#39;,y) = f x a&#39;</code></pre>
<p>Unidirectional mapping scan: mscanl, mscanr</p>
<p></p>
<p>(z, [y_0, y_1, y_2, y_3] = mscanr f a [x_0, x_1, x_2, x_3]</p>
<p>(z,ys) = mscanr f a xs</p>
<p></p>
<p>(z, [y_0, y_1, y_2, y_3] = mscanr f a [x_0, x_1, x_2, x_3]</p>
<p>(z,ys) = mscanr f a <em>xs</em></p>
<p>The ripple carry adder is an excellent example of scanr.</p>
<pre><code>fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)</code></pre>
<h3 id="ripple-carry-addition"><a href="#ripple-carry-addition">Ripple carry addition</a></h3>
<p>rippleAdd4</p>
<p></p>
<pre><code>rippleAdd4 :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd4 cin [(x0,y0),(x1,y1),(x2,y2),(x3,y3)]
  = (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd (x0,y0) c1
    (c1,s1) = fullAdd (x1,y1) c2
    (c2,s2) = fullAdd (x2,y2) c3
    (c3,s3) = fullAdd (x3,y3) cin</code></pre>
<pre><code>rippleAdd :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd = mscanr fullAdd</code></pre>
<p>Two's complement addition and subtraction</p>
<pre><code>addSub :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
addSub sub xy = rippleAdd sub (map f xy)
  where f (x,y) = (x, xor2 sub y)</code></pre>
<p>Circuit specifications using patterns can often be simplified if you pay attention to the order of parameters. For example, the ripple carry adder specification would be clunkier if we had defined the full adder as <em>fullAddInelegant :: Bit a =&gt; a -&gt; (a,a) -&gt; (a,a)</em>.</p>
<p>How can you make the definitions work out cleanly? Often there are choices that seem arbitrary at first, but later on you realise things would be simpler if the choice had been different. This is a good time to go back and clean up your specifications.</p>
<p>Two's complement addition and subtraction</p>
<pre><code>addSub :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
addSub sub xy = rippleAdd sub (map f xy)
  where f (x,y) = (x, xor2 sub y)</code></pre>
<h3 id="bidirectional-scan"><a href="#bidirectional-scan">Bidirectional scan</a></h3>
<p>A very general pattern is the <em>mscan</em> pattern, which takes a word, and <em>two</em> horizontal values, one moving from left to right and the other from right to left. The pattern combines a <em>foldl</em>, a <em>foldr</em>, and a <em>map</em>.</p>
<p>ALU circuits often use the <em>mscan</em> pattern.</p>
<pre><code>mscan :: (a-&gt;b-&gt;c-&gt;(b,a,d)) -&gt; a -&gt; b -&gt; [c] -&gt; (b,a,[d])
mscan f a b [] = (b,a,[])
mscan f a b (x:xs) = (b&#39;&#39;, a&#39;&#39;, y:ys)
  where
    (b&#39;&#39;,a&#39;,y) = f a b&#39; x
    (b&#39;,a&#39;&#39;,ys) = mscan f a&#39; b xs</code></pre>
<p></p>
<p>(b', a', [y_0, y_1, y_2, y_3]) = mscanr f a b [x_0, x_1, x_2, x_3]</p>
<p>(b', a', ys) = mscanr f a b <em>xs</em></p>
<h1 id="circuit-semantics"><a href="#circuit-semantics">Circuit semantics</a></h1>
<p>A digital circuit takes some input signals, performs a computation, and produces some output signals. Since the outputs depend on the inputs, the circuit acts like a mathematical function. This connection between circuits and functions is discussed in more depth in the chapter on synchronous circuits.</p>
<h2 id="boolean-signals"><a href="#boolean-signals">Boolean signals</a></h2>
<h2 id="streams"><a href="#streams">Streams</a></h2>
<h2 id="synchronous-circuits"><a href="#synchronous-circuits">Synchronous circuits</a></h2>
<h2 id="multiple-semantics"><a href="#multiple-semantics">Multiple semantics</a></h2>
<h2 id="path-depth"><a href="#path-depth">Path depth</a></h2>
<h2 id="netlists"><a href="#netlists">Netlists</a></h2>
<h1 id="equational-reasoning"><a href="#equational-reasoning">Equational reasoning</a></h1>
<h2 id="substituting-equals-for-equals"><a href="#substituting-equals-for-equals">Substituting equals for equals</a></h2>
<p>An equation in Hydra is a true mathematical equation, not an assignment statement. This has several consequences. One is that the order of the equations does not matter, and it is not necessary to define a signal before it is used. The set of equations above illustrates this: <em>x</em> is defined using <em>p</em> and <em>q</em>, whose definitions appear later. These equations could equally well be written in reverse order:</p>
<pre><code>r = nor2 c d
q = inv r
p = xor2 a b
x = nand2 p q</code></pre>
<p>The order of the equations makes no difference at all to the circuit; it's best to put them in whatever order seems to be easiest to understand. If a top-down view of the circuit seems natural, then the first set of equations is suitable, but if a bottom-up view is clearer, then the second set is better.</p>
<p>There is another important consequence of the fact that we are working with mathematical equations. We can perform <em>equational reasoning</em> to transform a circuit specification into a different form, with a guarantee that the circuit itself has not been affected. Suppose that we have an equation <em>x = e</em>. Equational reasoning means that if <em>x</em> appears in <em>e'</em>, we can replace it with <em>e</em>; conversely, if <em>e</em> appears in <em>e'</em> we can replace it with <em>x</em>. This process is sometimes called `substituting equals with equals', and it is central in algebraic reasoning.</p>
<p>Equational reasoning is one of the central advantages to a functional hardware description language. It has many applications: it can be used to rewrite a circuit to make it more readable; it can be used to transform a circuit to calculate the same result but do it faster; it can be used to prove that a circuit is correct according to an abstract specification. Equational reasoning can even be used to derive an implementation from a specification.</p>
<p>Here is a simple example of equational reasoning. Start with the set of equations discussed above:</p>
<pre><code>x = nand2 p q
p = xor2 a b
q = inv r
r = nor2 c d</code></pre>
<p>We can calculate the value of <em>x</em> using equational reasoning, in a sequence of steps:</p>
<pre><code>x = {definition of x}
nand2 p q
  = {substitute value of p}
nand2 (xor2 a b) q
  = {substitute value of q}
nand2 (xor2 a b) (inv r)
  = {substitute value of r}
nand2 (xor2 a b) (inv (nor2 c d))</code></pre>
<p>This calculation may not look very impressive, but later we will see how equational reasoning can solve some quite challenging problems.</p>
<h2 id="equivalent-ways-to-describe-a-circuit"><a href="#equivalent-ways-to-describe-a-circuit">Equivalent ways to describe a circuit</a></h2>
<h1 id="summary-of-syntax"><a href="#summary-of-syntax">Summary of syntax</a></h1>
<p>This section summarises the language syntax. Hydra is actually Haskell with some additional libraries, and it adopts all the syntax rules of Haskell.</p>
<p>Comments. There are two ways to indicate a comment (1) enclose the comment in brackets {- so this is a comment -} (2) A double dash -- indicates that everything else -- on the line is a comment</p>
<h2 id="indentation"><a href="#indentation">Indentation</a></h2>
<p>Haskell normally uses indentation, rather than punctuation, to determine the structure of a definition. There are good reasons behind this approach to syntax.</p>
<p>It is also possible to use braces and semicolons to determine the structure, instead of indentation. This is particularly useful for generators, where the specification is not written by hand and also not intended to be human readable. There are also some situations where a large number of very short equations can be more readable with many placed on each line, separated by punctuation. However, these situations are relatively uncommon. Normally it's best to use indentation and to make the layout of the code as readable as possible.</p>
<p>Indentation The equations in a definition need to be lined up vertically</p>
<p>circ x y = a -- a good definition where p = bla bla... q = bla... r = bla...</p>
<p>circ x y = a -- a bad definition where p = bla bla... q = bla... r = bla... -}</p>
<h2 id="names"><a href="#names">Names</a></h2>
<p>Names (also called identifiers) are used for circuits (e.g. logic gates) and signals. A name must begin with a lower case letter, and may contain letters, digits, underscores, and primes (single quote). The following are valid names:</p>
<pre><code>x
select
adder
y&#39;
bypass_ctl</code></pre>
<p>The following identifiers cannot be used to name a circuit or signal:</p>
<pre><code>Product    -- begins with upper case letter
x?3        -- contains invalid character ?
0          -- use zero to get the constant 0 signal</code></pre>
<h2 id="signal-expressions"><a href="#signal-expressions">Signal expressions</a></h2>
<p>A signal is specified in Hydra by an expression. The simplest form of expression is simply the name of a signal. For example, suppose we have signals named <em>x</em> and <em>y</em>. Then the following expressions denote the corresponding signals. Note that <em>zero</em> and <em>one</em> are simply the names of the constant signals.</p>
<pre><code>zero
one
x
y</code></pre>
<p>A signal is denoted by an expression, which can have any of the following forms:</p>
<ul>
<li><p>The constants <em>zero</em> and <em>one</em> are names that are pre-defined. These should not be redefined: don't write zero or one on the left hand side of an equation.</p></li>
<li><p>The name of a signal which is in scope: <em>x</em>, <em>carry</em>, <em>ctl_ld</em>. Later we will see how to define these, using equations or circuit inputs.</p></li>
<li><p>An application of a circuit to inputs denotes a signal: <em>or2 x y</em> specifies a signal which is the output of an <em>or2</em> gate connected to inputs <em>x</em> and <em>y</em>.</p></li>
</ul>
<p>Any of these notations can be used as input to a component.</p>
<p>The component and the inputs are separated by a space; don't use punctuation.</p>
<pre><code>c = and2 a b          -- correct
d = and2 (a,b);       -- wrong! don&#39;t use ( , ) ;</code></pre>
<h2 id="defining-equations-for-signals"><a href="#defining-equations-for-signals">Defining equations for signals</a></h2>
<p><a name="exercise:text-for-andor"><strong>Exercise</strong></a> <a href="#solution:text-for-andor"><em>(Go to solution)</em></a> Write a textual specification of the circuit in the following diagram:</p>
<div class="figure">
<img src="figures/xfig/andor.svg" title="schematic diagram" />
</div>
<h2 id="defining-equations-for-circuits"><a href="#defining-equations-for-circuits">Defining equations for circuits</a></h2>
<h1 id="error-messages-and-runtime-errors"><a href="#error-messages-and-runtime-errors">Error messages and runtime errors</a></h1>
<p>This section shows some typical error messages and runtime errors, and gives hints about how to handle them.</p>
<h1 id="implementation-of-hydra"><a href="#implementation-of-hydra">Implementation of Hydra</a></h1>
<h2 id="files"><a href="#files">Files</a></h2>
<p>Metadata</p>
<p>index.html Top level of documentation README.txt General information LICENSE.txt GPL license Hydra.cabal Information needed to compile the software Setup.hs Haskell build configuration makefile commands for maintainance and development</p>
<h2 id="source-directories"><a href="#source-directories">Source directories</a></h2>
<p>src contains the Hydra source code and the user guide source text</p>
<p>circuits contains a collection of examples. There is a naming convention: a file whose name matches *Run.hs is a main module containing a simulation driver and test data; you can run the simulation by entering ghc -e main *Run. Other files contain circuit specifications.</p>
<p>Automatically generated directories (can be deleted)</p>
<p>doc contains documentation files in html format. These are generated from sources (in src/docsrc). The entire doc directory can be deleted and regenerated by make doc.</p>
<p>dist contains the object code and interface files, as well as the library documentation generated by haddock</p>
<p>Hydra archve ... lots of tarballs, this is where snapshots will be saved ... current-version Hydra-i.j.k released ... some tarballs or zips ...</p>
<h1 id="further-information"><a href="#further-information">Further information</a></h1>
<p>For detailed documentation of the circuits and Hydra language tools, see the <a href="../../../dist/doc/html/Hydra/index.html">library interface reference</a>.</p>
<h1 id="solutions-to-the-exercises"><a href="#solutions-to-the-exercises">Solutions to the exercises</a></h1>
<p>
  
<p><a name="solution:or2-and2"><strong>Solution</strong></a> <a href="#exercise:or2-and2"><em>(Go to exercise)</em></a> <em>x = or2 (and2 a b) c</em></p>
</p><p>
  
<p><a name="solution:inv-and2"><strong>Solution</strong></a> <a href="#exercise:inv-and2"><em>(Go to exercise)</em></a> The diagram for inv and2 a b goes here.</p>
</p><p>
  
<p><a name="solution:xor2-nand3"><strong>Solution</strong></a> <a href="#exercise:xor2-nand3"><em>(Go to exercise)</em></a> The diagram for xor2-nand3 goes here.</p>
</p><p>
  
<p><a name="solution:use-mux1w"><strong>Solution</strong></a> <a href="#exercise:use-mux1w"><em>(Go to exercise)</em></a> <em>z = mux1w c x y</em></p>
</p><p>
  
<p><a name="solution:text-for-andor"><strong>Solution</strong></a> <a href="#exercise:text-for-andor"><em>(Go to exercise)</em></a> <em>y = or2 (and2 a b) c</em></p>
</p>

<h1 id="index"><a href="#index">Index</a></h1>
<h1 id="colophon"><a href="#colophon">Colophon</a></h1>
<p>This document is written in markdown augmented with m4 macros. The source is indexsrc.m4; this is processed by m4 producing indextemp.txt which is then processed by pandoc to produce index.html.</p>
<p>The links between exercises and solutions are generated by macros. xBeginExercise, xBeginSolution, xEndsolution (without leading x) should all start at the beginning of a line, after a blank line. If xBeginSolution doesn't follow a blank line the content can become scrambled.</p>
<p>Here are some experiments with diagrams.</p>
<object type="image/svg+xml"
  data="figures/svg/xor2-a-b.svg"> </object>

<p>This is a separator paragraph.</p>
<object type="image/svg+xml"
  data="figures/svg/xor2-a-b-modified.svg"> </object>

<p>This is a separator paragraph.</p>
<div class="figure">
<img src="figures/pgf/test-and2-svg.svg" />
</div>
</body>
</html>
