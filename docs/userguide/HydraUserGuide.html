<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="John T. O'Donnell" />
  <title>Hydra User Guide</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="userguide-style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Hydra User Guide</h1>
<p class="author">John T. O'Donnell</p>
<p class="date">version:         2.4.1</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#hydra-a-language-for-circuit-specification">Hydra: a language for circuit specification</a><ul>
<li><a href="#specifications">Specifications</a></li>
<li><a href="#hardware-description-languages">Hardware description languages</a></li>
<li><a href="#functional-hardware-description">Functional hardware description</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#circuits">Circuits</a></li>
<li><a href="#equations">Equations</a></li>
<li><a href="#typesetting-notes">Typesetting notes</a></li>
</ul></li>
</ul>
</nav>
<h1 id="hydra-a-language-for-circuit-specification">Hydra: a language for circuit specification</h1>
<p>Some references to include <span class="citation" data-cites="J84-app-prog-dig-design"></span> <span class="citation" data-cites="2002-OD-PDSECA-Hydra"></span> <span class="citation" data-cites="1995-OD-Hydra-FPLE"></span>.</p>
<p>&lt;a name="exercise:or2-and2"&gt;**Exercise**&lt;/a&gt; &lt;a href="#solution:or2-and2"&gt;*(Go to solution)*&lt;/a&gt; Write the Hydra notation for this schematic diagram: ![](figures/xfig/andor.svg "schematic diagram")</p>
<p>&lt;a name="exercise:inv-and2"&gt;**Exercise**&lt;/a&gt; &lt;a href="#solution:inv-and2"&gt;*(Go to solution)*&lt;/a&gt; Draw a schematic diagram for <strong>inv (and2 a b)</strong>.</p>
<p>&lt;a name="exercise:xor2-nand3"&gt;**Exercise**&lt;/a&gt; &lt;a href="#solution:xor2-nand3"&gt;*(Go to solution)*&lt;/a&gt; Draw a schematic diagram for <strong>xor2 (nand3 p q r) (or2 x y)</strong>.</p>
<p>To design a circuit, and to do anything useful with it, we need a way to describe it. The description must be understandable, and it also needs to be clear, complete, and precise. Such a description is called a <em>circuit specification</em>.</p>
<p>This chapter introduces circuit specification using Hydra, a <em>functional hardware description language</em> which is used throughout this book. The focus is on the basic concepts and notations. Later chapters describe features relating to circuit models and simulation, sequential circuits, design patterns, and more.</p>
<p>Hydra is implemented using Haskell, a general purpose functional programming language. Hydra is a subset of Haskell, augmented with libraries. A circuit specification is compiled using the Haskell compiler, and there is no separate Hydra compiler. However, it's better to think of Hydra as a distinct language, and some of the software tools will give an error message if you try to step outside of Hydra and write general Haskell code in a circuit specification. You don't need to know how Hydra is implemented in order to use it, but Chapter ?? explains how the implementation works.</p>
<p>The initial sections in this chapter introduce the basic concepts and illustrate them with examples. Toward the end of the chapter there is a more detailed explanation of some of the syntax rules, but a good way to get started is to follow the patterns shown in the examples.</p>
<h2 id="specifications">Specifications</h2>
<p>In any system design, it is valuable to make a distinction between a <em>specification</em> and an <em>implementation</em>. This applies both to software and to hardware. A specification is a clear statement of <em>what</em> the system is intended to do, while the implementation shows <em>how</em> the primitive operations that are available can achieve the result.</p>
<p>A circuit specification may be abstract, giving just a description of the intended behavior of the circuit. Alternatively, it may be written in a way that describes the structure as well as the function of the hardware. In this chapter, we will focus on this lower level form of specification.</p>
<p>A specification may take the form of a diagram or a piece of text. For digital circuits, a pictorial specification is called a <em>schematic diagram</em> while a textual specification uses a <em>hardware description language</em>. Both forms can also be used for software: a textual specification of an algorithm uses a programming language, but there are also visual programming languages that used diagrams to describe algorithms.</p>
<p>A schematic diagram is an abstract picture of a circuit. It shows the components and how they are connected with wires, but it does not directly describe the circuit's function. A schematic diagram implies some geometric information, such as the relative placement of components, and this geometry may be used in fabricating the circuit.</p>
<h2 id="hardware-description-languages">Hardware description languages</h2>
<p>An alternative approach is to use a computer hardware description language (`CHDL' or just `HDL', for hardware description language). A circuit specification using an HDL is a text document, so it looks superficially like a computer program, but it describes hardware rather than software.</p>
<p>Schematic diagrams and hardware description languages each have their merits. A diagram may be easier for a beginner to understand, and it is more obvious that a schematic describes hardware, and isn't just a computer program. However, hardware description languages scale up better to large and complex circuits, and fit better with software tools that perform actions using a specification (simulation, analysis, etc.).</p>
<p>Hardware description languages use many of the same concepts that appear in programming languages. This is natural, because the purpose of both hardware and software is to express algorithms, and both benefit from abstraction, repetition, and similar concepts. Some hardware description languages are based on imperative languages. We will be using Hydra, which is based on Haskell, a pure functional language.</p>
<h2 id="functional-hardware-description">Functional hardware description</h2>
<p>A functional language uses mathematical functions and equations to present an algorithm. In contrast, an imperative language is based on assignment statements that change the state of a variable.</p>
<p>A functional hardware description language, such as Hydra, uses a function to model a circuit. This is natural, because a circuit and a function are both a black box that takes some inputs and produces some outputs.</p>
<p>Hydra is a language that allows a digital circuit to be described precisely. However, Hydra is not suitable for all circuits: it assumes that all the values on wires are digital, rather than continuously varying analogue voltages. There are other hardware description languages that can handle analogue circuits, but Hydra is suitable for describing digital circuits like computers, but not analogue circuits like radio receivers.</p>
<p>It isn't necessary to know how Hydra is implemented in order to use it, but a brief discussion helps to put the language into context. Hydra is an example of an <em>embedded domain-specific language</em>. A domain-specific language is a language intended for one specific application domain, not for general purpose programming. Hydra is suitable specifically for expressing algorithms as digital circuits, but it isn't a general purpose programming language. It is implemented by <em>embedding</em> in Haskell, which is a general purpose functional language. This means that Hydra doesn't have a separate compiler; instead, its implementation consists of a library of Haskell modules. A circuit specification written in Hydra is compiled by the Haskell compiler and linked with the Hydra library.</p>
<h2 id="signals">Signals</h2>
<p>A data value in a circuit is called a <em>signal</em>. Signals are carried between components on wires. Normally we are not interested in the physical characteristics of a wire, although these can be important at the lower levels of chip design, so we will usually refer to signals rather than wires. A signal may be a bit, or a cluster comprising several bits. We can also describe circuits at a higher level, where signals represent integers or other data types.</p>
<p>A bit can have one of two distinct values. Several names are commonly used for these values; the most commonly used are 0/1, Low/High, False/True, and F/T. In real hardware a bit signal is represented by a voltage, but the precise voltage value is unimportant at the level of logic design. The particular names chosen for the two bit values are unimportant, although they can affect the readability of a table showing the behavior of a circuit. When Hydra prints out the values of bit signals, it will normally use 0 and 1, but you can tell it to use False and True, or any other names you prefer. The advantage of 0 and 1 is that they take up only one character and they look different (try reading a table showing thousands of F and T characters—they can be hard to tell apart!).</p>
<p>A constant signal is a wire that always carries the same value: either it is always 0, or always 1. When writing a circuit specification, the two constant bit signals are written as |zero| and |one|. (Do <em>not</em> use 0/1, or T/F, or True/False in a circuit specification; those notations have other meanings.)</p>
<h2 id="circuits">Circuits</h2>
<p>A circuit is a machine that takes some input signals, performs a computation, and produces some output signals. Since the outputs depend on the inputs, the circuit acts like a mathematical function. This connection between circuits and functions is discussed in more depth in the chapter on synchronous circuits.</p>
<p>To design a new circuit, you need to take a set of existing circuits and connect them with wires. There are several libraries of existing circuits that you can start with, and you can also define libraries of your own circuits for further use. The standard logic gates are defined as primitives in a library.</p>
<p>A signal is specified in Hydra by an expression. The simplest form of expression is simply the name of a signal. For example, suppose we have signals named |x| and |y|. Then the following expressions denote the corresponding signals. Note that |zero| and |one| are simply the names of the constant signals.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">zero</a>
<a class="sourceLine" id="cb1-2" title="2">one</a>
<a class="sourceLine" id="cb1-3" title="3">x</a>
<a class="sourceLine" id="cb1-4" title="4">y</a></code></pre></div>
<p>Another way to define a signal is to write an expression that introduces a component or circuit. The value of the expression is the signal that is the output of the component. The inputs to the component, which are also signals, must be written after the name of the component. Here is an example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">or2 x y</a></code></pre></div>
<p>This is an expression consisting of the name of a component (|and2|) followed by the names of the inputs to the component (|x| and |y|). The entire expression describes the output produced by the |or2| gate. Such an expression is called an <em>application</em> because the component is applied to its input signals.</p>
<p>Each circuit takes a specific number of inputs, and an application using that circuit must supply the corresponding number of input signals. Here are several applications of logic gates, each with the right number of inputs.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">inv x</a>
<a class="sourceLine" id="cb3-2" title="2">and2 a b</a>
<a class="sourceLine" id="cb3-3" title="3">xor3 p q r</a>
<a class="sourceLine" id="cb3-4" title="4">nor4 a b c d</a></code></pre></div>
<p>The expressions we have seen so far assume that we know the names of all the input signals. Since an application denotes a signal, we can that directly as an input. Here is an |and2| gate with two inputs: the first input is connected to the output of an inverter (whose input is |x|), and the second input is |y|.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">and2 (inv x) y</a></code></pre></div>
<p>The expression that describes the output of the inverter requires several symbols, the component |inv| and its input |x|. Such an expression needs to be enclosed in parentheses; thus |(inv x)| is a single value. The following notation would be wrong:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">and2 inv x y   <span class="co">-- Wrong!</span></a></code></pre></div>
<p> The problem is that it looks like the |and2| gate is being given three inputs, not two, and the first one isn't even a signal.</p>
<p>Parentheses are used in Hydra for grouping, just as in mathematics. You don't need to use parentheses just to specify the arguments to a function (that is, the inputs to a circuit). Some programming languages requires lots of punctuation to indicate function application:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">nand3 (x, and2 (p,q), z)</a></code></pre></div>
<p>In Hydra (as in Haskell) you don't need the extra parentheses and commas; just use parentheses when they are necessary to get the right grouping:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">nand3 x (and2 p q) z</a></code></pre></div>

<div class="sourceCode" id="cb8"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">x <span class="fu">=</span> or2 (and2 a b) c</a></code></pre></div>
<p>Here we need the parentheses to indicate that <em>and2 a b</em> denotes a single value (a signal).</p>
<p>It can be helpful to give both a schematic diagram and a textual specification for a circuit. Each form of description provides insight, and having both together is often worthwhile. But it is important to check that the two descriptions of the circuit are consistent with each other. To do this, check that every box in the diagram corresponds to a circuit (function) in the text, and check that the wires in the diagram correspond to the signals in the text.</p>
<p>A useful skill is the ability to convert from a schematic to Hydra, or vice versa. The following problems give some practice with this.</p>


<h2 id="equations">Equations</h2>
<p>So far, we have seen expressions that define a new signal as the output of a component. But the output signal has no name: it is anonymous. An equation can be used to give it a name. The left hand side of an equation is the name to be attached to the signal, and the right hand side is an expression that defines the value of the signal. The following equation says that the output of the |and3| gate has the name |x|.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">x <span class="fu">=</span> and3 a (inv b) c</a></code></pre></div>
<p>The corresponding schematic diagram is:</p>

<p>Signals may be named by an equation, or they may be anonymous. It is always possible to name all the signals, if you want to. This circuit contains several anonymous signals:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">x <span class="fu">=</span> nand2 (xor2 a b) (inv (nor2 c d))</a></code></pre></div>
<p>This can be rewritten so as to give every signal an explicit name, by introducing additional equations:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">x <span class="fu">=</span> nand2 p q</a>
<a class="sourceLine" id="cb11-2" title="2">p <span class="fu">=</span> xor2 a b</a>
<a class="sourceLine" id="cb11-3" title="3">q <span class="fu">=</span> inv r</a>
<a class="sourceLine" id="cb11-4" title="4">r <span class="fu">=</span> nor2 c d</a></code></pre></div>
<p>Sometimes an equation like this is called a <em>defining equation</em>, because the left hand side has to be a signal name whose value is defined to be the right hand side. It would be wrong, for example, to write</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">nand2 p q <span class="fu">=</span> x   <span class="co">-- Wrong!</span></a></code></pre></div>
<p>\subsection{Equational reasoning}</p>
<p>An equation in Hydra is a true mathematical equation, not an assignment statement. This has several consequences. One is that the order of the equations does not matter, and it is not necessary to define a signal before it is used. The set of equations above illustrates this: |x| is defined using |p| and |q|, whose definitions appear later. These equations could equally well be written in reverse order:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">r <span class="fu">=</span> nor2 c d</a>
<a class="sourceLine" id="cb13-2" title="2">q <span class="fu">=</span> inv r</a>
<a class="sourceLine" id="cb13-3" title="3">p <span class="fu">=</span> xor2 a b</a>
<a class="sourceLine" id="cb13-4" title="4">x <span class="fu">=</span> nand2 p q</a></code></pre></div>
<p>The order of the equations makes no difference at all to the circuit; it's best to put them in whatever order seems to be easiest to understand. If a top-down view of the circuit seems natural, then the first set of equations is suitable, but if a bottom-up view is clearer, then the second set is better.</p>
<p>There is another important consequence of the fact that we are working with mathematical equations. We can perform <em>equational reasoning</em> to transform a circuit specification into a different form, with a guarantee that the circuit itself has not been affected. Suppose that we have an equation |x = e|. Equational reasoning means that if |x| appears in |e'|, we can replace it with |e|; conversely, if |e| appears in |e'| we can replace it with |x|. This process is sometimes called `substituting equals with equals', and it is central in algebraic reasoning.</p>
<p>Equational reasoning is one of the central advantages to a functional hardware description language. It has many applications: it can be used to rewrite a circuit to make it more readable; it can be used to transform a circuit to calculate the same result but do it faster; it can be used to prove that a circuit is correct according to an abstract specification. Equational reasoning can even be used to derive an implementation from a specification.</p>
<p>Here is a simple example of equational reasoning. Start with the set of equations discussed above:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">x <span class="fu">=</span> nand2 p q</a>
<a class="sourceLine" id="cb14-2" title="2">p <span class="fu">=</span> xor2 a b</a>
<a class="sourceLine" id="cb14-3" title="3">q <span class="fu">=</span> inv r</a>
<a class="sourceLine" id="cb14-4" title="4">r <span class="fu">=</span> nor2 c d</a></code></pre></div>
<p> We can calculate the value of |x| using equational reasoning, in a sequence of steps:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">x <span class="fu">=</span> {definition <span class="kw">of</span> x}</a>
<a class="sourceLine" id="cb15-2" title="2">nand2 p q</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="fu">=</span> {substitute value <span class="kw">of</span> p}</a>
<a class="sourceLine" id="cb15-4" title="4">nand2 (xor2 a b) q</a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="fu">=</span> {substitute value <span class="kw">of</span> q}</a>
<a class="sourceLine" id="cb15-6" title="6">nand2 (xor2 a b) (inv r)</a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="fu">=</span> {substitute value <span class="kw">of</span> r}</a>
<a class="sourceLine" id="cb15-8" title="8">nand2 (xor2 a b) (inv (nor2 c d))</a></code></pre></div>
<p> This calculation may not look very impressive, but later we will see how equational reasoning can solve some quite challenging problems.</p>
<p>\section{General Boolean functions}</p>
<p>Suppose a Boolean function has <span class="math inline"><em>k</em></span> inputs, and one output.</p>

<p>For small <span class="math inline"><em>k</em></span>, we can enumerate all of these functions.</p>
<p>\subsection{0 inputs}</p>
<p>With 0 inputs, there are <span class="math inline">2<sup>0</sup> = 1</span> lines in the truth table, and <span class="math inline">2<sup>1</sup> = 2</span> distinct truth tables (thus two functions).</p>
<p></p>

<p></p>
<p>A 0-argument function is just a constant! These really are truth tables, although they are degenerate—compare them with the following slides.</p>
<p>Use <em>zero</em> and <em>one</em> as the two constants.</p>
<p>\subsection{1 input}</p>
<p>With 1 input <span class="math inline"><em>x</em></span>, there are <span class="math inline">2<sup>1</sup> = 2</span> lines in each truth table, and <span class="math inline">2<sup>2</sup> = 4</span> functions (distinct truth tables).</p>
<p></p>

<p>Here <span class="math inline"><em>f</em><sub>1</sub></span> is <em>buf</em>, and <span class="math inline"><em>f</em><sub>2</sub></span> is <em>inv</em>. The others aren't particularly useful.</p>
<p>\subsection{2 inputs}</p>
<p>With 2 inputs, there are <span class="math inline">2<sup>2</sup> = 4</span> lines in the truth table, and <span class="math inline">2<sup>(2<sup>2</sup>)</sup> = 16</span> distinct truth tables (functions).</p>
<p>All 16 possible functions can be enumerated in a table (each column specifies a distinct function):</p>
<p>{</p>

<p>}</p>
<p>\subsection{Identifying the Common Functions}</p>
<p>{</p>

<p>}</p>
<p>Possible Names for All Functions</p>
<p>{</p>

<p>}</p>
<p></p>
<p>Don't take these names too seriously—they aren't standard. The point is that all of these functions do exist. What is important is the existence and the value of a function, not its name.</p>
<p>(In this naming scheme, con means <em>constant</em>; j means <em>just</em>, nj means <em>not just</em>.)</p>
<h2 id="typesetting-notes">Typesetting notes</h2>
<ul>
<li>C-c C-e h h org-html-export-to-html</li>
</ul>
<p>&lt;p&gt; &lt;a name="solution:or2-and2"&gt;**Solution**&lt;/a&gt; &lt;a href="#exercise:or2-and2"&gt;*(Go to exercise)*&lt;/a&gt; <strong>x = or2 (and2 a b) c</strong></p>
<p>&lt;/p&gt;&lt;p&gt; &lt;a name="solution:inv-and2"&gt;**Solution**&lt;/a&gt; &lt;a href="#exercise:inv-and2"&gt;*(Go to exercise)*&lt;/a&gt; The diagram for inv and2 a b goes here.</p>
<p>&lt;/p&gt;&lt;p&gt; &lt;a name="solution:xor2-nand3"&gt;**Solution**&lt;/a&gt; &lt;a href="#exercise:xor2-nand3"&gt;*(Go to exercise)*&lt;/a&gt; The diagram for xor2-nand3 goes here.</p>
<p>&lt;/p&gt;</p>
</body>
</html>
