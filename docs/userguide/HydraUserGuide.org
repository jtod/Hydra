#+TITLE: Hydra User Guide
#+AUTHOR: John T. O'Donnell
#+DATE: October 2020

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
  
* Hydra: a language for circuit specification

Some references to include \cite{J84-app-prog-dig-design}
\cite{2002-OD-PDSECA-Hydra} \cite{1995-OD-Hydra-FPLE}.


To design a circuit, and to do anything useful with it, we need a way
to describe it.  The description must be understandable, and it also
needs to be clear, complete, and precise.  Such a description is
called a \emph{circuit specification}.

This chapter introduces circuit specification using Hydra, a
\emph{functional hardware description language} which is used
throughout this book.  The focus is on the basic concepts and
notations.  Later chapters describe features relating to circuit
models and simulation, sequential circuits, design patterns, and more.

Hydra is implemented using Haskell, a general purpose functional
programming language.  Hydra is a subset of Haskell, augmented with
libraries.  A circuit specification is compiled using the Haskell
compiler, and there is no separate Hydra compiler.  However, it's
better to think of Hydra as a distinct language, and some of the
software tools will give an error message if you try to step outside
of Hydra and write general Haskell code in a circuit specification.
You don't need to know how Hydra is implemented in order to use it,
but Chapter ?? explains how the implementation works.

The initial sections in this chapter introduce the basic concepts and
illustrate them with examples.  Toward the end of the chapter there is
a more detailed explanation of some of the syntax rules, but a good
way to get started is to follow the patterns shown in the examples.

** Specifications

In any system design, it is valuable to make a distinction between a
\emph{specification} and an \emph{implementation}.  This applies both
to software and to hardware.  A specification is a clear statement of
\emph{what} the system is intended to do, while the implementation
shows \emph{how} the primitive operations that are available can
achieve the result.

A circuit specification may be abstract, giving just a description of
the intended behavior of the circuit.  Alternatively, it may be
written in a way that describes the structure as well as the function
of the hardware.  In this chapter, we will focus on this lower level
form of specification.

A specification may take the form of a diagram or a piece of text.
For digital circuits, a pictorial specification is called a
\emph{schematic diagram} while a textual specification uses a
\emph{hardware description language}.  Both forms can also be used for
software: a textual specification of an algorithm uses a programming
language, but there are also visual programming languages that used
diagrams to describe algorithms.

A schematic diagram is an abstract picture of a circuit.  It shows the
components and how they are connected with wires, but it does not
directly describe the circuit's function.  A schematic diagram implies
some geometric information, such as the relative placement of
components, and this geometry may be used in fabricating the circuit.

** Hardware description languages

An alternative approach is to use a computer hardware description
language (``CHDL'' or just ``HDL'', for hardware description
language).  A circuit specification using an HDL is a text document,
so it looks superficially like a computer program, but it describes
hardware rather than software.

Schematic diagrams and hardware description languages each have their
merits.  A diagram may be easier for a beginner to understand, and it
is more obvious that a schematic describes hardware, and isn't just a
computer program.  However, hardware description languages scale up
better to large and complex circuits, and fit better with software
tools that perform actions using a specification (simulation,
analysis, etc.).

Hardware description languages use many of the same concepts that
appear in programming languages.  This is natural, because the purpose
of both hardware and software is to express algorithms, and both
benefit from abstraction, repetition, and similar concepts.  Some
hardware description languages are based on imperative languages.  We
will be using Hydra, which is based on Haskell, a pure functional
language.

** Functional hardware description

A functional language uses mathematical functions and equations to
present an algorithm.  In contrast, an imperative language is based on
assignment statements that change the state of a variable.

A functional hardware description language, such as Hydra, uses a
function to model a circuit.  This is natural, because a circuit and a
function are both a black box that takes some inputs and produces some
outputs.

Hydra is a language that allows a digital circuit to be described
precisely.  However, Hydra is not suitable for all circuits: it
assumes that all the values on wires are digital, rather than
continuously varying analogue voltages.  There are other hardware
description languages that can handle analogue circuits, but Hydra
is suitable for describing digital circuits like computers, but not
analogue circuits like radio receivers.

It isn't necessary to know how Hydra is implemented in order to use
it, but a brief discussion helps to put the language into context.
Hydra is an example of an \emph{embedded domain-specific language}.  A
domain-specific language is a language intended for one specific
application domain, not for general purpose programming.  Hydra is
suitable specifically for expressing algorithms as digital circuits,
but it isn't a general purpose programming language.  It is
implemented by \emph{embedding} in Haskell, which is a general purpose
functional language.  This means that Hydra doesn't have a separate
compiler; instead, its implementation consists of a library of Haskell
modules. A circuit specification written in Hydra is compiled by the
Haskell compiler and linked with the Hydra library.

** Signals

A data value in a circuit is called a \emph{signal}.  Signals are
carried between components on wires.  Normally we are not interested
in the physical characteristics of a wire, although these can be
important at the lower levels of chip design, so we will usually refer
to signals rather than wires.  A signal may be a bit, or a cluster
comprising several bits.  We can also describe circuits at a higher
level, where signals represent integers or other data types.

A bit can have one of two distinct values.  Several names are commonly
used for these values; the most commonly used are 0/1, Low/High,
False/True, and F/T.  In real hardware a bit signal is represented by
a voltage, but the precise voltage value is unimportant at the level
of logic design.  The particular names chosen for the two bit values
are unimportant, although they can affect the readability of a table
showing the behavior of a circuit.  When Hydra prints out the values
of bit signals, it will normally use 0 and 1, but you can tell it to
use False and True, or any other names you prefer.  The advantage of 0
and 1 is that they take up only one character and they look different
(try reading a table showing thousands of F and T characters---they
can be hard to tell apart!).

A constant signal is a wire that always carries the same value: either
it is always 0, or always 1.  When writing a circuit specification,
the two constant bit signals are written as |zero| and |one|.  (Do
\emph{not} use 0/1, or T/F, or True/False in a circuit specification;
those notations have other meanings.)

** Circuits

A circuit is a machine that takes some input signals, performs a
computation, and produces some output signals.  Since the outputs
depend on the inputs, the circuit acts like a mathematical function.
This connection between circuits and functions is discussed in more
depth in the chapter on synchronous circuits.

To design a new circuit, you need to take a set of existing circuits
and connect them with wires.  There are several libraries of existing
circuits that you can start with, and you can also define libraries of
your own circuits for further use.  The standard logic gates are
defined as primitives in a library.

A signal is specified in Hydra by an expression.  The simplest form of
expression is simply the name of a signal.  For example, suppose we
have signals named |x| and |y|.  Then the following expressions denote
the corresponding signals.  Note that |zero| and |one| are simply the
names of the constant signals.

#+BEGIN_SRC Haskell
zero
one
x
y
#+END_SRC

Another way to define a signal is to write an expression that
introduces a component or circuit.  The value of the expression is the
signal that is the output of the component.  The inputs to the
component, which are also signals, must be written after the name of
the component.  Here is an example:

#+BEGIN_SRC Haskell
or2 x y
#+END_SRC


This is an expression consisting of the name of a component (|and2|)
followed by the names of the inputs to the component (|x| and |y|).
The entire expression describes the output produced by the |or2| gate.
Such an expression is called an \emph{application} because the
component is applied to its input signals.

Each circuit takes a specific number of inputs, and an application
using that circuit must supply the corresponding number of input
signals.  Here are several applications of logic gates, each with the
right number of inputs.

#+BEGIN_SRC Haskell
inv x
and2 a b
xor3 p q r
nor4 a b c d
#+END_SRC

The expressions we have seen so far assume that we know the names of
all the input signals.  Since an application denotes a signal, we can
that directly as an input.  Here is an |and2| gate with two inputs:
the first input is connected to the output of an inverter (whose input
is |x|), and the second input is |y|.

#+BEGIN_SRC Haskell
and2 (inv x) y
#+END_SRC

The expression that describes the output of the inverter requires
several symbols, the component |inv| and its input |x|.  Such an
expression needs to be enclosed in parentheses; thus |(inv x)| is a
single value.  The following notation would be wrong:

#+BEGIN_SRC Haskell
and2 inv x y   -- Wrong!
#+END_SRC

\noindent
The problem is that it looks like the |and2| gate is being given three
inputs, not two, and the first one isn't even a signal.

Parentheses are used in Hydra for grouping, just as in mathematics.
You don't need to use parentheses just to specify the arguments to a
function (that is, the inputs to a circuit).  Some programming
languages requires lots of punctuation to indicate function
application:

#+BEGIN_SRC Haskell
nand3 (x, and2 (p,q), z)
#+END_SRC

In Hydra (as in Haskell) you don't need the extra parentheses and
commas; just use parentheses when they are necessary to get the right
grouping:

#+BEGIN_SRC Haskell
nand3 x (and2 p q) z
#+END_SRC

\begin{center}
  \includegraphics[scale=1.0]{figures/xfig/andor.eps}
\end{center}

#+BEGIN_SRC Haskell
x = or2 (and2 a b) c
#+END_SRC

Here we need the parentheses to indicate that \textit{and2 a b}
denotes a single value (a signal).

It can be helpful to give both a schematic diagram and a textual
specification for a circuit.  Each form of description provides
insight, and having both together is often worthwhile. But it is
important to check that the two descriptions of the circuit are
consistent with each other.  To do this, check that every box in the
diagram corresponds to a circuit (function) in the text, and check
that the wires in the diagram correspond to the signals in the text.

A useful skill is the ability to convert from a schematic to Hydra, or
vice versa.  The following problems give some practice with this.

\begin{exercise}
Draw a schematic diagram corresponding to the following Hydra
specifications:
\begin{enumerate}
\item inv (and2 a b)
\item xor2 (nand3 p q r) (or2 x y)
\end{enumerate}
\begin{solution}
An easy one, no?
\end{solution}
\end{exercise}

\begin{exercise}
Write a Hydra specification corresponding to the following schematic
diagrams:
\begin{enumerate}
\item foo
\item bar
\end{enumerate}
\begin{solution}
Hmmm
\end{solution}
\end{exercise}


** Equations

So far, we have seen expressions that define a new signal as the
output of a component.  But the output signal has no name: it is
anonymous.  An equation can be used to give it a name.  The left hand
side of an equation is the name to be attached to the signal, and the
right hand side is an expression that defines the value of the signal.
The following equation says that the output of the |and3| gate has the
name |x|.

#+BEGIN_SRC Haskell
x = and3 a (inv b) c
#+END_SRC

The corresponding schematic diagram is:

\begin{center}
  \includegraphics[scale=1.0]{figures/xfig/inv-and3.eps}
\end{center}

Signals may be named by an equation, or they may be anonymous.  It is
always possible to name all the signals, if you want to.  This circuit
contains several anonymous signals:

#+BEGIN_SRC Haskell
x = nand2 (xor2 a b) (inv (nor2 c d))
#+END_SRC

This can be rewritten so as to give every signal an explicit name, by
introducing additional equations:

#+BEGIN_SRC Haskell
x = nand2 p q
p = xor2 a b
q = inv r
r = nor2 c d
#+END_SRC

Sometimes an equation like this is called a \emph{defining equation},
because the left hand side has to be a signal name whose value is
defined to be the right hand side.  It would be wrong, for example, to
write

#+BEGIN_SRC Haskell
nand2 p q = x   -- Wrong!
#+END_SRC

\subsection{Equational reasoning}

An equation in Hydra is a true mathematical equation, not an
assignment statement.  This has several consequences.  One is that the
order of the equations does not matter, and it is not necessary to
define a signal before it is used.  The set of equations above
illustrates this: |x| is defined using |p| and |q|, whose definitions
appear later.  These equations could equally well be written in
reverse order:

#+BEGIN_SRC Haskell
r = nor2 c d
q = inv r
p = xor2 a b
x = nand2 p q
#+END_SRC

The order of the equations makes no difference at all to the circuit;
it's best to put them in whatever order seems to be easiest to
understand.  If a top-down view of the circuit seems natural, then the
first set of equations is suitable, but if a bottom-up view is
clearer, then the second set is better.

There is another important consequence of the fact that we are working
with mathematical equations.  We can perform \emph{equational
  reasoning} to transform a circuit specification into a different
form, with a guarantee that the circuit itself has not been affected.
Suppose that we have an equation |x = e|.  Equational reasoning means
that if |x| appears in |e'|, we can replace it with |e|; conversely,
if |e| appears in |e'| we can replace it with |x|.  This process is
sometimes called ``substituting equals with equals'', and it is
central in algebraic reasoning.

Equational reasoning is one of the central advantages to a functional
hardware description language.  It has many applications: it can be
used to rewrite a circuit to make it more readable; it can be used to
transform a circuit to calculate the same result but do it faster; it
can be used to prove that a circuit is correct according to an
abstract specification.  Equational reasoning can even be used to
derive an implementation from a specification.

Here is a simple example of equational reasoning.  Start with the set
of equations discussed above:

#+BEGIN_SRC Haskell
x = nand2 p q
p = xor2 a b
q = inv r
r = nor2 c d
#+END_SRC

\noindent
We can calculate the value of |x| using equational reasoning, in a
sequence of steps:

#+BEGIN_SRC Haskell
x = {definition of x}
nand2 p q
  = {substitute value of p}
nand2 (xor2 a b) q
  = {substitute value of q}
nand2 (xor2 a b) (inv r)
  = {substitute value of r}
nand2 (xor2 a b) (inv (nor2 c d))
#+END_SRC

\noindent
This calculation may not look very impressive, but later we will see
how equational reasoning can solve some quite challenging problems.


\section{General Boolean functions}

Suppose a Boolean function has $k$ inputs, and one output.

\begin{itemize}

\item Then there are $2^k$ lines in its truth table, and for every
line the output value could be either 0 or 1.

\item Therefore there are $2^{(2^k)}$ Boolean functions of $k$ inputs.

\end{itemize}

For small $k$, we can enumerate all of these functions.

\subsection{0 inputs}

With 0 inputs, there are $2^0=1$ lines in the truth table, and $2^1=2$
distinct truth tables (thus two functions).

\vspace{1cm}

\begin{center}
\hbox{
\begin{tabular}{||c||}
  \hline
    $f_0$ \\
  \hline
    0 \\
  \hline
\end{tabular}
\hspace{0.5cm}
\begin{tabular}{||c||}
  \hline
    $f_1$ \\
  \hline
    1 \\
  \hline
\end{tabular}
}
\end{center}

\vspace{0.25cm}

A 0-argument function is just a constant!  These really are truth
tables, although they are degenerate---compare them with the following
slides.

Use \textit{zero} and \textit{one} as the
two constants.

\subsection{1 input}

With 1 input $x$, there are $2^1=2$ lines in each truth table, and
$2^2=4$ functions (distinct truth tables).

\vspace{1cm}

\begin{center}
\hbox{
\begin{tabular}{||c||c||}
 \hline
   $x$ & $f_0\ x$ \\
 \hline
   0 & 0 \\
   1 &  0 \\
 \hline
\end{tabular}
\hspace{0.5cm}
\begin{tabular}{||c||c||}
 \hline
   $x$ &  $f_1\ x$ \\
 \hline
  0 & 0 \\
  1 & 1 \\
 \hline
\end{tabular}
\hspace{0.5cm}
\begin{tabular}{||c||c||}
 \hline
   $x$ &  $f_2\ x$ \\
 \hline
  0 & 1 \\
  1 & 0 \\
 \hline
\end{tabular}
\hspace{0.5cm}
\begin{tabular}{||c||c||}
 \hline
   $x$ &  $f_3\ x$ \\
 \hline
  0 & 1 \\
  1 & 1 \\
 \hline
\end{tabular}
}
\end{center}

Here $f_1$ is \textit{buf}, and $f_2$ is \textit{inv}.  The others
aren't particularly useful.

\subsection{2 inputs}

With 2 inputs, there are $2^2=4$ lines in the truth table, and
$2^{(2^2)}=16$ distinct truth tables (functions).

All 16 possible functions can be enumerated in a table (each column
specifies a distinct function):

{\footnotesize
  \begin{center}
    \begin{tabular}{||cc||cccccccccccccccc||}
      \hline
      $x$ & $y$
      &\fcnname{$f_0$}
      &\fcnname{$f_1$}
      &\fcnname{$f_2$}
      &\fcnname{$f_3$}
      &\fcnname{$f_4$}
      &\fcnname{$f_5$}
      &\fcnname{$f_6$}
      &\fcnname{$f_7$}
      &\fcnname{$f_8$}
      &\fcnname{$f_9$}
      &\fcnname{$f_{10}$}
      &\fcnname{$f_{11}$}
      &\fcnname{$f_{12}$}
      &\fcnname{$f_{13}$}
      &\fcnname{$f_{14}$}
      &\fcnname{$f_{15}$} \\
      \hline
      0    &0
      &0    &0    &0    &0    &0    &0    &0    &0
      &1    &1    &1    &1    &1    &1    &1    &1 \\
      0    &1
      &0    &0    &0    &0    &1    &1    &1    &1
      &0    &0    &0    &0    &1    &1    &1    &1 \\
      1    &0
      &0    &0    &1    &1    &0    &0    &1    &1
      &0    &0    &1    &1    &0    &0    &1    &1 \\
      1    &1
      &0    &1    &0    &1    &0    &1    &0    &1
      &0    &1    &0    &1    &0    &1    &0    &1 \\
      \hline
    \end{tabular}
  \end{center}
}

\subsection{Identifying the Common Functions}

{\footnotesize
  \begin{center}
    \begin{tabular}{||cc||cccccccccccccccc||}
      \hline
      $x$ & $y$
      &\fcnname{}
      &\fcnname{a\\n\\d\\2}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{x\\o\\r\\2}
      &\fcnname{o\\r\\2}
      &\fcnname{n\\o\\r\\2}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{}
      &\fcnname{\ \\n\\a\\n\\d\\2}
      &\fcnname{} \\
      \hline
      0    &0
      &0    &0    &0    &0    &0    &0    &0    &0
      &1    &1    &1    &1    &1    &1    &1    &1 \\
      0    &1
      &0    &0    &0    &0    &1    &1    &1    &1
      &0    &0    &0    &0    &1    &1    &1    &1 \\
      1    &0
      &0    &0    &1    &1    &0    &0    &1    &1
      &0    &0    &1    &1    &0    &0    &1    &1 \\
      1    &1
      &0    &1    &0    &1    &0    &1    &0    &1
      &0    &1    &0    &1    &0    &1    &0    &1 \\
      \hline
    \end{tabular}
  \end{center}
}

Possible Names for All Functions

{\footnotesize
  \begin{center}
    \begin{tabular}{||cc||cccccccccccccccc||}
      \hline
      $x$ & $y$
      &\fcnname{c\\o\\n\\0\\2}
      &\fcnname{a\\n\\d\\2}
      &\fcnname{j\\x\\2}
      &\fcnname{$x$\\$2$}
      &\fcnname{j\\y\\2}
      &\fcnname{$y$\\2}
      &\fcnname{x\\o\\r\\2}
      &\fcnname{o\\r\\2}
      &\fcnname{n\\o\\r\\2}
      &\fcnname{e\\q\\2}
      &\fcnname{i\\n\\v\\$y$\\2}
      &\fcnname{n\\j\\y\\2}
      &\fcnname{i\\n\\v\\$x$\\2}
      &\fcnname{n\\j\\x\\2}
      &\fcnname{\ \\n\\a\\n\\d\\2}
      &\fcnname{c\\o\\n\\1\\2} \\
      \hline
      0    &0
      &0    &0    &0    &0    &0    &0    &0    &0
      &1    &1    &1    &1    &1    &1    &1    &1 \\
      0    &1
      &0    &0    &0    &0    &1    &1    &1    &1
      &0    &0    &0    &0    &1    &1    &1    &1 \\
      1    &0
      &0    &0    &1    &1    &0    &0    &1    &1
      &0    &0    &1    &1    &0    &0    &1    &1 \\
      1    &1
      &0    &1    &0    &1    &0    &1    &0    &1
      &0    &1    &0    &1    &0    &1    &0    &1 \\
      \hline
    \end{tabular}
  \end{center}
}

\vspace{0.5cm}

Don't take these names too seriously---they aren't standard.  The
point is that all of these functions do exist.  What is important is
the existence and the value of a function, not its name.

(In this naming scheme, con means \emph{constant}; j means
\emph{just}, nj means \emph{not just}.)

** Typesetting notes

- C-c C-e h h org-html-export-to-html
