<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-09-29 Thu 13:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hydra User Guide</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="John T. O'Donnell" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../doc.css" />
<link rel="stylesheet" type="text/css" href="./docs/doc.css" />
<link rel="stylesheet" type="text/css" href="./docs/doc.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Hydra User Guide</h1>
version: 3.5.1
Copyright (c) 2022 John T. O'Donnell
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdb0526f">Introduction</a>
<ul>
<li><a href="#org4687588">Hardware description languages</a></li>
<li><a href="#org464d9e9">Modeling circuits as functions</a></li>
<li><a href="#org6170db3">Examples</a></li>
</ul>
</li>
<li><a href="#org359508c">README</a>
<ul>
<li><a href="#orge1be272">About Hydra</a></li>
<li><a href="#orge5c9740">Installation</a>
<ul>
<li><a href="#org64a734e">Haskell</a></li>
<li><a href="#org51eb96a">Hydra</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org21fa15f">Connecting components with signals</a>
<ul>
<li><a href="#orgafce46f">Components</a></li>
<li><a href="#org7e0fa83">Connecting a circuit to inputs</a></li>
<li><a href="#org0ce21ba">Anonymous signals</a></li>
<li><a href="#orge793750">Text and schematic</a></li>
<li><a href="#org327a927">Defining equation names a signal</a></li>
<li><a href="#org1dc2eb6">Constant signals</a></li>
<li><a href="#org4c9c5b2">Standard logic gates</a></li>
<li><a href="#org81ae949">Producing several outputs: halfAdd</a></li>
<li><a href="#orgf9d2b69">Example: multiplexer</a></li>
</ul>
</li>
<li><a href="#org25db107">Defining new circuits</a>
<ul>
<li><a href="#org47b4352">Circuit defining equation</a></li>
<li><a href="#orgd81eff3">Black boxes with internal signals</a></li>
<li><a href="#org0426bc8">Feedback</a></li>
</ul>
</li>
<li><a href="#orgcf2551c">Modules and files</a>
<ul>
<li><a href="#orgc9e847b">The circuit specification</a></li>
<li><a href="#org331d5b5">Modules and files</a></li>
</ul>
</li>
<li><a href="#org79c29e0">Circuit simulation</a>
<ul>
<li><a href="#orga239e57">The simulation driver</a></li>
<li><a href="#org19502b1">Running the circuit simulation</a></li>
<li><a href="#orgeb02fa0">Batch and interactive simulation</a></li>
</ul>
</li>
<li><a href="#orgc5285dd">Syntax</a>
<ul>
<li><a href="#org31f0fcd">Modules</a></li>
<li><a href="#org5b00e5e">Comments</a></li>
<li><a href="#org87fac5e">Names</a></li>
<li><a href="#orgd6541eb">Scope</a></li>
<li><a href="#orgb755bf4">Signal expressions</a></li>
<li><a href="#org74fa223">Indentation</a></li>
</ul>
</li>
<li><a href="#org57f253b">Interfaces and types</a>
<ul>
<li><a href="#org393f6e0">Interface</a></li>
<li><a href="#orgf938005">Interfaces and Types</a></li>
<li><a href="#org37deca1">Signal types</a></li>
<li><a href="#orgdbb8b48">Inputs and outputs</a></li>
<li><a href="#org9a4319d">Circuit type</a></li>
<li><a href="#org3698de7">Signal classes</a>
<ul>
<li><a href="#orgcc7e0df">Combinational signals: Bit a</a></li>
<li><a href="#org0d2883f">Clocked signals: CBit a</a></li>
</ul>
</li>
<li><a href="#org64458f4">Multiple outputs</a></li>
<li><a href="#org6fead11">Form of a type declaration</a></li>
<li><a href="#org44adf56">Type declaration is optional</a></li>
<li><a href="#org2169661">Signal types and circuit semantics</a></li>
<li><a href="#org805cdc5">The signal class constraint</a></li>
<li><a href="#org3e3e63e">Naming conventions</a></li>
<li><a href="#org451b877">The usual cases</a></li>
<li><a href="#org1ef13c5">Input and output types</a></li>
</ul>
</li>
<li><a href="#org6522b94">Containers</a>
<ul>
<li><a href="#orgdd81f8c">Tuples</a></li>
<li><a href="#org410201d">Circuits with several outputs</a></li>
<li><a href="#orgb6c9524">Words</a>
<ul>
<li><a href="#orgff9138c">Word size</a></li>
<li><a href="#orgc0414d4">Constructing words</a></li>
<li><a href="#org62a5575">Deconstructing words</a></li>
</ul>
</li>
<li><a href="#org360f572">Nested containers</a></li>
<li><a href="#org983f882">Containers</a>
<ul>
<li><a href="#org9ecfa98">Tuples</a></li>
<li><a href="#org47aee01">Words</a></li>
<li><a href="#org9e4c237">A circuit with words and internal signals</a></li>
<li><a href="#org4b35e0e">Nested clusters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdb92400">Simulation drivers with format and state</a>
<ul>
<li><a href="#orgb61d12f">Automatic output and formatted output</a></li>
<li><a href="#orgfde7792">Feedback and changing state: BSR4</a></li>
</ul>
</li>
<li><a href="#org52f5114">Records with named fields</a>
<ul>
<li><a href="#org8f9b643">Defining a group of signals</a></li>
<li><a href="#org8c4c3f2">Defining a group of signals</a></li>
</ul>
</li>
<li><a href="#org4389d4e">Circuit generators</a>
<ul>
<li><a href="#orgb8effa3">Inverting all the bits in a word</a></li>
<li><a href="#orgdbc2394">How does a circuit generator work?</a></li>
<li><a href="#orgda7be3d">Calculating the and/or of many bits</a></li>
<li><a href="#orgdb87706">4-bit ripple carry adder</a></li>
<li><a href="#orga4f60b9">Ripple carry adder schematic</a></li>
<li><a href="#org36a6b82">Generic $n$-bit ripple carry adder</a></li>
<li><a href="#org1c94ddb">``Times''</a></li>
<li><a href="#orgb35d673">Circuit generators</a>
<ul>
<li><a href="#orgf3d546c">Map</a></li>
<li><a href="#org5f372a4">Fold</a></li>
<li><a href="#org759d9a5">Circuit generators 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org68036f3">Combinational simulation</a></li>
<li><a href="#org97c8a83">Synchronous sequential simulation</a></li>
<li><a href="#orgb5c60f0">Standard library for bits</a>
<ul>
<li><a href="#org4f67c6c">Constant signals</a></li>
<li><a href="#orgbcc2902">Logic gates</a></li>
<li><a href="#org39d30e6">Replicating a signal</a></li>
<li><a href="#org0a26f3a">Multiplexers and demultiplexers</a></li>
<li><a href="#orga991f7c">Bit addition</a></li>
<li><a href="#orga413cd0">Flip flops and registers</a></li>
</ul>
</li>
<li><a href="#org99fdbb5">Standard library for words</a>
<ul>
<li><a href="#org0a004e8">Replicating a bit</a></li>
<li><a href="#orgd6dce8b">Rearranging bits in a word</a>
<ul>
<li><a href="#orge7f50c5">Combinational shifting</a></li>
<li><a href="#orgafe8cf7">Bit slice representation</a></li>
</ul>
</li>
<li><a href="#org3b70869">Logic on words</a></li>
<li><a href="#org301e5a6">Conditionals and addresses</a>
<ul>
<li><a href="#org10cd21c">Multiplexers</a></li>
<li><a href="#orgc5fcf4e">Demultiplexers</a></li>
</ul>
</li>
<li><a href="#orga5d1217">Arithmetic</a>
<ul>
<li><a href="#orgaef5933">Binary addition</a></li>
</ul>
</li>
<li><a href="#org7834291">Registers</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgdb0526f" class="outline-2">
<h2 id="orgdb0526f">Introduction</h2>
<div class="outline-text-2" id="text-orgdb0526f">
<p>
Hydra is a computer hardware description language (CHDL or HDL) that
enables you to design, analyse, and simulate digital circuits.  It
focuses on logic design, not on the physics of electronic components.
It is concerned with how to connect logic gates into a system, but not
with the electronic characteristics of an individual transistor.
Hydra supports synchronous circuits, where a clock keeps all the flip
flops synchronised with each other.
</p>

<p>
This is free and open source software; see README and LICENSE for
details.  To use the system you need the ghc compiler suite for
Haskell, which is also free software.  The README section explains how
to download, install, and run the system.
</p>

<p>
The language provides facilities that help to design complex circuits
as well as small ones. The notation is concise and readable.  Large
circuits can be described using circuit generators, which remove most
of the repetition in a circuit description without losing any of the
detail.  New circuit generators can be defined: you aren't limited to
the ones provided in the standard libraries.
</p>

<p>
Hydra has a semantic foundation for circuits that supports the use of
equational reasoning.  This is a formal method that can be used to
transform a circuit to make it more efficient according to a cost
model, as well as to prove that an implementation satisfies a
specification.  In some cases, it is possible to start with an
abstract specification of the desired behavior and to derive
mathematically a circuit that implements it.
</p>

<p>
Hydra is not suitable for all circuit design problems.  It assumes
that all the values on wires are digital, rather than continuously
varying analogue voltages, and it requires sequential circuits to be
synchronous, using one global clock.
</p>
</div>

<div id="outline-container-org4687588" class="outline-3">
<h3 id="org4687588">Hardware description languages</h3>
<div class="outline-text-3" id="text-org4687588">
<p>
To design a circuit, and to do anything useful with it, we need a way
to describe it.  The description can take two forms.  A
<i>specification</i> is a clear statement of what the system is intended to
do, while an <i>implementation</i> shows how the primitive components can
be connected together into a circuit that satisfies the specification.
The specification of an adder says that the output is the sum of the
inputs; the implementation of an adder says that a specific collection
of logic gates connected by wires in a specific way will output the
specified result.  An implementation of hardware is a circuit design.
Both the specification and implementation need to be clear, complete,
and precise.
</p>

<p>
An implementation (i.e. a circuit design) may take the form of a
<i>diagram</i> or a piece of <i>text</i>.  For digital circuits, a pictorial
specification is called a <i>schematic diagram</i>, while a textual
specification uses a <i>hardware description language</i>.  Both forms can
also be used for software: a textual specification of a software
algorithm uses a programming language, but there are also visual
programming languages that use diagrams to describe software
algorithms.
</p>

<p>
A schematic diagram is an abstract picture of a circuit.  It shows the
components and how they are connected with wires, but it doesn't
directly describe the circuit's function.  A schematic diagram implies
some geometric information, such as the relative placement of
components, and this geometry may be used in fabricating the circuit.
</p>

<p>
An alternative approach is to use a computer hardware description
language (CHDL or HDL).  A circuit specification using an HDL is a
text document, so it looks superficially like a computer program, but
it describes hardware rather than software.  Most hardware description
languages are based on existing programming languages intended for
software, and they model circuits using the paradigms of programming.
</p>

<p>
An algorithm can be realised using either software, hardware, or a
combination of both.  Algorithms may be specified abstractly, without
referring to either hardware or software.  A common misconception is
to think "if it's a picture, then it must be hardware; if it's text it
must be software".  That's doubly wrong: visual programming languages
use pictures to describe software, and hardware description languages
like Hydra use text to describe hardware.
</p>

<p>
Schematic diagrams and hardware description languages each have their
merits.  A diagram may be easier for a beginner to understand, and
it's more obvious that a schematic diagram describes hardware and
isn't just a computer program.  However, schematics for large and
complex circuits are cumbersome, while hardware description languages
scale up well.  Diagrams just sit there inertly on paper, and don't do
anything, but CHDLs support useful software tools for simulation,
fabrication, and testing.
</p>
</div>
</div>

<div id="outline-container-org464d9e9" class="outline-3">
<h3 id="org464d9e9">Modeling circuits as functions</h3>
<div class="outline-text-3" id="text-org464d9e9">
<p>
Some HDLs are based on imperative programming languages, using the
assignment statement to model a state change in a circuit.  In
contrast, Hydra is based on pure functional programming, and it models
a circuit as a function that takes inputs and produces outputs. This
is natural, because both a circuit and a function act as a black box
that takes some inputs and produces some outputs.  The underlying
model &#x2013; circuits as functions rather than state changes as
assignments &#x2013; is the fundamental difference between Hydra and
imperative HDLs.
</p>

<p>
Hydra is an example of an <i>embedded domain-specific language</i> (DSL or
EDSL).  A domain-specific language is a language intended for one
specific application domain, not for general purpose programming.
Hydra is suitable specifically for expressing algorithms as digital
circuits, but it isn't a general purpose programming language.  It is
implemented by <i>embedding</i> in Haskell, a general purpose functional
language.  This means that Hydra doesn't have a separate compiler;
instead, its implementation consists of a library of Haskell
modules. A circuit specification written in Hydra is compiled by the
Haskell compiler and linked with the Hydra library.  However, it is
best to think of Hydra as a distinct language: designing a circuit is
not the same as writing a program in Haskell, and some Haskell
programs don't correspond to circuits.
</p>
</div>
</div>

<div id="outline-container-org6170db3" class="outline-3">
<h3 id="org6170db3">Examples</h3>
<div class="outline-text-3" id="text-org6170db3">
<p>
The following sections explain the language and show how to write
circuit specifications.  A collection of examples can be found in
<code>hydra/examples</code>.  If you would like to see a simple circuit before
going on, look at <code>examples/simple/SimpleCirc.hs</code>.  To simulate it,
enter these commands:
</p>

<pre class="example" id="org96c9ea9">
cd examples/simple
ghc -e main SimpleCircRun
</pre>
</div>
</div>
</div>


<div id="outline-container-org359508c" class="outline-2">
<h2 id="org359508c">README</h2>
<div class="outline-text-2" id="text-org359508c">
<h1>Hydra README</h1>
</div>

<div id="outline-container-orge1be272" class="outline-3">
<h3 id="orge1be272">About Hydra</h3>
<div class="outline-text-3" id="text-orge1be272">
version: 3.5.1
Copyright (c) 2022 John T. O'Donnell

<p>
Hydra is a functional computer hardware description language for
specifying the structure and behavior of digital circuits. It supports
several levels of abstraction, including logic gates, register
transfer level, datapath and control, and processors. There are tools
for simulating circuits, generating netlists, and emulating
instruction set architectures. It is an embedded domain specific
language implemented using Haskell.
</p>

<ul class="org-ul">
<li>The <i>User Guide</i> is available online at
<a href="https://jtod.github.io/home/Hydra/UserGuide/HydraUserGuide.html">https://jtod.github.io/home/Hydra/UserGuide/HydraUserGuide.html</a>.
The Guide is in development, and this online link may give a newer
version than the one in the installation directory.</li>
<li>The User Guide is also available in the installation directory
<a href="HydraUserGuide.html">HydraUserGuide.html</a></li>
<li>The <i>API reference</i> gives types of the exported definitions.  If you
build using cabal, it will be in the the <code>dist-newstyle</code> directory.
The path depends on software versions, but may be something like
this:
<a href="../../dist-newstyle/build/x86_64-windows/ghc-9.2.3/hydra-3.4.16/doc/html/hydra/index.html">../../dist-newstyle/build/x86_64-windows/ghc-9.2.3/hydra-3.4.16/doc/html/hydra/index.html</a>.
If you install using cabal, it should also be placed in the standard
location for Haskell API references.</li>
</ul>

<p>
This is free and open source software released under the GPL-3
license.
</p>

<ul class="org-ul">
<li>Author: John T. O'Donnell, School of Computing Science, University
of Glasgow</li>
<li>Copyright (c) 2022 John T. O'Donnell</li>
<li>Author's home page: <a href="https://jtod.github.io/index.html">https://jtod.github.io/index.html</a></li>
<li>License: This software is free and open source, released under the
GPL-3 license.  See LICENSE.txt.</li>
<li>Source code repository: <a href="https://github.com/jtod/Hydra">https://github.com/jtod/Hydra</a></li>
<li>Version: see Hydra.cabal</li>
</ul>
</div>
</div>

<div id="outline-container-orge5c9740" class="outline-3">
<h3 id="orge5c9740">Installation</h3>
<div class="outline-text-3" id="text-orge5c9740">
<p>
Hydra runs in a shell using a command line interface.  Any shell can
be used; the examples use the bash shell.
</p>
</div>

<div id="outline-container-org64a734e" class="outline-4">
<h4 id="org64a734e">Haskell</h4>
<div class="outline-text-4" id="text-org64a734e">
<p>
Hydra requires the ghc toolset for Haskell, including ghc and cabal.
Haskell installers for Macintosh, Windows, and Linux are available at
<a href="https://www.haskell.org/ghcup/">https://www.haskell.org/ghcup/</a>.
</p>

<p>
For Windows, an alternative way to install Haskell is to use
chocolatey; see <a href="https://hub.zhox.com/posts/introducing-haskell-dev/">https://hub.zhox.com/posts/introducing-haskell-dev/</a>.
If you have chocolatey installed, you can use it to install Haskell
easily.  Run these commands in Windows PowerShell with administrator
privileges:
</p>

<pre class="example" id="orgb020645">
choco install ghc --force -y
choco install cabal --force -y
</pre>

<ul class="org-ul">
<li><code>-y</code> tells choco to answer with y automatically when it needs
permission to do something.  Without the -y, it doesn't actually ask
permission and the whole installation fails.</li>
<li><code>--force</code> shouldn't be necessary but seems to be needed if
installing after a failed installation attempt.</li>
</ul>

<p>
<i>Verify that Haskell is working</i>
</p>

<pre class="example" id="org8168bcf">
$ ghc --version
The Glorious Glasgow Haskell Compilation System, version 9.2.3
$ cabal --version
cabal-install version 3.6.2.0
compiled using version 3.6.2.0 of the Cabal library
</pre>

<p>
<i>In case of difficulty</i>
</p>

<p>
If you have a previous installation of ghc, and a new installation
fails, the following might work:
</p>

<pre class="example" id="orge9373a5">
choco upgrade ghc cabal -y
</pre>
</div>
</div>

<div id="outline-container-org51eb96a" class="outline-4">
<h4 id="org51eb96a">Hydra</h4>
<div class="outline-text-4" id="text-org51eb96a">
<p>
The Hydra source code is available at <a href="https://github.com/jtod/Hydra">https://github.com/jtod/Hydra</a>.
See the Releases section on the right side of the page and click on
the latest release.  Download the source code file (in the Assets
section), which is available in both <code>zip</code> and <code>.tar.gz</code> format.  The
installation file is Hydra-i.j.k.zip (or .tgz), where i.j.k is the
version number.  Put the file somewhere in your user workspace and
unpack it, using the correct version number for your download:
</p>

<ul class="org-ul">
<li>On Linux: tar -xzf Hydra-3.5.1.tar.gz</li>
<li>On Windows use zip, 7zip or tar</li>
</ul>

<p>
This will create a directory that contains documentation (<code>docs</code>
directory and <code>examples</code> directory), the source code (<code>src</code>
directory), and build tools.  Install using these commands (using the
right version number for Hydra):
</p>

<pre class="example" id="org10c6495">
cd Hydra-3.5.1
cabal install --lib
cabal haddock
</pre>

<p>
<i>Verify that Hydra is working</i>
</p>

<p>
The following commands should simulate a 4-bit word adder for several
clock cycles, with different inputs during each cycle.
</p>

<pre class="example" id="orgb885c50">
$ cd examples/adder
$ ghc -e main Add4Run
</pre>

<p>
<i>In case of difficulty</i>
</p>

<p>
See the user guides for ghc and cabal for more information.  The
<code>ghc-pkg list</code> command shows the installed packages.
</p>

<p>
Sometimes an installation may fail if there was a previous
installation.  If this happens, find the ghc environment default file,
which is located at a path similar to the following (with your
username and the right version numbers):
</p>

<p>
Linux:
</p>
<pre class="example" id="org5cd5f19">
~/.ghc/x86_64-linux-8.8.3/environments/default 
</pre>

<p>
Windows:
</p>
<pre class="example" id="orgab5e27e">
C:/Users/username/AppData/Roaming/ghc/x86_64-mingw32-9.2.3/environments/default
</pre>

<p>
Open this file in a text editor and find the line containing an entry
for hydra, which should look something like this:
</p>

<pre class="example" id="org64bdc57">
package-id hydra-3.4.5-VeryLongHashKey
</pre>

<p>
Delete the lines for hydra, save the <code>default</code> file, and try the
<code>cabal install --lib</code> command again.
</p>

<p>
<i>Alternative: using ghci</i>
</p>

<p>
Instead of using the batch command <code>ghc -e main Add4Run</code> (where
Add4Run is the name of a simulation driver), an alternative is to use
the interactive Haskell interpreter:
</p>

<pre class="example" id="org06e9e06">
$ ghci
ghci&gt; :load Add4Run
ghci&gt; :main
ghci&gt; :quit
</pre>

<p>
The ghci interpreter offers a number of debugging and tracing tools.
See the GHC User Guide for details.
</p>

<p>
If you get a message saying that there are "hidden packages", copy the
following into a file named <code>.ghci</code>
</p>
<pre class="example" id="org38200b2">
:set -package mtl
:set -package parsec
:set -package ansi-terminal
</pre>

<p>
<i>Alternative: using cabal</i>
</p>

<p>
You can turn a directory with a circuit and simulation driver into a
cabal package by defining some metadata files.  Once this is done, you
can then execute the driver using the command <code>cabal run driver</code>,
where <code>driver</code> is replaced by the actual name of the simulation
driver.  One advantage of this method is that you can put command line
arguments on the <code>cabal run</code> command, which you cannot do with the
<code>ghc -e main</code>.  See the M1 processor circuit directory for an example.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org21fa15f" class="outline-2">
<h2 id="org21fa15f">Connecting components with signals</h2>
<div class="outline-text-2" id="text-org21fa15f">
<p>
A data value in a circuit is called a <b>signal</b>.  A signal is carried
by a wire, and it transmits information from one component to another.
In logic design we don't usually care about the physical
characteristics of a wire, although these can be important at the
lower levels of chip design.  Therefore we will usually refer to
signals rather than wires.
</p>

<p>
The information carried by a signal may be represented as an
individual bit or a cluster comprising several bits.  We can also
describe circuits at a higher level, where signals represent natural
numbers, integers, or other data types.
</p>

<p>
A bit (binary digit) can have one of two distinct values.  Several
names are commonly used for these values, including 0/1, Low/High,
False/True, and F/T.  In real hardware a bit signal is represented by
a voltage, but the precise voltage value is unimportant at the level
of logic design.  The particular names chosen for the two bit values
are also unimportant, although they can affect the readability of a
table showing the behavior of a circuit.
</p>

<p>
When Hydra prints out the values of bit signals, it will normally use
0 and 1, but you can tell it to use False and True, or any other names
you prefer.  One advantage of 0/1 is that they are consistent with
treating a bit as a binary digit (False/True suggest treating a bit as
a Boolean).  Another advantage of 0 and 1 is that they take up only
one character and they look different.  Try reading a table showing
thousands of F and T characters &#x2013; they can be hard to tell apart!.
</p>
</div>

<div id="outline-container-orgafce46f" class="outline-3">
<h3 id="orgafce46f">Components</h3>
<div class="outline-text-3" id="text-orgafce46f">
<p>
The simplest circuits are primitive components.  There are two kinds:
combinational components (called logic gates) and sequential
components (called latches or flip flops).  Every circuit is either a
primitive component, or a number of circuits connected by wires.
</p>

<p>
The simplest logic gate is the inverter, which takes one input and
produces one output.  The inverter outputs 0 if its input is 1, and
outputs 1 if its input is 0.  The name of the inverter is <code>inv</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Gate</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">buf a</td>
<td class="org-left">buffer</td>
</tr>

<tr>
<td class="org-left">inv a</td>
<td class="org-left">inverter</td>
</tr>

<tr>
<td class="org-left">and2 a b</td>
<td class="org-left">2-input and gate</td>
</tr>

<tr>
<td class="org-left">and3 a b c</td>
<td class="org-left">3-input and gate</td>
</tr>

<tr>
<td class="org-left">and4 a b c d</td>
<td class="org-left">4-input and gate</td>
</tr>

<tr>
<td class="org-left">or2 a b</td>
<td class="org-left">2-input or gate</td>
</tr>

<tr>
<td class="org-left">or3 a b c</td>
<td class="org-left">3-input or gate</td>
</tr>

<tr>
<td class="org-left">or4 a b c d</td>
<td class="org-left">4-input or gate</td>
</tr>

<tr>
<td class="org-left">xor2 a b</td>
<td class="org-left">2-input xor gate</td>
</tr>

<tr>
<td class="org-left">xor3 a b c</td>
<td class="org-left">3-input xor gate</td>
</tr>

<tr>
<td class="org-left">xor4 a b c d</td>
<td class="org-left">4-input xor gate</td>
</tr>

<tr>
<td class="org-left">nand2 a b</td>
<td class="org-left">2-input nand gate</td>
</tr>

<tr>
<td class="org-left">nand3 a b c</td>
<td class="org-left">3-input nand gate</td>
</tr>

<tr>
<td class="org-left">nand4 a b c d</td>
<td class="org-left">4-input nand gate</td>
</tr>

<tr>
<td class="org-left">nor2 a b</td>
<td class="org-left">2-input nor gate</td>
</tr>

<tr>
<td class="org-left">nor3 a b c</td>
<td class="org-left">3-input nor gate</td>
</tr>

<tr>
<td class="org-left">nor4 a b c d</td>
<td class="org-left">4-input nor gate</td>
</tr>

<tr>
<td class="org-left">xnor2 a b</td>
<td class="org-left">2-input xnor gate</td>
</tr>

<tr>
<td class="org-left">xnor3 a b c</td>
<td class="org-left">3-input xnor gate</td>
</tr>

<tr>
<td class="org-left">xnor4 a b c d</td>
<td class="org-left">4-input xnor gate</td>
</tr>
</tbody>
</table>

<p>
The buffer produces an output that is the same as the input; it is the
identify function.  The inverter outputs 0 if its input is 1, and
outputs 1 if its input is 0.
</p>

<p>
Many of the logical operations can be performed on any number of
inputs.  For example, there is the logical conjunction (<code>and</code>) of two,
three, or four inputs.  These correspond to distinct logic gates: the
<code>and2</code> gate has two input ports and there is no way to connect three
inputs to it.  Therefore Hydra doesn't have an <code>and</code> gate; it has
distinct <code>and2</code>, <code>and3</code>, <code>and4</code> gates.  This doesn't go on
indefinitely; Hydra does not define the <code>and5</code> gate or the <code>and73</code>
to use <code>andw</code>.
</p>

<p>
Most of these logic gates are provided for convenience; only a few of
them are necessary.  For example, you can replace <code>and3 a b c</code> by
<code>and2 a (and2 b c)</code>.  However, logic gates with several inputs can be
fabricated on chips, they are slightly more efficient, and most
importantly, it's more readable to use <code>and3</code> rather than two <code>and2</code>
gates.
</p>
</div>
</div>

<div id="outline-container-org7e0fa83" class="outline-3">
<h3 id="org7e0fa83">Connecting a circuit to inputs</h3>
<div class="outline-text-3" id="text-org7e0fa83">
<p>
Suppose we have two signals named <code>x</code> and <code>y</code>, and want to connect
them to the inputs of an <code>or2</code> gate.  This is done by writing the name
of the component, followed by the names of the input signals:
</p>

<pre class="example" id="org7160116">
or2 x y
</pre>

<p>
The value of this expression is the signal which is the output of the
<code>or2</code> gate.  Such an expression is called an <b>application</b> because the
component is applied to its input signals.
</p>

<p>
Each circuit takes a specific number of inputs, and an application
using that circuit must supply the corresponding number of input
signals.  Here are several applications of logic gates, each with the
right number of inputs:
</p>

<pre class="example" id="org9fc4411">
inv x
and2 a one
xor3 p q r
nor4 a zero c d
</pre>
</div>
</div>

<div id="outline-container-org0ce21ba" class="outline-3">
<h3 id="org0ce21ba">Anonymous signals</h3>
<div class="outline-text-3" id="text-org0ce21ba">
<p>
A signal may be given a name, such as <code>x</code> or <code>y</code>, although this is
optional.  You can also refer to a signal using an application of a
component to its inputs, such as <code>inv x</code>; the output of the inverter
is an <i>anonymous</i> signal as it has no name.
</p>

<p>
An anonymous signal is described by an expression, and that expression
is written with several tokens.  When you use it as an input to a
circuit, this expression must be enclosed by parentheses, to turn it
into a single entity.  For example, suppose we have an inverter whose
input is <code>x</code>, and we want to connect the inverter's output to the
first input of an <code>and2</code> gate.  The second input to the <code>and2</code> gate
should be <code>y</code>.  Here is the correct way to write it:
</p>

<pre class="example" id="orgbc4b680">
and2 (inv x) y
</pre>

<p>
There are two expressions following <code>and2</code>, denoting its two inputs.
The first expression is <code>(inv x)</code> and it denotes an anonymous signal
(the output of the inverter).  The second expression is <code>y</code>, which of
course is a named signal.  The following notation would be wrong:
</p>

<pre class="example" id="orga93cac6">
and2 inv x y   -- Wrong!
</pre>

<p>
This says that the <code>and2</code> gate is being given three inputs, and the
first input (<code>inv</code>) isn't even a signal.
</p>

<p>
Parentheses are used for grouping, just as in mathematics.  You don't
need to use parentheses just to specify the arguments to a function
(that is, the inputs to a circuit).  Some programming languages
requires lots of punctuation to indicate function application, but
Hydra doesn't do that:
</p>

<pre class="example" id="org04360ac">
inv (x)                     -- Wrong!
and2 (a,b)                  -- Wrong!
nand3 (x, and2 (p,q), z);   -- Wrong!
</pre>

<p>
In Hydra (as in Haskell) you don't need the extra parentheses and
commas, and they will lead to error messages.  Use parentheses only
when they are necessary to get the right grouping:
</p>

<pre class="example" id="orgc8a5bc3">
inv x
and2 a b
nand3 x (and2 p q) z
</pre>
</div>
</div>

<div id="outline-container-orge793750" class="outline-3">
<h3 id="orge793750">Text and schematic</h3>
<div class="outline-text-3" id="text-orge793750">
<p>
It can be helpful to give both a schematic diagram and a textual
specification for a circuit.  Each form of description provides
insight, and having both together is often worthwhile.
</p>

<p>
It's important to check that the two descriptions of the circuit are
consistent with each other.  To do this,
</p>
<ul class="org-ul">
<li>Check that every box in the diagram corresponds to a circuit
(function) in the text</li>
<li>Check that each wire in the diagram corresponds to a signal in the
text.</li>
<li>The wire should be connected to exactly one component output, which
places a logic value on the wire.</li>
<li>The wire may be connected to one or more component inputs.</li>
</ul>
</div>
</div>

<div id="outline-container-org327a927" class="outline-3">
<h3 id="org327a927">Defining equation names a signal</h3>
<div class="outline-text-3" id="text-org327a927">
<p>
Sometimes it's useful to give a name to a signal, rather than using it
anonymously.  A named signal can be used as an input to several
different components, but an anonymous signal cannot.  Names can also
make it easier to explain the circuit, and well chosen names help
document the purpose of a signal.
</p>

<p>
A signal can be named using an equation.  The left hand side of the
equation is the name, and the right hand side is an expression that
defines the signal.  The following equation says that the output of
the <code>and3</code> gate has the name <code>x</code>.
</p>

<pre class="example" id="org94ae374">
x = and3 a (inv b) c
</pre>

<p>
With that equation, <code>x</code> can be used as the input to any component:
</p>

<pre class="example" id="org93966ba">
x = and3 a (inv b) c
y = or2 a x
</pre>

<p>
A <i>defining equation</i> defines the name on the left hand side to have
the same value as the signal expression on the right hand side. The
order of equations is immaterial, just as with equations in
mathematics.  It's fine to use a signal name before the equation that
defines it.  The example above could be written like this, and it
would specify exactly the same circuit:
</p>

<pre class="example" id="orgf8f4f15">
y = or2 a x
x = and3 a (inv b) c
</pre>

<p>
However, in mathematics you can swap the left and right hand sides,
but a Hydra equation <i>must</i> have the name on the left side and its
value on the right side.  It's called a <i>defining equation</i> because it
defines the name on the left hand side to have the value of the right
hand side.  If you reverse the two sides, you'll get an error:
</p>

<pre class="example" id="org2b61e6a">
a = inv b      -- Correct, defines the name a
inv c = d      -- Error, need a name (not application) on left
</pre>

<p>
Later we will see a technique called <i>equational reasoning</i>, which is
useful for analysing circuits.  This uses equations with a more
general form.  But to give a name to a signal, you need to use a
<i>defining equation</i>, where the left hand side is always a signal name.
</p>

<p>
It's a good idea to write the equations in an order that makes the
circuit more readable.  If most of the signals are defined before they
are used, a person reading the text will get a bottom-up
understanding.  Using signals before they are defined gives a top-down
presentation.  Both styles are useful, and we will see examples of
both.
</p>

<p>
Sometimes the choice between anonymous and named signals is just a
matter of style.  Here is a signal defined using three anonymous
signals:
</p>

<pre class="example" id="org500b6c4">
x = nand2 (xor2 a b) (inv (nor2 c d))
</pre>

<p>
This can be rewritten so as to give every signal an explicit name, by
introducing additional equations:
</p>

<pre class="example" id="orgfcab154">
x = nand2 p q
p = xor2 a b
q = inv r
r = nor2 c d
</pre>
</div>
</div>

<div id="outline-container-org1dc2eb6" class="outline-3">
<h3 id="org1dc2eb6">Constant signals</h3>
<div class="outline-text-3" id="text-org1dc2eb6">
<p>
A constant signal always carries the same value: either it is always
0, or always 1.  The names of these two constant signals are written
as <code>zero</code> and <code>one</code>.  Names in Hydra always begin with a lower case
letter, never with a digit.  Don't use 0/1, or T/F, or True/False in a
circuit specification; those notations have other meanings and will
lead to bizarre error messages.
</p>

<pre class="example" id="org740154f">
x = and2 a one   -- Correct, x is same as a
y = and2 a 1     -- Error, 1 isn't a signal
</pre>
</div>
</div>

<div id="outline-container-org4c9c5b2" class="outline-3">
<h3 id="org4c9c5b2">Standard logic gates</h3>
<div class="outline-text-3" id="text-org4c9c5b2">
<p>
To design a new circuit, you need to take a set of existing circuits
and connect them with signals.  A logic gate is a primitive
combinational component (combinational means that the output depends
on the current values of the inputs).  Some of the most commonly used
</p>

<p>
There are several libraries of
existing circuits that you can start with, and you can also define
libraries of your own circuits for further use.  The Hydra libraries
provide as primitives the standard logic gates, summarised in the
following table.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Gate</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">buf a</td>
<td class="org-left">buffer</td>
</tr>

<tr>
<td class="org-left">inv a</td>
<td class="org-left">inverter</td>
</tr>

<tr>
<td class="org-left">and2 a b</td>
<td class="org-left">2-input and gate</td>
</tr>

<tr>
<td class="org-left">and3 a b c</td>
<td class="org-left">3-input and gate</td>
</tr>

<tr>
<td class="org-left">and4 a b c d</td>
<td class="org-left">4-input and gate</td>
</tr>

<tr>
<td class="org-left">or2 a b</td>
<td class="org-left">2-input or gate</td>
</tr>

<tr>
<td class="org-left">or3 a b c</td>
<td class="org-left">3-input or gate</td>
</tr>

<tr>
<td class="org-left">or4 a b c d</td>
<td class="org-left">4-input or gate</td>
</tr>

<tr>
<td class="org-left">xor2 a b</td>
<td class="org-left">2-input xor gate</td>
</tr>

<tr>
<td class="org-left">xor3 a b c</td>
<td class="org-left">3-input xor gate</td>
</tr>

<tr>
<td class="org-left">xor4 a b c d</td>
<td class="org-left">4-input xor gate</td>
</tr>

<tr>
<td class="org-left">nand2 a b</td>
<td class="org-left">2-input nand gate</td>
</tr>

<tr>
<td class="org-left">nand3 a b c</td>
<td class="org-left">3-input nand gate</td>
</tr>

<tr>
<td class="org-left">nand4 a b c d</td>
<td class="org-left">4-input nand gate</td>
</tr>

<tr>
<td class="org-left">nor2 a b</td>
<td class="org-left">2-input nor gate</td>
</tr>

<tr>
<td class="org-left">nor3 a b c</td>
<td class="org-left">3-input nor gate</td>
</tr>

<tr>
<td class="org-left">nor4 a b c d</td>
<td class="org-left">4-input nor gate</td>
</tr>

<tr>
<td class="org-left">xnor2 a b</td>
<td class="org-left">2-input xnor gate</td>
</tr>

<tr>
<td class="org-left">xnor3 a b c</td>
<td class="org-left">3-input xnor gate</td>
</tr>

<tr>
<td class="org-left">xnor4 a b c d</td>
<td class="org-left">4-input xnor gate</td>
</tr>
</tbody>
</table>

<p>
The buffer produces an output that is the same as the input; it is the
identify function.
</p>

<p>
Most of these logic gates are provided for convenience; only a few of
them are necessary.  For example, you can replace <code>and3 a b c</code> by
<code>and2 a (and2 b c)</code>.  However, logic gates with several inputs can be
fabricated on chips, they are slightly more efficient, and most
importantly, it's more readable to use <code>and3</code> rather than two <code>and2</code>
gates.
</p>
</div>
</div>

<div id="outline-container-org81ae949" class="outline-3">
<h3 id="org81ae949">Producing several outputs: halfAdd</h3>
<div class="outline-text-3" id="text-org81ae949">
<p>
The circuits we have looked at so far have just one output.  We need a
way to allow circuits to produce any number of outputs.
</p>

<p>
Files: <b>examples/adder/HalfAdd.hs</b> and <b>examples/adder/HalfAddRun.hs</b>
</p>

<p>
A half adder circuit takes two inputs <b>x</b> and <b>y</b>, and produces a pair
of outputs, the carry output and the sum output.  The carry is the
logical <b>and</b> of <b>x</b> and <b>y</b>, while the sum is their exclusive <b>or</b>.
Here is the circuit specification (file <b>HalfAdd.hs</b>):
</p>

<p>
The module statement gives a name to this module, and the import
statement brings in the essential Hydra library definitions.  The
circuit definition is a one-line equation which says <b>halfAdd</b> is a
circuit, gives names <b>x</b> and <b>y</b> to its inputs, and calculates the
outputs using <b>and2</b> and <b>xor2</b> logic gates.
</p>

<p>
To see the circuit working, we can simulate it.  This requires
three things, all provided in <b>HalfAddRun.hs</b>:
</p>

<ul class="org-ul">
<li>Suitable test data, expressed as a list of <b>[x,y]</b> inputs</li>

<li>A [Simulation driver](#simulation-drivers), which converts between
human readable input and output and the internal signal
representations.  The simulation driver is not part of the
circuit; it's simply formatting inputs and outputs.</li>

<li>A main program that runs the simulation driver on the test data.</li>
</ul>

<p>
See `examples/adder/HalfAddRun.hs'
</p>

<p>
Run the simulation using any of the methods given above, e.g. enter
<b>ghc -e main HalfAddRun</b>.  Here is the result:
</p>

<pre class="example" id="org6f009f7">
$ ghc -e main HalfAddRun
Input: x = 0 y = 0  Output: c = 0 s = 0
Input: x = 0 y = 1  Output: c = 0 s = 1
Input: x = 1 y = 0  Output: c = 0 s = 1
Input: x = 1 y = 1  Output: c = 1 s = 0
</pre>
</div>
</div>

<div id="outline-container-orgf9d2b69" class="outline-3">
<h3 id="orgf9d2b69">Example: multiplexer</h3>
<div class="outline-text-3" id="text-orgf9d2b69">
<p>
The <i>multiplexer</i> is an example of a circuit that can be defined by
conecting several logic gates together. The multiplexer is one of the
most important building blocks for larger systems.  There are many
varieties of multiplexer; here we look at the 1-bit multiplexer,
called <code>mux1</code>.
</p>

<p>
Files:
</p>
<ul class="org-ul">
<li><code>examples/mux/Mux1.hs</code></li>
<li><code>examples/mux/Mux1Run.hs</code></li>
</ul>

<p>
A multiplexer is a hardware version of the if-then-else expression,
and is used to perform conditional actions in a circuit.  It takes
three inputs: a control input <code>c</code>, and two data inputs <code>x</code> and <code>y</code>.
</p>

<p>
The idea is that the multiplexer will choose one of the data inputs &#x2013;
either <code>x</code> or <code>y</code> &#x2013; and output it.  The data input that is not chosen is
simply ignored.  The choice is determined by the value of <code>c</code>.
</p>

<p>
The behavior of the multiplexer can be described informally using an
if&#x2013;then&#x2013;else expression.  This is just an English description, not a
circuit, because <b>if</b> is not a circuit: it's programming language
notation.
</p>

<pre class="example" id="org608b6b5">
-- informal specification
mux1 c x y = if c = zero then x else y
</pre>

<p>
The multiplexer can be implemented with logic gates.  The circuit is
defined in the file <code>Mux1.hs</code>, and a <i>simulation driver</i> is in
<code>Mux1Run.hs</code>.  A simulation driver is a software interface to the
actual circuit; the software takes inputs in a readable notation,
formats the outputs, and controls the simulation.
</p>

<p>
Files:
</p>
<ul class="org-ul">
<li><code>examples/mux/Mux1.hs</code></li>
<li><code>examples/mux/Mux1Run.hs</code></li>
</ul>

<p>
To run the simulation, enter  
</p>

<pre class="example" id="org2120140">
cd examples/mux
ghc -e main Mux1Run
</pre>

<p>
Given inputs c, x, y, the circuit outputs a bit whose value is
</p>

<pre class="example" id="orgea9136e">
or2 (and2 (inv c) x) (and2 c y)
</pre>

<p>
There are several ways to understand how this Boolean logic implements
the if-then-else construct.  One way is simply to build a truth table
showing the output for each possible input.
</p>

<p>
This expression can be read by working through each subexpression:
</p>
<ul class="org-ul">
<li><code>inv c</code> says there is an inverter, and its input is connected to
<code>c</code>.  The subexpression <code>inv c</code> denotes the output signal produced
by the inverter.</li>
<li><code>and2 (inv c) a</code> denotes the output of an and2 gate; its first input
is the output of the inverter and its second input is <code>a</code>.  This
signal is the first input to the <code>or2</code> gate.</li>
<li><code>and2 c y</code> is the output of an and2 gate with inputs c and y; the
output of the gate is the second input to the <code>or2</code> gate.</li>
</ul>

<p>
The file <code>examples/mux/Mux1.hs</code> defines the circuit as follows.
</p>

<pre class="example" id="org7983962">
mux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</pre>

<p>
Circuit definitions are discussed in more detail later, as well as the
rest of the file:
</p>

<div class="org-src-container">
<pre class="src src-hydra" id="orge51364a">module Mux1 where
import HDL.Hydra.Core.Lib

-- mux1 is defined in the Hydra circuit libraries, so here
-- the circuit is called mymux1 to ensure that we're testing
-- this definition

mymux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mymux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-hydra" id="org22d76a9">module Main where
-- Mux1Run: test the mux1 circuit

import HDL.Hydra.Core.Lib
import Mux1

main :: IO ()
main = mux1Run testdata

testdata :: [[Int]]
testdata =
-----------------------------------------
--   c  x  y       expected result
-----------------------------------------
  [ [0, 0, 0]  --  0  (c=0 so output=x)
  , [0, 0, 1]  --  0  (c=0 so output=x)
  , [0, 1, 0]  --  1  (c=0 so output=x)
  , [0, 1, 1]  --  1  (c=0 so output=x)
  , [1, 0, 0]  --  0  (c=1 so output=y)
  , [1, 0, 1]  --  1  (c=1 so output=y)
  , [1, 1, 0]  --  0  (c=1 so output=y)
  , [1, 1, 1]  --  1  (c=1 so output=y)
  ]

mux1Run input = runAllInput input output
  where
-- Extract input signals  
    c = getbit input 0
    x = getbit input 1
    y = getbit input 2
-- The circuit to be simulated
    z = mymux1 c x y
-- Format the output
    output =
      [string "  c=", bit c,
       string "  x=", bit x,
       string "  y=", bit y,
       string "    output z=", bit z
      ]
</pre>
</div>

<p>
We can run it with a simulation driver that runs the circuit on all
possible inputs, so the outputs form a truth table.  It's good
practice to write the test data with clean indentation, so the inputs
line up in columns, and to include the expected outputs in comments.
</p>

<p>
See examples/mux/Mux1Run.hs')
</p>
</div>
</div>
</div>


<div id="outline-container-org25db107" class="outline-2">
<h2 id="org25db107">Defining new circuits</h2>
<div class="outline-text-2" id="text-org25db107">
<p>
A new circuit can be designed by connecting together a number of
existing ones.  The examples given so far consist of logic gates,
which are primitive components.  To design larger scale systems, we
need the ability to define a circuit as a new <b>black box</b> component
and reuse it.  This is similar to using abstraction in a programming
language by defining a function or procedure for a commonly used
computation.  A circuit definition contains up to three parts:
</p>

<ol class="org-ol">
<li>Circuit type (optional)</li>

<li>Interface (mandatory)</li>

<li>Internal signals (optional)</li>
</ol>
</div>

<div id="outline-container-org47b4352" class="outline-3">
<h3 id="org47b4352">Circuit defining equation</h3>
</div>

<div id="outline-container-orgd81eff3" class="outline-3">
<h3 id="orgd81eff3">Black boxes with internal signals</h3>
<div class="outline-text-3" id="text-orgd81eff3">
<p>
Files: <b>adder/Add4.hs</b> and <b>examples/Add4Run.hs</b>
</p>

<pre class="example" id="org9da88d7">
*Main&gt; :main
  x =  5  y =  8  cin = 0    ==&gt;    cout = 0  s = 13
  x =  7  y =  3  cin = 0    ==&gt;    cout = 0  s = 10
  x =  8  y = 12  cin = 0    ==&gt;    cout = 1  s =  4
  x =  8  y =  1  cin = 0    ==&gt;    cout = 0  s =  9
  x = 12  y =  1  cin = 1    ==&gt;    cout = 0  s = 14
  x =  2  y =  3  cin = 1    ==&gt;    cout = 0  s =  6
  x = 15  y = 15  cin = 1    ==&gt;    cout = 1  s = 15
(0.00 secs, 252,808 bytes)
*Main&gt;
</pre>

<p>
This part of a definition is optional; if present it follows the
<b>where</b> keyword.
</p>

<p>
The expression that defines the circuit's output can become fairly
complicated, and it's often simpler to define it using several other
named signals.  Each of these needs a defining equation which is
inside the circuit.  To do this, write the keyword <b>where</b> after the
equation, and after the <b>where</b> you can write any number of signal
defining equations.  The general form is:
</p>


<pre class="example" id="org2b1bda9">
circuit_name input1 input2 = output
  where
    output = ...
    x = ... (internal signals...)
    y = ...
</pre>

<p>
Here is an example of a circuit named c22 that takes three inputs and
produces one output.
</p>

<pre class="example" id="orgdf610e9">
c22 a b c = x
  where
    x = xor2 p q
    p = and2 a b
    q = or2 b c
</pre>


<p>
The equations should be indented consistently, and there is no extra
punctuation (no curly braces, no semicolons).  The compiler determines
the structure of a definition from the indentation, not from
punctuation.  Therefore the indentation is essential, and if it's
wrong then the specification will be parsed incorrectly.
</p>
</div>
</div>
<div id="outline-container-org0426bc8" class="outline-3">
<h3 id="org0426bc8">Feedback</h3>
<div class="outline-text-3" id="text-org0426bc8">
<p>
A register is a circuit with an internal state, and with the ability
to load an external value into the state and to read out the state.
</p>



<div class="org-src-container">
<pre class="src src-ghci" id="org7825efd">module Reg1 where
import HDL.Hydra.Core.Lib
import HDL.Hydra.Circuits.Combinational

reg1 :: CBit a =&gt; a -&gt; a -&gt; a
reg1 ld x = r
  where r = dff (mux1 ld r x)
</pre>
</div>

<p>
The reg1 circuit has a feedback loop: the output of the flip flop is
connected to one of the inputs to the mux1, whose output in turn is
input to the flip flop.  Hydra does not allow feedback loops in pure
combinational logic, but feedback that goes through a flip flop is
fine.  When a circuit contains a feedback loop, there will be a
circular path in the schematic diagram, and there will be circular
equations in its specification.  For the reg1 circuit. the feedback
loop can be seen in the equation which has r on both the left and
right hand side.  Thus r is being defined in terms of itself.  The way
this works, and the reason that r is well-defined, is explained in the
section on circuit semantics.
</p>

<div class="org-src-container">
<pre class="src src-ghci">-- Simulation driver for reg1
module Main where
import HDL.Hydra.Core.Lib
import Reg1

main :: IO ()
main = do
  runReg1 testdata

testdata :: [[Int]]
testdata =
------------------------
--  ld  x       output
------------------------
  [ [1, 1],  -- 0  output in cycle 0 is initial state
    [0, 0],  -- 1  state changed to 1 at tick between cycles 0/1
    [0, 1],  -- 1  no change
    [0, 0],  -- 1  no change
    [1, 0],  -- 1  still see 1 but at end of cycle, set state to 0
    [0, 0],  -- 0 during this cycle can see result of state change
    [1, 1],  -- 0 but set state to 1 on tick at end of cycle
    [1, 0],  -- 1 the 1 becomes visible in this cycle
    [0, 0],  -- 0 the 0 now becomes visible
    [0, 0],  -- 0 no change
    [0, 0]   -- no comma after last element of list
  ]

runReg1 input = runAllInput input output
  where
-- Input signals
    ld = getbit input 0
    x  = getbit input 1
-- Circuit
    y = reg1 ld x
-- Format the input and output signals
    output =
      [string "Input ld = ", bit ld,
       string " x = ", bit x,
       string "   Output = ", bit y]
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgcf2551c" class="outline-2">
<h2 id="orgcf2551c">Modules and files</h2>
<div class="outline-text-2" id="text-orgcf2551c">
<p>
We start with an example in the directory <code>examples/simple</code>,
consisting of three files.  We will normally keep circuit definitions
and their simulation drivers in separate files, although that isn't
required.  For a circuit named <code>MyCirc.hs</code>, the naming convention is
to call the driver <code>MyCircRun.hs</code>.
</p>

<ul class="org-ul">
<li><code>SimpleCirc.hs</code> defines a circuit named <code>simpleCirc</code>, which takes
two input bits and outputs their logical <i>and</i>.  The circuit is just
an <code>and2</code> logic gate.</li>
</ul>
</div>

<div id="outline-container-orgc9e847b" class="outline-3">
<h3 id="orgc9e847b">The circuit specification</h3>
<div class="outline-text-3" id="text-orgc9e847b">
<p>
The circuit is defined in a module <code>SimpleCirc</code>, which is in the file
named <code>SimpleCirc.hs</code>.
</p>

<pre class="example" id="org26bd2b5">
-- SimpleCirc: minimal example of a circuit specification
-- This file is part of Hydra. See README and https://github.com/jtod/Hydra
-- Copyright (c) 2022 John T. O'Donnell

module SimpleCirc where
import HDL.Hydra.Core.Lib

-- Define a circuit "simpleCirc" which takes two input bits and
-- outputs their logical conjunction, using an and2 logic gate.

-- To run the circuit simulation, see SimpleCircRun and
-- SimpleCircRunInteractive.

simpleCirc :: Bit a =&gt; a -&gt; a -&gt; a   -- interface: two inputs, one output
simpleCirc x y = and2 x y            -- circuit is just an and2 logic gate
</pre>

<p>
A module begins with a <code>module</code> statement that gives its , followed by
statements that import other modules.  All Hydra modules must contain
<code>import HDL.Hydra.Core.Lib</code>, which defines, among other things, the
<code>and2</code> logic gate.
</p>

<p>
Following the imports, the module may contain any number of circuit
definitions.  The definition of the circuit <code>simpleCirc</code> contains two lines
of code: a <i>type declaration</i> which contains the symbol <code>::</code> and a
<i>defining equation</i> which contains the symbol =.
</p>

<p>
A type declaration specifies the name of the circuit and its
interface.  The declaration <i>simpleCirc :: Bit a =&gt; a -&gt; a -&gt; a</i> contains
several parts:
</p>

<ul class="org-ul">
<li>The beginning  means "simpleCirc has type&#x2026;".</li>
<li>Bit a    means the circuit uses Bit signals, and we will use the
name <i>a</i> for the type of a bit signal</li>
<li><i>a -&gt; a -&gt; a</i> says the circuit takes an input of type <i>a</i>, a second
input also of type <i>a</i>, and it outputs a signal of type <i>a</i></li>
<li>There may be any number of inputs, and each is followed by <i>-&gt;</i>.
This means that the number of inputs is the number of <i>-&gt;</i> in the
type.</li>
<li>There must be exactly one output.  The last <i>a</i> in the type is the
type of the output.  Later, we will see how to allow a circuit to
produce several outputs.</li>
</ul>

<p>
The defining equation specifies local names for the circuit's inputs,
and it gives a circuit that produces its output.  The defining
equation for this circuit is <code>simpleCirc x y = and2 x y</code>.  This says
</p>
<ul class="org-ul">
<li>We will use the names <code>x</code> and <code>y</code> as local names for the inputs to
the circuit</li>
<li>There is an <code>and2</code> logic gate with inputs <code>x</code> and <code>y</code></li>
<li>The output of that logic gate is the output of the circuit</li>
</ul>
</div>
</div>

<div id="outline-container-org331d5b5" class="outline-3">
<h3 id="org331d5b5">Modules and files</h3>
</div>
</div>


<div id="outline-container-org79c29e0" class="outline-2">
<h2 id="org79c29e0">Circuit simulation</h2>
<div class="outline-text-2" id="text-org79c29e0">
<p>
Running a circuit is necessary for testing, and observing its behavior
also helps in understanding.  One way to run a circuit is to fabricate
it in hardware, connect it to I/O devices, and observe its behavior.
That takes a lot of time.  It's easier and faster to <i>simulate</i> the
circuit, which allows you to run it in software.
</p>

<p>
This section shows how to simulate circuits using automated tools.
These techniques are well suited for small circuits, such as registers
and adders.  Section ??  introduces more powerful tools which are
valuable for larger and more complex circuits, such as processors.
</p>

<p>
We start with an example in the directory <code>examples/simple</code>,
consisting of three files.  We will normally keep circuit definitions
and their simulation drivers in separate files, although that isn't
required.  For a circuit named <code>MyCirc.hs</code>, the naming convention is
to call the driver <code>MyCircRun.hs</code>.
</p>

<ul class="org-ul">
<li><code>SimpleCirc.hs</code> defines a circuit named <code>simpleCirc</code>, which takes
two input bits and outputs their logical <i>and</i>.  The circuit is just
an <code>and2</code> logic gate.</li>

<li><code>SimpleCircRun.hs</code> defines a simulation driver for the circuit.  The
file provides a main program named <code>main</code> which runs the simulation
on test data which is also defined in the file.</li>

<li><code>SimpleCircRunInteractive.hs</code> is the same as <code>SimpleCircRun</code>, except
it runs interactively.  On each clock cycle it prompts the user to
enter the input values, and then displays the outputs.</li>
</ul>

<p>
To run the simulation, go to <code>examples/simple</code> and enter this on the
command line: <code>ghc -e main SimpleCircRun</code>.  The driver runs the
circuit on all possible inputs: 00, 01, 10, 11.  Since the circuit is
really just an <code>and2</code> gate, the output should be 0, 0, 0, 1.
</p>
</div>

<div id="outline-container-orga239e57" class="outline-3">
<h3 id="orga239e57">The simulation driver</h3>
<div class="outline-text-3" id="text-orga239e57">
<p>
To test the circuit, we can simulate it with some inputs.  This
requires a <i>simulation driver</i> which is defined in a separate module
in the file SimpleCircRun.hs.  The simulation driver defines the
interface to the circuit and specifies how to format the inputs and
outputs, so you don't have to read and write thousands of 0s and 1s.
</p>

<p>
The file begins by defining the module and importing some required
libraries.  Every Hydra file needs to import HDL.Hydra.Core.Lib.  In
addition, a simulation driver like SimpleCircRun needs to import the
circuit file, which should be in the same directory.
</p>

<pre class="example" id="orgbfd0e5f">
-- SimpleCircRun:  simulation driver for SimpleCirc
-- This file is part of Hydra. See README and https://github.com/jtod/Hydra
-- Copyright (c) 2022 John T. O'Donnell

-- Usage:  $ ghc -e main SimpleCircRun

module Main where
import HDL.Hydra.Core.Lib
import SimpleCirc


</pre>

<p>
A simulation driver can define input data, although this is not
required.  The data is given as a list of strings.  Each string
corresponds to one clock cycle, and it gives the values of the inputs
during that cycle.
</p>

<pre class="example" id="org96cc359">
testdata1 :: [String]
testdata1=
------------------------------
--   x   y     expected output
------------------------------
  [ "0  0"   --  0
  , "0  1"   --  0
  , "1  0"   --  0
  , "1  1"   --  1
  ]
</pre>

<p>
The file defines a function <code>main</code> that will run the simulation.
These two lines are boiler plate and every driver should contain them:
</p>

<pre class="example" id="orge189317">
main :: IO ()
main = driver $ do
-- Input data
  useData testdata1

-- Inputs
  x &lt;- inputBit "x"
  y &lt;- inputBit "y"

-- Circuit
  let z = simpleCirc x y

-- Output ports
  outputBit "z" z

-- Run
  runSimulation
</pre>

<p>
If you want the simulation to use any test data (e.g. testdata1), the
useData statement specifies which test data to use.  This command is
optional; if you don't include it (or if you comment it out) the
simulation will be interactive, and prompt you for the input values
every clock cycle.  But if the useData statement is present, the
simulation will run to completion without any intervention by the
user.
</p>

<pre class="example" id="org1856e8d">
useData testdata1
</pre>

<p>
Every driver is required to define an input port for every circuit
input.  The convention is that in input signal named x has an input
prt named in<sub>x</sub>.  Each input port is created with a statement of the
form portname &lt;- inPortBit "signame".  If the inport is a word, rather
than a bit, you would definit like this: in<sub>w</sub> &lt;- inPortWord "w" 8
where 8 is the word size.
</p>

<p>
There must be an input signal for each port.  These are defined using
inbsig for bits, and inwsig for words.
</p>

<p>
What is the difference between a port and a signal?  A signal is a
wire, and it can be connected directly to a circuit.  A port is a data
structure that contains the signal and also some addiitonal metadata
required by the simulator.
</p>

<p>
Notice that ports are defined using &lt;- and signals are defined with
the let keyword and =.
</p>

<pre class="example" id="org03c509b">

</pre>

<p>
The next piece of the driver is an equation that connects the input
and output signals to the circuit.  This equation is given in a let
statement
</p>

<pre class="example" id="orgb5b4965">

</pre>

<p>
The simulator will print out the values of all the signals for each
clock cycle.  You can either have the system do this automatically, or
you can supply a detailed format that gives precise control over the
output.
</p>

<p>
The easiest approach is to ask for automatic output of all the
signals.  To do this, you need to define an output port for each
output signal.  This uses the outPortBit function, which takes the
name of the signal "z" and the corresponding signal z.
</p>

<pre class="example" id="org1ac749a">

</pre>


<p>
The final piece of the driver is the command runSimulation.  If you
omit this, the simulation won't run and there won't be any output.
</p>

<pre class="example" id="org0b797d1">
runSimulation
</pre>

<p>
Alternatively, you can use the format statement which gives precise
control over the formatting of the simulation output.  The format is a
list of field specifiers.  The field specifier string "&#x2026;" says that
the literal string "&#x2026;" should appear in the output.  The field
specifier bit x says that x is a signal; its value should be printed
in the output (it will be either 0 or 1).
</p>

<pre class="example" id="org68e62cc">
-- Formatted output
  format [string "x=", bit x,
          string "  y=", bit y,
          string "   output = ", bit z,
          string "\n"
         ]
</pre>

<p>
There are several format specifiers, that allow output of words using
bit strings, decimal, hexadecimal, and both binary and two's
complement.  See examples/SimDriver for examples of these specifiers.
</p>
</div>
</div>

<div id="outline-container-org19502b1" class="outline-3">
<h3 id="org19502b1">Running the circuit simulation</h3>
<div class="outline-text-3" id="text-org19502b1">
<p>
To run a circuit you should cd to the directory that
contains the circuit (Circuit.hs) and its simulation driver
(CircuitRun.hs) files.
</p>

<p>
One way to run the simulation is to use the ghc command, which will
run the main program in CircuitRun as a single command:
</p>

<pre class="example" id="org1cdcb7e">
ghc -e main CircuitRun
</pre>

<p>
An alternative is to use the ghci command, which launches the
interactive version of ghc.  This offers many useful debugging tools,
but you need to give it several commands to run the simulation:
</p>

<pre class="example" id="org30a9853">
ghci
:load CircuitRun
:main
</pre>
</div>
</div>

<div id="outline-container-orgeb02fa0" class="outline-3">
<h3 id="orgeb02fa0">Batch and interactive simulation</h3>
<div class="outline-text-3" id="text-orgeb02fa0">
<p>
You can run a circuit simulation in batch mode, which will run to
completion with no intervention by the user.  Alternatively, you can
run it interactively.  The choice between the modes is determined by
just one line of code: the presence or absence of a useData statement.
</p>

<p>
If you run a simulation in interactive mode, the system will prompt
"hydra&gt;" and wait for you to enter a command.  When it does so, just
press Enter, which is the command to simulate one clock cycle.  It
will then prompt you for the value of each signal; enter a decimal
number.  When all the inputs have been provided, the driver will now
print out all the signal values and prompt for a command again.  The
help command will print a list of the available commands.
</p>

<p>
You can try out both approaches with the SimpleCircRun driver.  It
contains a useData, so it will run in batch mode.  But if you comment
out the useData, the driver will revert to interactive mode.
</p>
</div>
</div>
</div>


<div id="outline-container-orgc5285dd" class="outline-2">
<h2 id="orgc5285dd">Syntax</h2>
<div class="outline-text-2" id="text-orgc5285dd">
<p>
This section summarises the language syntax.  Hydra is actually
Haskell with some additional libraries, and it adopts all the syntax
rules of Haskell.
</p>
</div>

<div id="outline-container-org31f0fcd" class="outline-3">
<h3 id="org31f0fcd">Modules</h3>
</div>
<div id="outline-container-org5b00e5e" class="outline-3">
<h3 id="org5b00e5e">Comments</h3>
<div class="outline-text-3" id="text-org5b00e5e">
<p>
There are two ways to indicate a comment
</p>
<ul class="org-ul">
<li>Enclose the comment in brackets {- so this is a comment -}</li>
<li>A double dash &#x2013; indicates that everything else &#x2013; on the line is a
comment</li>
</ul>
</div>
</div>

<div id="outline-container-org87fac5e" class="outline-3">
<h3 id="org87fac5e">Names</h3>
<div class="outline-text-3" id="text-org87fac5e">
<p>
Names (also called identifiers) are used for circuits (e.g. logic
gates) and signals.  A name must begin with a lower case letter, and
may contain letters, digits, underscores, and primes (single quote).
The following are valid names:
</p>

<pre class="example" id="orgd3939c3">
x
select
adder
y'
bypass_ctl
</pre>

<pre class="example" id="orgc4af9b0">
Product    -- begins with upper case letter
x?3        -- contains invalid character ?
0          -- use zero to get the constant 0 signal
</pre>

<p>
The following identifiers cannot be used to name a circuit or signal:
</p>
</div>
</div>

<div id="outline-container-orgd6541eb" class="outline-3">
<h3 id="orgd6541eb">Scope</h3>
</div>

<div id="outline-container-orgb755bf4" class="outline-3">
<h3 id="orgb755bf4">Signal expressions</h3>
<div class="outline-text-3" id="text-orgb755bf4">
<p>
A signal is specified in Hydra by an expression.  The simplest form of
expression is simply the name of a signal.  For example, suppose we
have signals named <b>x</b> and <b>y</b>.  Then the following expressions denote
the corresponding signals.  Note that <b>zero</b> and <b>one</b> are simply the
names of the constant signals.
</p>

<pre class="example" id="orgff61309">
zero
one
x
y
</pre>

<p>
A signal is denoted by an expression, which can have any of the
following forms:
</p>

<ul class="org-ul">
<li>The constants <b>zero</b> and <b>one</b> are names that are pre-defined.
These should not be redefined: don't write zero or one on the left
hand side of an equation.</li>

<li>The name of a signal which is in scope: <b>x</b>, <b>carry</b>, <b>ctl<sub>ld</sub></b>.
Later we will see how to define these, using equations or circuit
inputs.</li>

<li>An application of a circuit to inputs denotes a signal: <b>or2 x y</b>
specifies a signal which is the output of an <b>or2</b> gate connected to
inputs <b>x</b> and <b>y</b>.</li>
</ul>

<p>
Any of these notations can be used as input to a component.
</p>

<p>
The component and the inputs are separated by a space; don't use
punctuation.
</p>

<pre class="example" id="org13ac965">
c = and2 a b          -- correct
d = and2 (a,b);       -- wrong! don't use ( , ) ;
</pre>
</div>
</div>

<div id="outline-container-org74fa223" class="outline-3">
<h3 id="org74fa223">Indentation</h3>
<div class="outline-text-3" id="text-org74fa223">
<p>
Haskell normally uses indentation, rather than punctuation, to
determine the structure of a definition.  There are good reasons
behind this approach to syntax.
</p>

<p>
It is also possible to use braces and semicolons to determine the
structure, instead of indentation.  This is particularly useful for
generators, where the specification is not written by hand and also
not intended to be human readable.  There are also some situations
where a large number of very short equations can be more readable with
many placed on each line, separated by punctuation.  However, these
situations are relatively uncommon.  Normally it's best to use
indentation and to make the layout of the code as readable as
possible.
</p>

<p>
The equations in a definition need to be lined up vertically
</p>

<pre class="example" id="orgfc72832">
circ x y = a   -- a good definition
  where
    p = bla bla...
    q = bla...
    r = bla...
</pre>

<pre class="example" id="orgef2bf37">
circ x y = a  -- a bad definition
  where
    p = bla bla...
   q = bla...
    r = bla...
</pre>
</div>
</div>
</div>



<div id="outline-container-org57f253b" class="outline-2">
<h2 id="org57f253b">Interfaces and types</h2>
<div class="outline-text-2" id="text-org57f253b">
<p>
The <b>type</b> of a value determines what operations you can perform on
it.  This holds for hardware description just as for programming.  The
type of a signal determines what kind of information it carries, and
the type of a circuit specifies the types and organisation of its
input and output signals.
</p>

<p>
A circuit has an interface to the outside world, and an internal
organization.  To use the circuit, all we need to know about is the
interface: what inputs need to be provided and what the outputs mean.
The type expresses a useful portion of this information: it describes
the number and organization of the inputs and outputs.  The meanings
of the circuit outputs are not specified by the type; they should be
described in documentation for the circuit.  Since Hydra models a
circuit as a function, a circuit type looks just like a function type.
</p>

<p>
The type declaration for a circuit is optional, as the compiler can
work out the type for itself.  If you omit the type, your circuit will
still run.  However, there are several benefits in writing out the
type explicitly:
</p>

<ul class="org-ul">
<li>The type gives useful information about the interface to the
circuit.  Later on, if you want to use this circuit in a larger one,
you will be more interested in the interface than the internal
components inside the circuit.</li>

<li>There is some redundancy between the type and the defining
equation.  If there is any inconsistency between the two, the
compiler will give a type error message.  That may be annoying, but
at least you know that the error lies somewhere in the (small)
specification of this one circuit.  If you omit the type
declaration, but there is an error in the defining equation, you may
get an error message that says, in effect, ``there is an error
somewhere in the (large) file'', but it's up to you to figure out
<b>where</b> the error is.</li>

<li>If you do get a type error message, the compiler will do its
best to give a helpful and informative message.  In practice,
though, the error messages will be far more understandable if you
include type declarations for your circuits.</li>
</ul>

<p>
If present, the type of a circuit should come immediately before the
defining equation.  Type declarations are easily recognizable: they
always contain the symbol <b>::</b>, and usually contain some arrows <b>=&gt;</b>
and <b>-&gt;</b>.  A typical example is
</p>

<pre class="example" id="org14a206a">
reg1 :: CBit a =&gt; a -&gt; a
</pre>


<p>
A type declaration contains several parts:
</p>

<ul class="org-ul">
<li>The circuit name (e.g. reg1)</li>
<li id="The">symbol, read as "has type"</li>
<li>The signal class ending with =&gt; (e.g. CBit a =&gt;)</li>
<li>The input and output signal types (e.g. a -&gt; a)</li>
</ul>
</div>

<div id="outline-container-org393f6e0" class="outline-3">
<h3 id="org393f6e0">Interface</h3>
<div class="outline-text-3" id="text-org393f6e0">
<p>
The interface gives the name of the circuit and names its inputs and
outputs.  A circuit is created with a <b>circuit defining equation</b>.
The left hand side of the equation is the name of the circuit followed
by the names of the input signals.  There may be any number of inputs.
The right hand side is an expression giving the value of the output
signal:
</p>


<pre class="example" id="orgd12fab8">
circ_name input1 input2 = expression
</pre>

<p>
This defines a circuit whose name is <b>circ<sub>name</sub></b>, which takes two
inputs named <b>input1</b> and <b>input2</b>, and produces an output with the
specified signal value.  Here is an example:
</p>

<pre class="example" id="org58c87b7">
mycirc a b c = and3 a (inv b) c
</pre>


<p>
The input names <b>a</b>, <b>b</b>, and <b>c</b>, are local to the definition of
<b>mycirc</b>, and they can be used to calculate the value of the output.
Another circuit can connect signals with arbitrary names, or no names
at all, to the inputs of <b>mycirc</b>.
</p>
</div>
</div>

<div id="outline-container-orgf938005" class="outline-3">
<h3 id="orgf938005">Interfaces and Types</h3>
<div class="outline-text-3" id="text-orgf938005">
<p>
The \emph{type} of a circuit describes its interface; in particular
</p>

<ul class="org-ul">
<li>how a signal is represented: this determines the choice of
semantic model;</li>
<li>how many inputs it takes, how they are structured;</li>
<li>how many outputs it produces, and how they are structured;</li>
<li>the size parameters, if any;</li>
<li>the building block circuits, if any.</li>
</ul>

<p>
If you try to plug the wrong number of signals into a circuit, you
will get a type error message.
</p>
</div>
</div>

<div id="outline-container-org37deca1" class="outline-3">
<h3 id="org37deca1">Signal types</h3>
<div class="outline-text-3" id="text-org37deca1">
<p>
<b>Short version.</b> If you're writing a routine circuit and just want to
simulate it, you can just write <b>CBit a =&gt;</b> for the signal class
constraint and then use <b>a</b> as the type for every bit signal.  In more
complicated situations, or if you want to know what this means, read
on.
</p>

<p>
When a circuit specification is executed, each signal has a specific
type.  Many types can be used, for example <b>Bool</b> or <b>Stream Lattice</b>.
The choice of type determines what happens during execution.  Some
types lead to combinational simulation, others lead to synchronous
simulation, others perform a path depth analysis, or generate a
netlist.
</p>

<p>
It's possible to define a circuit with a specific type, and if you do
this the class constraint (the part before =&gt;) is omitted.  For
example, we could define a Bool version of the mux1 circuit (call it
halfAddB) to operate in signals of type Bool:
</p>

<pre class="example" id="orgf1fbc6c">
halfAddB :: Bool -&gt; Bool -&gt; (Bool,Bool)
halfAddB x y = (and2 x y, xor2 x y)
</pre>


<p>
This is a little simpler than the standard definition halfAdd, which
(1) uses the type class constraint Bit a =&gt;, and (2) uses <b>a</b> rather
than <b>Bool</b> as the bit signal type.
</p>
</div>
</div>

<div id="outline-container-orgdbb8b48" class="outline-3">
<h3 id="orgdbb8b48">Inputs and outputs</h3>
<div class="outline-text-3" id="text-orgdbb8b48">
<p>
After the signal class (i.e. after the <b>=&gt;</b> symbol) come the types of
the inputs and output of the circuit.  In the simplest case, each
input or output signal is just a bit of type <b>a</b>.  There may be any
number of input arguments, and there must be one output result.  A
single arrow <b>-&gt;</b> must follow each input; thus the number of single
arrows in the type is the same as the number of inputs.
</p>

<p>
The inverter has one input of type <b>a</b>, which is followed by <b>-&gt;</b>, and
the type <b>a</b> of the output appears last.  The type declaration can be
read as "inv uses signals in the Bit class; it takes one input and
produces one output":
Thus the entire type declaration ``*inv :: Bit a =&gt; a -&gt; a*'' says
``*inv* is a circuit that takes an input bit signal, and produces an
output bit signal.''
</p>

<pre class="example" id="org7e0e451">
inv :: Bit a =&gt; a -&gt; a
</pre>


<p>
The notation <b>a -&gt; a</b> means "the circuit takes an input signal and
produces an output signal".  This is similar to conventional
mathematical notation; for example in mathematics there is a function
<b>im</b> that is given a complex number (type \(C\)) and returns its
imaginary part (type \(R\)), and a mathematician might write its type as
im : C -&gt; R.  (The reason :: is used in Haskell (and Hydra) is that :
is used for something else.)
</p>

<p>
Circuits that take several inputs have a slightly more complicated
type.  For example, here are the types for the family of and-gates:
</p>

<pre class="example" id="org0813cc5">
and2 :: Bit a =&gt; a -&gt; a -&gt; a
and3 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
and4 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a -&gt; a
</pre>

<p>
There is always one output, but any number of inputs, and every input
is followed by <b>-&gt;</b>.  To find out how many inputs a circuit takes,
just count the number of times <b>-&gt;</b> appears in its type.
</p>

<p>
If a circuit has several outputs, they must be enclosed in a
container, and this is reflected in the type.  See the section on
Containers.
</p>
</div>
</div>

<div id="outline-container-org9a4319d" class="outline-3">
<h3 id="org9a4319d">Circuit type</h3>
<div class="outline-text-3" id="text-org9a4319d">
<p>
The circuit type is covered in a later section.  It's optional,
although it is generally best to include it.  If present, the type can
be recognized by the :: symbol and a number of right arrow symbols; a
typical example is
</p>

<pre class="example" id="org9af44fe">
halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
</pre>
</div>
</div>

<div id="outline-container-org3698de7" class="outline-3">
<h3 id="org3698de7">Signal classes</h3>
<div class="outline-text-3" id="text-org3698de7">
</div>
<div id="outline-container-orgcc7e0df" class="outline-4">
<h4 id="orgcc7e0df">Combinational signals: Bit a</h4>
<div class="outline-text-4" id="text-orgcc7e0df">
<pre class="example" id="org86814c7">
halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (and2 x y, xor2 x y)
</pre>


<p>
The main disadvantage of using Bool as the signal type is that
combinational simulation is the <b>only</b> thing you can do with the
circuit.  However, Hydra provides many other options.  For example,
you can perform synchronous simulations over many clock cycles, but to
do that, the signals must have a different type.  You can do these
other things with <b>halfAdd</b>, but not with <b>halfAddB</b>.
</p>

<p>
There are several different types that can be used to represent a
signal.  These are organized into two main sets: <b>Bit</b> and <b>CBit</b>.
<b>Bit</b> is used for combinational circuits, and <b>CBit</b> ("clocked bit")
is used for sequential circuits.
</p>

<p>
signal.  The notation <b>Bit a =&gt;</b> means that <b>a</b> can be any type in the
set <b>Bit</b>, and therefore all of the Bit operations can be performed on
a signal of type <b>a</b>.
</p>

<p>
The commonest signal class constraints are:
</p>

<ul class="org-ul">
<li><b>Bit a =&gt;</b> is used when <b>a</b> is a bit signal in a combinational
circuit.  The circuit may contain logic gates, but not flip flops.</li>

<li><b>CBit a =&gt;</b> is used when <b>a</b> is a bit signal in a sequential
circuit, which may contain flip flops and feedback loops as well
as logic gates.</li>
</ul>
</div>
</div>

<div id="outline-container-org0d2883f" class="outline-4">
<h4 id="org0d2883f">Clocked signals: CBit a</h4>
<div class="outline-text-4" id="text-org0d2883f">
<p>
The signal class constraint 
Classes
</p>

<p>
Base signal types
</p>

<ul class="org-ul">
<li>Bool    (defined in Haskell standard libraries)</li>

<li>Word16  (defined in Haskell standard libraries)</li>

<li>Word32  (defined in Haskell standard libraries)</li>

<li>Lattice (defined in Hydra Core library)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org64458f4" class="outline-3">
<h3 id="org64458f4">Multiple outputs</h3>
</div>

<div id="outline-container-org6fead11" class="outline-3">
<h3 id="org6fead11">Form of a type declaration</h3>
<div class="outline-text-3" id="text-org6fead11">
<pre class="example" id="orgf4d9f51">
circname :: signalClass =&gt; inType -&gt; inType -&gt; outType
</pre>

<ul class="org-ul">
<li>circname is the name of the circuit; starts with lower case letter</li>
<li>signalClass gives information about the signal.  We will
normally use either {\color{red}Bit a} or {\color{red}CBit a}, but
there are many other options we won't be using</li>
<li>input and output types: {\color{red}a} for a bit signal,
{\color{red}[a]} or {\color{red}(a,a)} for a container holding
several bits</li>
</ul>
</div>
</div>

<div id="outline-container-org44adf56" class="outline-3">
<h3 id="org44adf56">Type declaration is optional</h3>
<div class="outline-text-3" id="text-org44adf56">
<ul class="org-ul">
<li>You can omit the type declaration; the compiler will work it
out automatically</li>
<li>There are some advantages for declaring the type:

<ul class="org-ul">
<li>It provides helpful documentation</li>
<li>It enables the compiler to give better error messages, if
there is an error in a circuit</li>
<li>A useful design technique is to specify first the types of
your circuits and to go back later to implement them</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org2169661" class="outline-3">
<h3 id="org2169661">Signal types and circuit semantics</h3>
<div class="outline-text-3" id="text-org2169661">
<ul class="org-ul">
<li>There is a close relationship between \emph{how a signal is
represented} and \emph{how the circuit is evaluated}.

<ul class="org-ul">
<li>Example: if you use Bool, then you can do logic simulation
but not synchronous simulation.</li>
<li>If you use streams, you can handle timing.</li>
<li>If you want to allow special techniques (tristate drivers,
wired or) you need a multiple-value logic.</li>
</ul></li>

<li>For this reason, it's not a good idea to give circuit types
like \texttt{inv :: Bool -> Bool}.</li>
<li>Instead, we use a \emph{type variable}, typically \texttt{a},
to represent the signal type.</li>
</ul>
</div>
</div>

<div id="outline-container-org805cdc5" class="outline-3">
<h3 id="org805cdc5">The signal class constraint</h3>
<div class="outline-text-3" id="text-org805cdc5">
<dl class="org-dl">
<dt>When you write \texttt{inv</dt><dd>Bit a =&gt; a -&gt; a}, the \texttt{Bit
a =&gt;} part means ``for an arbitrary type \texttt{a}, provided that
\texttt{a} is in the set of types that can represent a bit signal''.</dd>
<dt>Similarly, \texttt{reg1</dt><dd>CBit a =&gt; a -&gt; a -&gt; a}, the
constraint \texttt{CBit a =>} means the signal type \texttt{a} has
to be capable of representing clocked synchronous bit signals.</dd>
<dt>(no term)</dt><dd>Hydra offers many signal representations.</dd>
<dt>(no term)</dt><dd>Normally, the choice of specific signal type will be made by the
simulation driver.</dd>
</dl>
</div>
</div>

<div id="outline-container-org3e3e63e" class="outline-3">
<h3 id="org3e3e63e">Naming conventions</h3>
<div class="outline-text-3" id="text-org3e3e63e">
<ul class="org-ul">
<li>By convention, the type of a bit signal is called \texttt{a}.</li>
<li>The scope of the type variable \texttt{a} is the type
statement.</li>
<li>This means you can have a signal named \texttt{a} in the
circuit definition, without confusion.</li>
</ul>

<pre class="example" id="org0c075bf">
circ1 :: Bit a =&gt; a -&gt; a -&gt; a
circ1 a b = and2 a (inv b)
</pre>

<p>
In the first line, \texttt{a} is the signal type, but in the second
line \texttt{a} is the name of the first input signal.
</p>
</div>
</div>

<div id="outline-container-org451b877" class="outline-3">
<h3 id="org451b877">The usual cases</h3>
<div class="outline-text-3" id="text-org451b877">
<ul class="org-ul">
<li>For a combinational circuit, use {\color{red}|Bit a =&gt;|} and the
type of a bit signal is {\color{red}|a|}</li>
<li>For a clocked synchronous circuit, use {\color{red}|CBit a =&gt;|}
and the type of a bit signal is {\color{red}|a|}</li>
</ul>

<p>
There are many other options for the signal classes, but we won't use
them in CA4.
</p>
</div>
</div>

<div id="outline-container-org1ef13c5" class="outline-3">
<h3 id="org1ef13c5">Input and output types</h3>
<div class="outline-text-3" id="text-org1ef13c5">
<ul class="org-ul">
<li>A bit signal is indicated by the signal type \texttt{a}.</li>
<li>Each input signal group is followed by an arrow \texttt{->}.
This means that the number of arrows in the type is the number of
inputs.</li>
<li>The output signal group follows the last arrow.

<dl class="org-dl">
<dt>\texttt{and2</dt><dd>Bit a =&gt; a -&gt; a -&gt; a} has two arrows
\texttt{->}, so there are two input groups, both with type
\texttt{a}.  The output has type \texttt{a}.</dd>
<dt>\texttt{mux2</dt><dd>Bit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a}
has five input groups: a bit pair (used for control), four bits
(for data), and there is one output bit.</dd>
</dl></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org6522b94" class="outline-2">
<h2 id="org6522b94">Containers</h2>
<div class="outline-text-2" id="text-org6522b94">
<ul class="org-ul">
<li>Most circuits (except the simplest ones) have groups of signals
that travel together.</li>
<li>To keep circuit descriptions concise, we need to be able to put
these signals into a container and treat it as a single entity</li>
<li>There are two kinds of container:

<ul class="org-ul">
<li>A \alert{tuple} is a group of several signals that may be
unrelated</li>
<li>A \alert{word} is a sequence indexed by a bit position,
normally used for binary numbers</li>
</ul></li>

<li>A container of signals is indicated by a tuple type
\texttt{(a,[a])} or by a word type \texttt{[(a,a)]}.</li>
<li>Containers aren't part of the hardware!  They are just
\emph{notation} used to shorten the description of the hardware.</li>
<li>\emph{Any} circuit can be described without groups&#x2014;but the
description could be millions of lines long</li>
</ul>
</div>

<div id="outline-container-orgdd81f8c" class="outline-3">
<h3 id="orgdd81f8c">Tuples</h3>
<div class="outline-text-3" id="text-orgdd81f8c">
<p>
You construct a tuple simply by writing its components in
parentheses:
</p>

<pre class="example" id="org9728fc5">
code = (x,y,z)
</pre>

<p>
Given a tuple, you can supply names for its components with an
equation.  The tuple is a \emph{pattern} that defines the elements
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">p</td>
<td class="org-left">,</td>
<td class="org-left">q</td>
<td class="org-left">,</td>
<td class="org-left">r</td>
</tr>
</tbody>
</table>

<pre class="example" id="org9258c8d">
(p,q,r) = code
</pre>
</div>
</div>

<div id="outline-container-org410201d" class="outline-3">
<h3 id="org410201d">Circuits with several outputs</h3>
<div class="outline-text-3" id="text-org410201d">
<ul class="org-ul">
<li>Hydra requires every circuit to have \emph{one} output.</li>
<li>If there are several output signals, just group them in a tuple.</li>
</ul>

<p>
The half adder and demux1 circuits produce two outputs, which can be
specified as expressions in a tuple.
</p>

<pre class="example" id="org24cd810">
halfAdd x y = (and2 x y, xor2 x y)
demux1 c x = (and2 (inv c) x, and2 c x)
</pre>

<p>
In |demux2| it's necessary to define the output as a tuple of names
which are defined by equations.
</p>

<pre class="example" id="org17370d2">
demux2 (c0,c1) x = (y0,y1,y2,y3)
  where  (p,q) = demux1 c0 x
         (y0,y1) = demux1 c1 p
         (y2,y3) = demux1 c1 q
</pre>
</div>
</div>

<div id="outline-container-orgb6c9524" class="outline-3">
<h3 id="orgb6c9524">Words</h3>
<div class="outline-text-3" id="text-orgb6c9524">
<ul class="org-ul">
<li>A word \([x_0, x_1, \ldots, x_{k-1}]\) is used to represent
binary numbers.</li>

<li>There are notations to allow you to build words and extract
parts of words.</li>

<li>Some circuits are defined recursively: the definition for a
\(k+1\) bit word uses a subcircuit of size \(k\).</li>

<li>Sometimes you need to extract a bit or a field from a word,
or construct new words.</li>

<li>Therefore we need operators to add a new bit to a word,
extract a bit from a word, etc.</li>
</ul>
</div>

<div id="outline-container-orgff9138c" class="outline-4">
<h4 id="orgff9138c">Word size</h4>
<div class="outline-text-4" id="text-orgff9138c">
<p>
If \texttt{x} is a word, then \texttt{length x} gives the number of
elements.
</p>

<pre class="example" id="org5661323">
n = length x
</pre>

<ul class="org-ul">
<li>With this definition, \texttt{n} can be used as a size
parameter to define other circuits.</li>
<li>Important: \texttt{length} is not a circuit!  It is a
meta-operator; it is a calculation on the notation.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc0414d4" class="outline-4">
<h4 id="orgc0414d4">Constructing words</h4>
<div class="outline-text-4" id="text-orgc0414d4">
</div>
<ul class="org-ul">
<li><a id="org1a10e04"></a>List notation for words<br />
<div class="outline-text-5" id="text-org1a10e04">
<p>
A word can be either
</p>

<ul class="org-ul">
<li>An \emph{empty word}, written \texttt{[]}, which contains no
bits at all.</li>
<li>A \emph{nonempty word}, which has to be of the form
\texttt{(x:xs)}, where \texttt{x} is the initial bit and
\texttt{xs} is a word comprising the rest of the bits.</li>
<li>Example: Suppose \texttt{xs = [p,q,r,s]}.  Then \texttt{x:xs
= [x,p,q,r,s]}.</li>
</ul>

<p>
Attaching a singleton \texttt{x} onto a word \texttt{xs}
</p>

<pre class="example" id="org577f06f">
(x:xs)
</pre>
</div>
</li>

<li><a id="orgb88a89f"></a>Concatenation<br />
<div class="outline-text-5" id="text-orgb88a89f">
<p>
Concatenating two words \texttt{x} and \texttt{y}
</p>

<pre class="example" id="orgf2e5dd7">
x++y
</pre>

<ul class="org-ul">
<li>If |w1 = [a,b,c]| and |w2 = [d,e,f,g]|, then</li>
<li>|w1++w2| = |[a,b,c,d,e,f,g]|</li>
</ul>

<p>
You could also write |[a,b,c] ++ [d,e,f]| although that usually isn't
very useful.
</p>
</div>
</li>

<li><a id="orgb2a4a60"></a>Accessing parts of words with a pattern<br />
<div class="outline-text-5" id="text-orgb2a4a60">
<ul class="org-ul">
<li>The left hand side is defined to have the value of the right
hand side.</li>
<li>When the lhs is a pattern, it defines the names in the pattern
to be the corresponding elements of the rhs.</li>
<li>This only works if the number of elements in the pattern matches
the number of elements in the word</li>
</ul>

<pre class="example" id="org9cfbd5e">
[a,b,c,d] = w
</pre>
</div>
</li>

<li><a id="org2fc73d6"></a>Indexing an element of a word<br />
<div class="outline-text-5" id="text-org2fc73d6">
<ul class="org-ul">
<li>The \texttt{(!!)} operator indexes an element in a word, where
the leftmost element has index 0.</li>
<li>Example: |[a,b,c,d] !! 2| = |c|</li>
<li>The most significant element of |w| is |w!!0|.</li>
<li>There is also a ``most significant bit'' function; thus |msb w|
is equivalent to |w!!0|</li>
<li>The least significant element is |w!!(length w - 1)|.  There is
also a ``least significant bit'' function; thus |lsb w| is equivalent
to |w!!(length w - 1)|.</li>
</ul>

<p>
Examples: the following are equivalent:
</p>

<pre class="example" id="orgc28f779">
lt_tc = mux2 (xy!!0) lt zero one lt
lt_tc = mux2 (msb xy lt zero one lt
</pre>
</div>
</li>

<li><a id="org35f22db"></a>Big Endian and Little Endian<br />
<div class="outline-text-5" id="text-org35f22db">
<ul class="org-ul">
<li>Notations are always somewhat arbitrary!</li>
<li>You can number bits in a word increasing from the left, or from
the right; starting from 0, or starting from 1.</li>
<li>Hydra numbers the bit positions from left to right, starting
from 0</li>
<li>This convention makes the formula for binary value of a word
slightly more complicated&#x2014;a one-time cost of 3 or 4 characters</li>
<li>But it makes many other expressions in a large circuit slightly
simpler</li>
<li>Another common convention (\emph{not} used in Hydra) is to mix
the two notations in the same specification, and to let the reader
guess which one is in effect everywhere</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org62a5575" class="outline-4">
<h4 id="org62a5575">Deconstructing words</h4>
<div class="outline-text-4" id="text-org62a5575">
</div>
<ul class="org-ul">
<li><a id="org9a6c210"></a>Fields<br />
<div class="outline-text-5" id="text-org9a6c210">
<ul class="org-ul">
<li>Usually the best way to extract part of a word is to use a
\alert{field}, which is a part of a word.</li>
<li>Do this with the |field| function; again this is ``meta
notation'', not a circuit.</li>
<li>|field w i k| gives the word consisting of the portion of |w|
starting at index |i| and continuing for |k| elements.</li>
<li>It is an error if a field is specified that doesn't lie within
the word.</li>
</ul>

<p>
Here is a typical example: |ir| is the instruction register, a 16-bit
word, and |ir<sub>sa</sub>| is a field within an instruction.
</p>

<pre class="example" id="orgbd58249">
ir_sa = field ir 8 4
</pre>
</div>
</li>

<li><a id="orga0a362e"></a>Patterns<br />
<div class="outline-text-5" id="text-orga0a362e">
<ul class="org-ul">
<li>Words are treated as lists, and you can use Haskell's list
operations on them.</li>
<li>Normally it is better to use |(++)|, |(!!)|, and |field|.</li>
<li>The |(:)| operator is useful for defining ``design patterns''
tree-structured circuits (later!)</li>
<li>Suppose you have a word \texttt{w}, and you want to give a
separate name to the first bit, and to all the rest.</li>
<li>Example: \texttt{w = [a,b,c,d,e]} and you want to use the
name \texttt{x} to refer to the first bit (which is \texttt{a})
and \texttt{xs} to refer to the rest (which is
\texttt{[b,c,d,e]}).</li>
</ul>

<p>
This is achieved by writing:
</p>

<pre class="example" id="org0d2d9b8">
(x:xs) = w
</pre>
</div>
</li>

<li><a id="org993e604"></a>Using list pattern notation<br />
<div class="outline-text-5" id="text-org993e604">
<ul class="org-ul">
<li>The left hand side \texttt{(x:xs)} is a \emph{pattern} giving
names to components of a structure</li>
<li>Similarly a circuit input can be written as \texttt{(x:xs)}.
(This is sometimes done in the recursive case of the definition
of a design pattern.)</li>
</ul>

<p>
The parentheses in \texttt{(x:xs)} are just for grouping, so the
\texttt{:} operator gets the right precedence.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org360f572" class="outline-3">
<h3 id="org360f572">Nested containers</h3>
<div class="outline-text-3" id="text-org360f572">
<ul class="org-ul">
<li>You can have a tuple containing two words |:: ([a], [a])|</li>
<li>Or a word of tuples |:: [(a,a,a)]|</li>
<li>Or arbitrarily deeply nested containers |:: ([(a,a)], a, ([a],a),
[a])|</li>
<li id="|rippleAdd4">Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])| has two input
groups: a singleton bit (the carry input) and a word of pairs (the
numbers to add).  The output contains a singleton (carry output) and
a word (the sum).
<ul class="org-ul">
<li>The type {\color{red}|[(a,a)]|} is an important special case
which is called {\color{blue}bit slice format}.  The |rippleAdd4|
type is an example of bit slice format.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org983f882" class="outline-3">
<h3 id="org983f882">Containers</h3>
<div class="outline-text-3" id="text-org983f882">
<p>
In a physical circuit, every wire carries one bit, and doesn't have
any relationship to any other wire (unless it is actually connected to
that other wire).  When we design a circuit, however, it takes several
wires to carry any data value that isn't just a Boolean.  For example,
it takes 16 wires to transmit a 16-bit word, and to the designer there
is definitely a clear relationship among these wires.
</p>

<p>
Circuits may contain large numbers of signals, and it would be
tiresome to name them all.  You can simplify the description of a
circuit by defining <b>containers</b> that hold a collection of signals.
Then you can use the container as a single object, without referring
explicitly to its components.
</p>

<p>
A design is clearer if related signals together are grouped together,
with a name for the entire collection.  For example, we could give the
name <b>x</b> to a 16-bit word, and just use <b>x</b> to refer to all the wires
collectively.
</p>

<p>
Hydra provides two kinds of container: <b>tuples</b> and <b>words</b>.
Tuples are useful for circuits that have multiple inputs and outputs;
an example of a tuple is <b>(x, (a,b))</b>.  Words are appropriate when
several signals are used to represent a number, for example
<b>[x0,x1,x2,x3]</b>.
</p>

<p>
Both kinds of container are written with several elements separated by
commas.  A quick way to tell them apart is that tuples use round
parentheses <b>( &#x2026;  )</b> but words use square brackets <b>[ &#x2026;  ]</b>.
</p>

<p>
Containers are just notations that help to simplify the description of
large circuits.  If you look at the layout of a chip under a
microscope, you won't see any tuples or words&#x2014;just thousands of
individual wires and components.  A circuit specification that names
each one explicitly would be long and unreadable; containers enable us
to write compact and readable descriptions of such large circuits.
</p>
</div>

<div id="outline-container-org9ecfa98" class="outline-4">
<h4 id="org9ecfa98">Tuples</h4>
<div class="outline-text-4" id="text-org9ecfa98">
<p>
Tuples provide the simplest way to give a single name to a bundle of
signals.
</p>

<p>
Suppose we have a couple of signals named <b>a</b> and <b>b</b>.  They can be
collected together into a tuple by writing <b>(a,b)</b>.  The elements are
written inside round parentheses ( &#x2026; ) and separated by commas.
</p>

<p>
The elements of the tuple are expressions that describe signals.  Any
expression can be used; it doesn't have to be a signal name.  For
example, the tuple <b>(and2 x y, or2 x y)</b> is a tuple consisting of two
signals, the outputs of two logic gates.  In this example, the actual
signals in the tuple don't have names.
</p>

<p>
A tuple can have any number of elements.  Thus <b>(inv x, y, z)</b> is a
3-tuple and <b>(a,b,c,d)</b> is a 4-tuple.
</p>

<p>
If the basic signal type is <b>a</b>, as usual, then a 2-tuple has type
<b>(a,a)</b>, a 3-tuple has type <b>(a,a,a)</b>, and so on.  The type shows
explicitly the number of elements.
</p>

<p>
One of the commonest ways to use a tuple is to describe a circuit that
has several outputs.  Indeed, there is no way to do this without using
a cluster (a tuple or a word).  Recall that the type of a circuit
contains a number of arrows (<b>-&gt;</b>) and the type of the output comes
after the last arrow.  If there are actually several outputs, we need
to combine them into a cluster and give the cluster's type as the type
of the output.
</p>

<p>
Here is an example.  Suppose we want to define a circuit that has two
input bit signals, called <b>x</b> and <b>y</b>.  The circuit produces two
outputs, <b>and2 x y</b> as well as <b>or2 x y</b>.  Let's name the circuit
<b>aor2</b>.  Here is a full definition:
</p>

<pre class="example" id="org09bb7a2">
aor :: Bit a =&gt; a -&gt; a -&gt; (a,a)
aor x y = (and2 x y, or2 x y)
</pre>


<p>
The definition of <b>aor</b> consists of two parts: a type declaration (the
line containing <b>::</b>), and a defining equation (thie line containing
the <b>=</b>).  In general, every circuit specification should contain
these two parts.
</p>

<p>
Notice that there are two arrows (<b>-&gt;</b>) in the type.  This means that
there are two inputs, and each has type <b>a</b> &#x2014; that is, each input is
a bit signal.  The type of the output comes after the last arrow, and
it is <b>(a,a)</b>, so the output of the circuit is a tuple containing two
bit signals.
</p>

<p>
The signal defining equations we have considered up to now have had a
signal name on the left hand side: <b>x = &#x2026;</b>.  In general, however,
the left hand side of an equation is a <b>pattern</b>.
</p>

<p>
It is also possible to have an input cluster.  The <b>aor</b> circuit above
has two inputs, and these were treated separately: there are two
arrows in the type, one after each input type.  An alternative
notation is to say that the circuit has just one input, which is a
cluster containing two elements:
</p>

<pre class="example" id="orge7ad02f">
aorTup :: Bit a =&gt; (a,a) -&gt; (a,a)
aorTup (x,y) = (and2 x y, or2 x y)
</pre>


<p>
Compare the definitions of <b>aorTup</b> and <b>aor</b>.  Both of them have two
input bits named <b>x</b> and <b>y</b>, but they are organized differently.  In
<b>aor</b>, the inputs are treated as separate arguments, each of type <b>a</b>,
and each followed by an arrow <b>-&gt;</b>.  In <b>aorTup</b>, the input bits are
collected together into the tuple <b>(x,y)</b> which has type <b>(a,a)</b>, and
this tuple is the sole argument.
</p>

<p>
These two circuits, <b>aor</b> and <b>aorTup</b>, are essentially the same.
They would look identical on a VLSI chip under the microscope.  The
only difference between them is the notation used to describe them.
</p>

<p>
There is an asymmetry in the notation.  If a circuit has several
inputs, there is a choice of notation: they can be treated as separate
arguments, or they can be collected together into a tuple.  However,
if a circuit has several outputs, there is no choice: they <b>must</b>
be collected together into a tuple.
</p>

<p>
This notation for types, with the arrows and the (apparently)
different treatment of circuit inputs and outputs, may look strange
and counterintuitive.  There is actually a very good reason the type
notation is designed this way, but it involves some techniques we are
not ready to discuss yet (see the chapter on design patterns).
</p>

<p>
There are other uses for tuples besides just handling circuits with
multiple outputs.  Sometimes tuples are useful just for cutting some
of the boilerplate in a specification, making it shorter and easier to
read.  Suppose we have a circuit where two signals, say <b>x</b> and <b>y</b>,
are needed as inputs to several other building block circuits <b>f1</b>,
<b>f2</b>, and <b>f3</b>.  We could write the specification with all the signals
written out explicitly:
</p>

<pre class="example" id="org89faa32">
circ :: Bit a =&gt; a -&gt; a -&gt; a
circ x y = z
  where
     p = f1 x y
     q = f2 x y
     r = f3 x y
     z = xor3 p q r
</pre>

<p>
But we might be able to simplify this by changing the types of <b>circ</b>,
<b>f1</b>, <b>f2</b>, and <b>f3</b> to collect <b>x</b> and <b>y</b> into a tuple.
</p>

<pre class="example" id="orgd6cac52">
circ :: Bit a =&gt; (a,a) -&gt; a
circ xy = z
  where
     p = f1 xy
     q = f2 xy
     r = f3 xy
     z = xor3 p q r
</pre>

<p>
In a large and complicated system, this technique can make a big
difference.  For example, in a processor circuit there may be a number
of signals needed to control the arithmetic-logic unit, and those
signals travel together.  It can cut down on the notation
significantly just to combine them into a tuple, give the tuple a
name, and pass around the whole cluster without mentioning the
individual components.
</p>

<p>
Sometimes you may have a cluster, but you need to extract its elements
and give them individual names.  This can be done in a circuit black
box definition using a signal defining equation.  For example, the
following equation defines <b>alpha</b> and <b>beta</b> to be the names of the
elements of a tuple named <b>pair</b>:
</p>

<pre class="example" id="org10190e0">
(alpha,beta) = pair
</pre>

<p>
Tuples can be nested.  For example, <b>(p, (x,y,z))</b> is a 2-tuple
(<b>not</b> a 4-tuple!).  The first element is <b>p</b>, and the second
element is a 3-tuple <b>(x,y,z)</b>.  The type is
</p>


<pre class="example" id="org3b5c8b3">
(p, (x,y,z)) :: (a, (a,a,a))
</pre>

<p>
This example shows a crucial property of tuples: their elements may
have different types; in this case the type of the first element is
<b>a</b> and the type of the second element is <b>(a,a,a)</b> and those types
are different, just as a physical wire is not the same thing as a
bundle of three physical wires.
</p>

<p>
Why use a tuple type like <b>(a,(a,a,a))</b> when a simple 4-tuple would
seem simpler?  The reason is that sometimes, in larger systems, a
sub-circuit produces many outputs, and groups of them will then be
connected to different destinations.  The notation to describe this is
simpler if the tuple structure matches the logical organization of the
circuit.  We will see several examples of this, especially in the
design of processors.
</p>

<p>
It is also possible to have two different signal representations in a
specification.  Each one needs its own distinct type variable name.
For example, suppose we are designing a circuit that has a basic bit
signal type <b>a</b>, but the circuit also has some values where we aren't
concerned about the bit representation (floating point numbers,
perhaps).  To abstract away from the bit representation, we could give
another type <b>b</b> to these abstract values.  Then a black box circuit
that outputs both a bit and a floating point number would have the
output type <b>(a,b)</b>.
</p>
</div>
</div>

<div id="outline-container-org47aee01" class="outline-4">
<h4 id="org47aee01">Words</h4>
<div class="outline-text-4" id="text-org47aee01">
<p>
There are two kinds of cluster that allow several signals to be
collected together into one entity.  The previous section discussed
tuples, and now we introduce words.  Tuples allow arbitrary groupings,
while words have a regular structure and their elements can be
accessed by indexing.  Words are frequently used for collections of
bits that represent binary numbers.
</p>


<p>
In a word, bit indices are 0, 1, &#x2026;, n-1 where bit 0 is most
significant.  The expression <b>[x0,x1,x2,x3]</b> denotes a word containing
the individual signals <b>x0</b>, &#x2026;, <b>x3</b>.  The syntax is similar to a
tuple; the difference is that an expression for a word uses square
brackets <b>[ \ ]</b> while a tuple uses round parentheses <b>( \ )</b>.
</p>

<p>
The basic usage of a word is similar to a tuple.  For example, a
circuit could collect several signals into a word and output that.
Here is an alternative definition of the half adder:
</p>


<pre class="example" id="org4855cd9">
halfAddw :: Bit a -&gt; a -&gt; a -&gt; [a]
halfAddw x y = [c,s]
  where
    c = and2 x y
    s = xor2 x y
</pre>


<p>
There two differences between this definition and the one given
earlier.  First the output expression here is <b>[c,s]</b>, so it's a word,
while the output expression given for the original <b>halfAdd</b> is
<b>(c,s)</b>, which is a tuple.  The other difference is quite important:
the output type is <b>[a]</b>, rather than <b>(a,a)</b> for the original
<b>halfAdd</b>.
</p>

<p>
All the elements of a word must have the same type.  If this type is
<b>a</b>, then the word has type <b>[a]</b>.  The type of a word doesn't specify
how many elements the word contains.  This is different from a tuple,
where <b>(a,a)</b> contains exactly two elements, and <b>(a,a,a,a)</b> contains
exactly four elements.
</p>

<p>
Each element of a word has an index, a natural number that gives its
position within the word.  You can think of a word as an array or
vector.  The index of the leftmost position is 0, and the index of the
rightmost position is <b>k-1</b>, where <b>k</b> is the length of the word.
If we have defined some bit signals <b>x0</b>, <b>x1</b>, <b>x2</b>, and <b>x3</b>, then
we could define a word <b>x</b> of these bits with the equation
</p>


<pre class="example" id="orga9fda1d">
w = [x0,x1,x2,x3]
</pre>


<p>
There are actually two conventions commonly used in computer systems.
One convention starts with position 0 at the left end, and counts up
going to the right.  This is called <b>big Endian</b> notation.  The
other convention, naturally called <b>little Endian</b>, starts with 0
as the index of the rightmost element, and the indices count up going
to the left.
</p>

<pre class="example" id="orge5743e9">
[x0,x1,x2,x3]   -- Big Endian convention
[x3,x2,x1,x0]   -- Little Endian convention
</pre>


<p>
As you might imagine, neither convention is fundamentally better than
the other, but there are all sorts of minor issues that might cause
one to be preferred over the other.  Hydra allows both conventions,
but in this book we will stick to Big Endian consistently.
</p>

<p>
There seems to be a phenomenon in computer systems, where the less
significant an issue is, the more heated debate there is about it.
This phenomenon was actually the inspiration for the odd names
Big/Little Endian.  The names come from Gullivers Travels, by Jonathan
Swift, where the citizens of the kingdom of Blefuscu open their eggs
at the big end, while the citizens of Lilliput open their eggs at the
little end.  The application of this story to computer systems comes
from an article by Danny Cohen, ``On Holy Wars and a Plea for Peach''
(IEEE Computer, October 1981).
</p>

<p>
The point here (aside from an entertaining digression) is that having
a standard is a good idea, and arguments for one particular choice are
less compelling than having a consistent standard.  Nevertheless,
there is one situation in hardware description where Little Endian is
slightly more convenient than Big Endian (see ref????) and some
authors actually combine both conventions.  The confusion isn't worth
it!
</p>

<p>
The size or length of a word is the number of elements it contains.
If a word contains \(k\) elements, then their indices range from 0 to
\(k-1\).  Hydra provides a meta-function <b>length</b> that takes a word and
returns an integer giving its size.
</p>


<pre class="example" id="org746c916">
length :: [a] -&gt; Int
</pre>



<p>
For example, <b>length [x0,x1,x2] = 3</b>.  With just the parts of Hydra
covered so far, there is no way to use the length of a word, but later
we will encounter some more powerful features where an algorithm will
generate a circuit of a given size, and then the <b>length</b> function
will be useful.  It's important to remember that <b>length</b> is not a
circuit; it is part of the notation used to describe circuits.
</p>

<p>
There are several notations and operators that can be used to build
words from signals, and for extracting the signals within a word.  The
following sections introduce these notations, and then a couple of
example circuits will be presented.
</p>
</div>
</div>

<div id="outline-container-org9e4c237" class="outline-4">
<h4 id="org9e4c237">A circuit with words and internal signals</h4>
<div class="outline-text-4" id="text-org9e4c237">
<p>
Files: <b>Add4.hs</b> and <b>Add4Run.hs</b>
</p>

<p>
The <b>add4</b> circuit takes two 4-bit binary numbers <b>x</b> and <b>y</b>, and a
carry input <b>c</b>.  It adds them and outputs a carry output bit and a 4
bit sum.  The circuit is defined in <b>Add4.hs</b>.  A main program
containing test data and a simulation driver is in <b>Add4Run.hs</b>.  To
run the simulation, enter <b>ghc -e main Add4Run</b>.  Here is the output:
</p>
</div>

<ul class="org-ul">
<li><a id="org8ba3aab"></a>Building words<br />
<div class="outline-text-5" id="text-org8ba3aab">
<p>
If you have expressions that define some signals, a word comprising
the signals can be constructed by writing the expressions in square
brackets, separated by commas.
</p>


<pre class="example" id="org0f5a32b">
[p,q,r,s]
</pre>



<p>
The length of a word can be any natural number.  Thus <b>[]</b> is the
empty word, <b>[x]</b> is a word containing just one element, and so on.
</p>


<pre class="example" id="orgde39b4d">
[]                          -- length = 0
[x]                         -- length = 1
[x,y]                       -- length = 2
[x0,x1,x2,x3,x4,x5,x6,x7]   -- length = 8
</pre>


<p>
Suppose you have a word <b>w</b>, of any length, and a bit signal <b>x</b>.
Thus <b>w :: [a]</b> and <b>x :: a</b>, where <b>a</b> is the basic signal type.
Then we can construct a new word which is just like <b>w</b> except that
the singleton <b>x</b> is attached to the front.  The notation for this is
<b>x:w</b>, which is pronounced ``*x cons w*''.  For example, suppose <b>w =
[p,q,r,s]</b>.  Then <b>(x:w) = [x,p,q,r,s]</b>.  The properties of the <b>(:)</b>
operator are summarized as follows:
</p>


<pre class="example" id="org81fe084">
x :: a
w :: [a]
(x:w) :: [a]
length (x:w) = 1 + length w
</pre>


<p>
It's often useful to take two words that have already been defined,
and to define a bigger one that contains the elements of both.  This
is called <b>append</b> or <b>concatenation</b>, and is done using the
<b>(++)</b> operator.  The word <b>w1 ++ w2</b> is a word containing first the
elements of <b>w1</b>, and then the elements of <b>w2</b>.  Here are some
examples and properties of append:
</p>


<pre class="example" id="org9ad2f71">
[x0,x1,x2,x3] ++ [y0,y1] = [x0,x1,x2,x3,y0,y1]
length (w1 ++ w2) = length w1 + length w2
</pre>
</div>
</li>

<li><a id="org92b618f"></a>Accessing parts of a word<br />
<div class="outline-text-5" id="text-org92b618f">
<p>
Often we can perform operations on entire words, using word-oriented
digital circuits, without ever accessing individual elements of a
word.  Later we will see a family of building block circuits that
operate on words.  Normally this is the best way to organize a circuit
that works with words.
</p>

<p>
Sometimes, however, it's necessary to extract one or more elements of
a word.  One way to do this is by <b>indexing</b>.  Each element of a
word <b>w</b> has an index, ranging from 0 to \(k-1\), where <b>k = length w</b>.
The <b>(!!)</b> operator uses an index to extract the element; thus <b>w!!i</b>
gives the $i$th element of the word <b>w</b>.  This is well defined if the
index <b>i</b> is in range: \(i \leq length\ w\).  If \(i<0\), or \(i \geq
length\  W\), then <b>w!!i</b> is an error.
</p>



<pre class="example" id="org49ed7cf">
w!!i                   i'th bit of word w
field w i j            bits i..i+j-1 of word w
</pre>

<p>
There are two special cases for indexing that are supported by
specific operators: you can get the least significant (or most
significant) bit of a word <b>w</b> using <b>lsb w</b> (or <b>msb w</b>).  The least
significant bit <b>lsb w</b> is equivalent to <b>w !! (length w -1)</b>, and the
most significant bit <b>msb w</b> is equivalent to <b>w !! 0</b>.
</p>


<pre class="example" id="org8b9d04f">
w !! i                 (!!) :: [a] -&gt; Int -&gt; a
lsb w                  lsb :: [a] -&gt; a
msb w                  msb :: [a] -&gt; a
</pre>


<p>
There are three functions that give a field from a word; that is, the
result is itself a (smaller) word, not just an individual bit.  The
<b>take</b> and <b>drop</b> functions give a sub-word that is at the beginning
or end of a word.  Thus <b>take i w</b> gives a word consisting of the
leftmost \(i\) elements of <b>w</b>, while <b>drop i w</b> gives a word consisting
of all the elements of <b>w</b> <b>except for</b> the leftmost \(i\)
elements.
</p>

<p>
More generally, it is sometimes necessary to extract an arbitrary
field from a word.  A <b>field</b> is a word consisting of any
consecutive set of elements.  A field has type <b>Field</b>, and it
consists of a pair of integers <b>(i,s)</b> where <b>i</b> is the index of the
starting position of the field, and <b>s</b> is its size.  Thus <b>field
(i,s) w = [w!!i, w!!(i+1), &#x2026;, w!!(i+s-1)]</b>.
</p>



<pre class="example" id="org65fe8c4">
type Field = (Int,Int)
take i w                 take :: Int -&gt; [a] -&gt; [a]
drop i w                 drop :: Int -&gt; [a] -&gt; [a]
field f w                field :: Field -&gt; [a] -&gt; [a]
</pre>


<p>
An example of a circuit that operates on words is the 4-bit word
inverter <b>inv4</b>.  Its input and output are both 4-bit words, and each
output bit is the inversion of the corresponding input bit.  The type
notation for the word is concise, since the types of the individual
bits don't have to be repeated, but on the other hand the type doesn't
express the fact that this circuit works only on 4-bit words.
</p>

<pre class="example" id="orgd705f93">
inv4 :: Bit a =&gt; [a] -&gt; [a]
inv4 [x0,x1,x2,x3] = [inv x0, inv x1, inv x2, inv x3]
</pre>

<p>
The circuit specification for <b>inv4</b> is simple enough, but it would be
painful to extend this to much larger sizes, say 64-bit words.  The
chapter on design patterns shows a more elegant approach, but for
small words the style used here is adequate.  The Hydra libraries
provide a collection of straightforward circuit specifications written
in the same style as <b>inv4</b>, and they also provide circuits that are
defined using design patterns and that work for arbitrary word sizes,
no matter how large.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org4b35e0e" class="outline-4">
<h4 id="org4b35e0e">Nested clusters</h4>
<div class="outline-text-4" id="text-org4b35e0e">
<p>
The cluster types can be nested.  A tuple may contain words (or deeper
tuples), and a word may contain tuples (or deeper words, although that
is unusual).
</p>

<p>
There is a style of circuit design called <b>bit slice
  organization</b>.  The idea is that a building block circuit is defined
for an arbitrary position within a word, and these building blocks can
then be combined.  Bit slice style often results in complex groupings,
with words of tuples, and notwithstanding the relatively complex types
it can result in simple specifications of efficient circuits.  The
essence of bit slice organization is to keep the corresponding bits of
several words together.  Thus two words \(x\) and \(y\) could be
represented as a word of pairs, rather than two separate words:
</p>

<p>
\([(x0,y0), (x1,y1), (x2,y2), (x3,y3)] :: [(a,a)]\)
</p>

<p>
Collecting a group of signals into a cluster is just a notational
convenience; it doesn't affect the actual circuit.  However, grouping
can simplify the way you <b>describe</b> the circuit, and this is essential
for large and complex circuits.
</p>

<p>
When you are designing a circuit with several input signals, you can
decide whether to treat them as separate arguments (each followed by
an arrow <b>-&gt;</b>) or as a single argument which is a tuple or word.
However, if you are using a circuit that has already been specified,
you need to follow the type used in its specification.
</p>

<p>
When a circuit has several outputs, there is no choice&#x2014;the output
signals must be collected into a tuple or a word.  The reason for this
is that the underlying functional language requires that each function
has one result.  This does not limit our ability to express complex
circuits; it simply means that we need to use tuples or words.
</p>

<p>
Grouping is often helpful just to simplify the notation and to make
specifications more readable.
</p>

<p>
A tuple (x, (a,b)) is used to collect several values which may be
unrelated to each other.  Tuples are used for groups where the
components are unrelated, and indexing doesn't make sense.  The
components may have different types: \((a, (a,a), a)\) A word is used to
collect values that belong to specific bit positions, typically to
form a binary number.  Tuples and words can be combined to form
complex clusters.
</p>

<p>
Example: a 4-Bit ripple carry adder
</p>

<p>
For the multiplexer (the hardware equivalent of an if-then-else)
there is little to gain by grouping the inputs, so we use separate
parameters without grouping: *mux1 c x y = &#x2026; *
</p>

<p>
For the full-adder, which adds three bits, it's convenient to
group the bits \(x\) and \(y\) from the $i$th position in a word together,
and to keep them separate from the carry input bit \(c\).
  *fullAdd (x,y) c = &#x2026; *
</p>

<p>
Don't worry&#x2014;the reasons for these decisions will become clear later,
when we start making advanced uses of these circuits.  It's common to
make some changes to the grouping notation for a circuit after you
start using it extensively!
</p>

<pre class="example" id="org452ff50">
rippleAdd4 c [(x0,y0), (x1,y1), (x2,y2), (x3,y3)] =
    (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd c1 (x0,y0)
    (c1,s1) = fullAdd c2 (x1,y1)
    (c2,s2) = fullAdd c3 (x2,y2)
    (c3,s3) = fullAdd c  (x3,y3)
</pre>


<p>
<b><b>Exercise.</b></b>
A circuit has the type declaration <b>circ :: Bit a =&gt; a
    -&gt; (a,a) -&gt; [a] -&gt; (a,[a])</b>.  How many groups of input bits are
  there?  How are they structured?  How is the output structured?
</p>

<p>
<b><b>Exercise.</b></b> Modify the definition of <b>rippleAdd4</b> to handle 6-bit
words.
</p>

<p>
<b><b>Exercise.</b></b> Define an 8-bit adder, named <b>rippleAdd8</b>.  Don't follow
the pattern of <b>rippleAdd4</b>, with eight equations.  Instead, use
<b>rippleAdd4</b> as a building block circuit.  In your definition of
<b>rippleAdd8</b>, use two separate internal <b>rippleAdd4</b> circuits, and
connect them up appropriately.
</p>

<p>
<b><b>Exercise.</b></b> Suppose <b>x = [x0,x1,x2]</b>, <b>y = [y0,y1,y2,y3]</b>, and <b>z =
  x++y</b>.  What are the values of <b>z</b>, <b>length z</b>, and <b>z!!4</b>?
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgdb92400" class="outline-2">
<h2 id="orgdb92400">Simulation drivers with format and state</h2>
<div class="outline-text-2" id="text-orgdb92400">
<p>
This section shows several examples of circuits of increasing
complexity.  You should be able to design and simulate some circuits on
your own by following and modifying these examples.  The various
design techniques are described in more detail in later sections.  For
now, just run the examples, and refer back to them as the subsequent
sections explain the language.  See the examples directory for a
collection of circuits.
</p>

<p>
To run a circuit, two definitions are needed: a circuit specification,
and a simulation driver.  The circuit specification states precisely
the interface to the circuit, what components it contains, and how
they are connected.  The simulation driver describes how to provide
inputs using a readable input format, and how to format the outputs to
make them readable.  For example, Reg1.hs defines a 1-bit register
circuit, and Reg1Run.hs is the simulation driver which handles
conversion between readable notation and internal signals.
</p>

<p>
It's good practice to place the circuit definition and its simulation
driver in separate files.  By convention, the filename of the driver
ends in "Run".
</p>
</div>

<div id="outline-container-orgb61d12f" class="outline-3">
<h3 id="orgb61d12f">Automatic output and formatted output</h3>
<div class="outline-text-3" id="text-orgb61d12f">
<p>
You can choose between automatic or manual formatting of the
simulation results.
</p>

<ul class="org-ul">
<li>If a format statement is present, the automatic output is disabled
and the outport is produced entirely by the format.  However, the
system will indicate the clock cycles.</li>
<li>If the format is omitted, then the system will generate output using
the port definitions.  In this case, outport definitions are
required.</li>
</ul>

<p>
A simulation driver must either define the outports, or it must
contain a format.  If it contains both, the outports are ignored.  So
if you wish to provide a format there is no need to define the
outports.
</p>

<p>
For small circuits, it may be easiest to define the outports and use
the automatic output.  For large circuits, you can make the results
more compact and more readable by defining a format.
</p>
</div>
</div>

<div id="outline-container-orgfde7792" class="outline-3">
<h3 id="orgfde7792">Feedback and changing state: BSR4</h3>
<div class="outline-text-3" id="text-orgfde7792">
<p>
Files: <b>BSR4.hs</b> and <b>BSR4Run.hs</b>
</p>

<p>
A bidirectional shift register
</p>

<p>
Define a shift register that takes an operation code op and data
inputs x, li, ri, and performs an a state change depending on op:
</p>

<ul class="org-ul">
<li>op=0 &#x2013; no state change</li>
<li>op=1 &#x2013; load input word x</li>
<li>op=2 &#x2013; shift right</li>
<li>op=3 &#x2013; shift left</li>
</ul>

<p>
The circuit uses a building block srb ("shift register block") which
has an internal state to hold the bit in that position in the word.
The inputs to an srb are an input from the left (for shifting to the
right), an input from the right (for shifting to the left), and a bit
input from the word x (for loading a word).  The circuit outputs a
triple: the left and right outputs, and the word giving the current
state of the register.  (Minor point: the left and right outputs
aren't essential, as they also appear as the most and least
significant bits of the word output, but this approach makes it easier
to connect several sr4 circuits together, and it also fits well with
the definition of the more general sr circuit below.)
</p>

<p>
The structure of the 4-bit version comes directly from the data
dependencies.
</p>

<p>
The shift register block uses a dff to hold the state, and it uses a
mux2 to determine the new value of the state.  This is either the old
value, the data bit x from a load, or the input from the left or right
in case of a shift.
</p>

<p>
examples/shift/BSR4.hs
examples/shift/BSR4Run.hs
</p>

<p>
The test data and simulation driver are defined in <b>BSR4Run.hs</b>.
Running the circuit produces this:
</p>


<pre class="example" id="orgd3162f6">
$ ghc -e main BSR4Run
op=01 l=0 r=0 x=9   Output lo=0 ro=0 y=0
op=00 l=0 r=0 x=0   Output lo=1 ro=1 y=9
op=11 l=0 r=0 x=0   Output lo=1 ro=1 y=9
op=11 l=0 r=1 x=0   Output lo=0 ro=0 y=2
op=00 l=0 r=0 x=0   Output lo=0 ro=1 y=5
op=01 l=0 r=0 x=4   Output lo=0 ro=1 y=5
op=10 l=1 r=0 x=0   Output lo=0 ro=0 y=4
op=10 l=0 r=0 x=0   Output lo=1 ro=0 y=a
op=10 l=0 r=0 x=0   Output lo=0 ro=1 y=5
op=10 l=1 r=0 x=0   Output lo=0 ro=0 y=2
op=00 l=0 r=0 x=0   Output lo=1 ro=1 y=9
</pre>
</div>
</div>
</div>


<div id="outline-container-org52f5114" class="outline-2">
<h2 id="org52f5114">Records with named fields</h2>
<div class="outline-text-2" id="text-org52f5114">
<p>
When a circuit has a small number of inputs or outputs, it's
straightforward to provide them in a fixed order.  For example, here
is the definition of a multiplexer:
</p>

<pre class="example" id="org99b0a04">
mux1 :: Signal 1 =&gt; a -&gt; a -&gt; a -&gt; a
mux1 c x y = or2 (and2 (inv c) x)
                 (and2 c y)
</pre>

<p>
To use it, you need to know that the first input <code>c</code> is the control,
that the input <code>x</code> is output if <code>c</code> is zero, and the input <code>y</code> is
output if <code>c</code> is one.
</p>

<p>
However, complex circuits may have too many inputs and outputs to be
able to remember all their positions in a list of ports.  Even if
you remember that the signal you want is the 19th one, it's awkward
to get access to it.  Some modern chips have thousands of input and
output signals.
</p>
</div>

<div id="outline-container-org8f9b643" class="outline-3">
<h3 id="org8f9b643">Defining a group of signals</h3>
<div class="outline-text-3" id="text-org8f9b643">
<p>
The solution is to identify the signals by name and to collect a
group of named signals in a <i>record</i>.  Here is a definition from the
Datapath module, which provides a number of output signals that are
collected into a record with type <code>DPoutputs a</code>:
</p>

<pre class="example" id="org05d06ef">
data DPoutputs a = DPoutputs
     { aluOutputs :: ([a], [a])
     , r :: [a]        -- alu output
     , ccnew :: [a]     -- alu output
     , ma :: [a]
...
     }
</pre>

<p>
The Datapath module defines the signals: it contains an equation for
each element of the record giving the value.
</p>

<pre class="example" id="orga337b9a">
...
aluOutputs = ...
r = ...
ccnew = ...
...
</pre>
</div>
</div>

<div id="outline-container-org8c4c3f2" class="outline-3">
<h3 id="org8c4c3f2">Defining a group of signals</h3>
<div class="outline-text-3" id="text-org8c4c3f2">
<p>
The record itself is named <code>dp</code> and is defined by this equation:
</p>

<pre class="example" id="org78bf0d9">
dp = DPoutputs {..}
</pre>

<p>
The notation <code>{..}</code> means that each defined value whose name is
listed in the record type (<code>DPoutputs</code>) should be included in the
actual record (<code>dp</code>).  For example, the record type <code>DPoutputs a</code>
defines a field named <code>ccnew</code> and there is an equation defining the
value <code>ccnew</code>, so <code>ccnew</code> is included in the record <code>dp</code>.
</p>

<p>
The definition of the datapath circuit is an equation where the
right hand side says that the output is <code>dp</code>, which is defined to be
the record of signals <code>dp</code>:
</p>

<pre class="example" id="org6923220">
datapath (CtlSig {..}) (SysIO {..}) memdat = dp
  where

-- Interface
    dp = DPoutputs {..}
</pre>

<p>
The first input to the datapath circuit is <code>(CtlSig {..})</code>, which is
a record of signals output by the control circuit.  When used as an
input, this <code>{..}</code> notation means that every field in the <code>CtlSig</code>
record defines the corresponding name.  With this notation, you
don't need to write a separate equation for every element of the
<code>CtlSig</code> record.
</p>

<p>
The <code>{..}</code> notation makes it easy to add a new signal to a record.
For example, suppose you modify the datapath to contain two new
signals: <code>pqr</code> which is a bit, and <code>xyz</code> which is a word of bits.
The following changes are required:
</p>
<ul class="org-ul">
<li>Add equations defining the new signals to the <code>Datapath</code> module:</li>
</ul>
<pre class="example" id="org1701dec">
pqr = ...
xyz = ...
</pre>
<ul class="org-ul">
<li>Add the new signals to the record definition in the <code>Interface</code>
module:</li>
</ul>
<pre class="example" id="org7535cb7">
data DPoutputs a = DPoutputs
  { ...
  , pqr :: a
  , xyz :: [a]
  ...
}
</pre>
<ul class="org-ul">
<li>Now you can use <code>pqr</code> and <code>xyz</code> in any module that receives the
<code>DPoutputs</code>.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org4389d4e" class="outline-2">
<h2 id="org4389d4e">Circuit generators</h2>
<div class="outline-text-2" id="text-org4389d4e">
<ul class="org-ul">
<li>Often we won't describe every component ``by hand''</li>

<li>We can use \emph{circuit generators} &#x2014; algorithms that
create the circuit</li>

<li>The simplest kind is a \emph{generic circuit} which works for
any word size

<ul class="org-ul">
<li>For now we'll look at some examples of generic circuits
defined using a circuit generator</li>

<li>Later we'll look at how to use the generators</li>

<li>And even later, we'll see how to define new circuit
generators.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgb8effa3" class="outline-3">
<h3 id="orgb8effa3">Inverting all the bits in a word</h3>
<div class="outline-text-3" id="text-orgb8effa3">
<p>
Word inverter: |winv4| takes a word and inverts each of its bits
</p>

<pre class="example" id="org7ab0878">
winv4 :: Bit a =&gt; [a] -&gt; [a]
winv4 [a,b,c,d] = [inv a, inv b, inv c, inv d]
</pre>

<ul class="org-ul">
<li>You can use {\color{blue}|winv4 x|} if |x| is a 4-bit word, but
not if it's an 8 or 16 bit word.</li>
<li>The generic circuit {\color{blue}|winv|} works for any word
size.  It's defined using a {\color{red}circuit generator} called
{\color{red}map}.</li>
</ul>

<pre class="example" id="orgd1ef6cd">
winv :: Bit a =&gt; [a] -&gt; [a]
winv = map inv
</pre>
</div>
</div>

<div id="outline-container-orgdbc2394" class="outline-3">
<h3 id="orgdbc2394">How does a circuit generator work?</h3>
<div class="outline-text-3" id="text-orgdbc2394">
<ul class="org-ul">
<li>winv4 is a 4-bit word inverter</li>
<li>winv generates an $n$-bit word inverter: it works for
\emph{every word size}</li>
<li>The circuit generator works by (1) measuring the size of the
input word and (2) generating the required number of components</li>
<li>{\color{red}This is not software to do the operation &#x2014; it is
still a real circuit.}</li>
</ul>
</div>
</div>

<div id="outline-container-orgda7be3d" class="outline-3">
<h3 id="orgda7be3d">Calculating the and/or of many bits</h3>
<div class="outline-text-3" id="text-orgda7be3d">
<p>
Take a word, and and/or all its bits together
</p>

<pre class="example" id="org821f13e">
andw4 [a,b,c,d] = and2 (and2 a b) (and2 c d)
</pre>

<p>
For bigger words, it's better to use generic circuits andw, orw that
are defined using the circuit generator {\color{red}foldl}:
</p>

<pre class="example" id="orgc76bab0">
andw, orw :: Bit a =&gt; [a] -&gt; a
andw = foldl and2 one
orw = foldl or2 zero
</pre>

<p>
The input is a word of bits, and the output is the and/or of all those
bits.  This is like an $n$-bit or gate with an $n$-bit input word.
</p>
</div>
</div>

<div id="outline-container-orgdb87706" class="outline-3">
<h3 id="orgdb87706">4-bit ripple carry adder</h3>
<div class="outline-text-3" id="text-orgdb87706">
<pre class="example" id="org1a37d5a">
rippleAdd4 :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd4 cin [(x0,y0),(x1,y1),(x2,y2),(x3,y3)]
  = (c0, [s0,s1,s2,s3])
  where
    (c0,s0) = fullAdd (x0,y0) c1
    (c1,s1) = fullAdd (x1,y1) c2
    (c2,s2) = fullAdd (x2,y2) c3
    (c3,s3) = fullAdd (x3,y3) cin
</pre>

<p>
In Sigma16 we need a 16-bit adder.  Many current machines contain
64-bit adders.  This would be painful to write in the style of
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">rippleAdd4</td>
<td class="org-left">.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga4f60b9" class="outline-3">
<h3 id="orga4f60b9">Ripple carry adder schematic</h3>
<div class="outline-text-3" id="text-orga4f60b9">
</div>
</div>

<div id="outline-container-org36a6b82" class="outline-3">
<h3 id="org36a6b82">Generic $n$-bit ripple carry adder</h3>
<div class="outline-text-3" id="text-org36a6b82">
<ul class="org-ul">
<li>The \texttt{rippleAdd} generic circuit is similar to
\texttt{rippleAdd4}, except it works on all word sizes.</li>

<li>It's defined using a very powerful generator called {\color{red}mscanr}</li>

<li>At circuit generation time, the generator measures the sizes of
its input words, and then it constructs a circuit with the right
number of full adders, and automatically does all the wiring.</li>

<li><p>
Notice that |rippleAdd| is equivalent to an infinite set of
definitions |rippleAdd0|, |rippleAdd1|, |rippleAdd2|, |rippleAdd3|,
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">rippleAdd4</td>
<td class="org-left">, \(\ldots\),</td>
<td class="org-left">rippleAdd64</td>
<td class="org-left">, \(\ldots\),</td>
</tr>
</tbody>
</table></li>

<li>Yet the definition of |rippleAdd| is far simpler than
e.g. |rippleAdd4|.</li>

<li>This is due to the power of the generator |mscanr|.</li>
</ul>

<pre class="example" id="org4782d38">
rippleAdd :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd = mscanr fullAdd
</pre>
</div>
</div>

<div id="outline-container-org1c94ddb" class="outline-3">
<h3 id="org1c94ddb">``Times''</h3>
<div class="outline-text-3" id="text-org1c94ddb">
<ul class="org-ul">
<li>Programmers talk about two ``times'' involved in running a
program:

<ul class="org-ul">
<li>Compile time</li>
<li>Run time</li>
</ul></li>

<li>This makes a real difference: an error message at compile
time is very different from a crash at run time</li>
<li>Hydra has four ``times''

<ul class="org-ul">
<li>Model transformation time</li>
<li>Circuit generation time</li>
<li>Circuit compilation time</li>
<li>Runtime (simulator execution time)</li>
<li>And to get real hardware, there is

<ul class="org-ul">
<li>Netlist and layout generation time</li>
<li>Fabrication time</li>
<li>Running the hardware circuit</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgb35d673" class="outline-3">
<h3 id="orgb35d673">Circuit generators</h3>
<div class="outline-text-3" id="text-orgb35d673">
<p>
We will generally specify large circuits using a circuit generator,
not by drawing every component individually.  There are two kinds of
circuit generator.  Design patterns (higher order functions) are the
focus of this chapter.  Special languages for special kinds of circuit
(e.g. control algorithms) are covered later.
</p>

<p>
Design patterns use circuits as building blocks
</p>

<p>
Design patterns are <b>higher order</b> functions: they take one or
more <b>circuit specifications</b> as parameters.  The pattern defines
how to connect up these given circuits in a regular pattern.  A
pattern definition looks just like an ordinary circuit specification,
except It uses recursion to decompose groups of signals.  It uses
abstract circuits, supplied as parameters, instead of specific
circuits.  Its type may include building block circuits (these
parameters contain an <b>-&gt;</b> in their type) and/or size
parameters (with a type like <b>Int</b>).
</p>
</div>

<div id="outline-container-orgf3d546c" class="outline-4">
<h4 id="orgf3d546c">Map</h4>
<div class="outline-text-4" id="text-orgf3d546c">
<p>
Word inverter: winv takes a word and inverts each of its bits
</p>


<pre class="example" id="orgfe79772">
winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x
</pre>


<p>
Operating on each element of a word of known size: mapn
</p>


<pre class="example" id="org6eff549">
wlatch :: CBit a =&gt; Int -&gt; [a] -&gt; [a]
wlatch k x = mapn dff k x
</pre>


<p>
The word register
</p>


<pre class="example" id="orgdbab90e">
reg
  :: CBit a =&gt;
  Int             -- ** k = the word size
  -&gt; a          -- ** ld = the load control signal
  -&gt; [a]        -- ** input word of size k
  -&gt; [a]        -- ** output is the register state
reg k ld x = mapn (reg1 ld) k x
</pre>


<p>
Mapping a circuit with multiple inputs
</p>


<pre class="example" id="orge00bdea">
mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y
</pre>



<pre class="example" id="org6589169">
mux2w cc = map4 (mux2 cc)
</pre>
</div>

<ul class="org-ul">
<li><a id="org1103419"></a>The map combinator<br />
<div class="outline-text-5" id="text-org1103419">
<p>
Sometimes you have a circuit (it's arbitrary, so call it f) that takes
an input (say it has type a) and produces an output (call its type
b).  You need to take a word of signals, and process each one with
the circuit f.  For example, <b>inv4</b> processes each signal with an
<b>inv</b>.  The <b>map</b> pattern describes this in general.
</p>



<pre class="example" id="org5557a7f">
map :: (a-&gt;b) -&gt; [a] -&gt; [b]
</pre>


<ul class="org-ul">
<li>The first argument to the pattern is a circuit with type  <b>a-&gt;b</b></li>
<li>The pattern then generates a circuits, which takes an input word of
type <b>[a]</b> and produces an output word of type <b>[b]</b>.</li>
</ul>

<p>
Example of map
</p>

<p>
We can define a word inverter using the pattern that places an
inverter on each input signal, to produce the corresponding output
signals.
</p>


<pre class="example" id="org5b38608">
winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x
</pre>


<p>
Technical note: in a defining equation of the form <b>f a b c
  = g c</b>, you can ``factor out'' the rightmost parameter from both
sides, giving a slightly shorter form.
</p>


<pre class="example" id="org6c776fe">
winv :: Bit a =&gt; [a] -&gt; [a]
winv = map inv
</pre>

<p>
This is attractive because it describes just the pattern.
</p>


<pre class="example" id="orge2abd11">
map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
</pre>


<p>
This definition is a recursion, based on the word structure of the
input.
</p>

<p>
The base case is an empty input word <b>[]</b>.  In this
case, the output is also empty.
</p>

<p>
The recursion (or induction) case has an input word <b>x:xs</b> consisting
of an initial bit <b>x</b> followed by the rest of the word, <b>xs</b>.  The
circuit introduces a copy of the <b>f</b> circuit to process <b>x</b>, and
handles the rest recursively.
</p>


<p>
Extending map to multiple inputs
</p>

<p>
The <b>map2</b> pattern is similar to <b>map</b>, but it uses a
circuit that takes two inputs (thus its type is <b>a-&gt;b-&gt;c</b>).
Note that <b>map2</b> is <b>not</b> a bit-slice pattern; it uses
separate words.
</p>


<pre class="example" id="orge3844ab">
map2 :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt; [c]
</pre>


<p>
We can extend the basic multiplexor to handle words:
</p>


<pre class="example" id="orgcace450">
mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y
</pre>
</div>
</li>

<li><a id="org2229636"></a>Sized map<br />
<div class="outline-text-5" id="text-org2229636">
<p>
The <b>mapn</b> pattern is similar to <b>map</b>, except it
takes a size parameter, and guarantees to produce an output of that
size.
</p>


<pre class="example" id="org917ff20">
mapn :: (a-&gt;b) -&gt; Int -&gt; [a] -&gt; [b]
</pre>



<p>
Registers are defined using <b>mapn</b>, to ensure that the number
 of flip flops is defined
Combinational circuits may be defined using <b>map</b>, so
 they inherit the word size of their input
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org5f372a4" class="outline-4">
<h4 id="org5f372a4">Fold</h4>
<div class="outline-text-4" id="text-org5f372a4">
<p>
The folding patterns define a linear circuit structure.
</p>


<p>
There is an input word of type <b>[b]</b>.
</p>

<p>
The elements of the word are combined using a building block
 <b>f</b>.
</p>

<p>
There is a ``horizontal'' signal of some type (call it
 <b>a</b>), which is goes across the word from left to right.
</p>

<p>
An initial horizontal input, of type <b>a</b> is provided.
</p>

<p>
The output is the final horizontal output (produced by the
 rightmost <b>f</b> circuit).
</p>

<p>
Folding corresponds to a linear computation from one end of the
word to the other, starting with an initial value a (sometimes
called an accumulator, but this is not to be confused with
accumulator registers!).
</p>
</div>

<ul class="org-ul">
<li><a id="orge63978e"></a>Fold from the left<br />
<div class="outline-text-5" id="text-orge63978e">
<p>
In general, a fold can proceed either direction across the word.
The <b>foldl</b> pattern describes a <b>fold from the left</b>;
i.e. the information flows from left to right across the word.
</p>


<pre class="example" id="org94a6f61">
foldl :: (a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a
</pre>


<p>
The pattern is defined recursively:
</p>


<pre class="example" id="org16d106b">
foldl f a [] = a
foldl f a (x:xs) = foldl f (f a x) xs
</pre>



<p>
xamples: orw, andw
</p>

<p>
The <b>orw</b> circuit determines whether there is any 1 bit in a
word.
</p>


<pre class="example" id="org9ed3656">
orw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
</pre>


<p>
The <b>andw</b> circuit determines whether all the bits in a word
are 1.
</p>

<p>
And/Or over a word
</p>

<pre class="example" id="org99889c7">
orw, andw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
andw = foldl and2 one
</pre>


<p>
The time required (the path depth) is linear in the word size.
There are also tree-structured patterns that can do these
computations in logarithmic time.
</p>


<p>
Efficiency
</p>

<p>
The definitions of <b>orw</b> and <b>andw</b> are not very efficient
</p>

<p>
If a large number of signals are being combined, a tree structure of
logic gates reduces the path depth.  If this circuit is on the
critical path, that will help.  If the technology supplies 3 or 4
input gates, it would likely be faster to use some of those, rather
than just the 2 input gates.  The <b>foldl</b> pattern uses one extra gate
to include the ``default'' value of zero or one.  This is overhead.
</p>

<p>
This inefficiency is not a concern, because
</p>

<ul class="org-ul">
<li>There are alternative patterns that generate more efficient circuits</li>
<li>A circuit optimiser can generate optimal results If the circuit
isn't on the critical path, it makes no difference anyway.</li>
</ul>
</div>
</li>

<li><a id="org79eadd5"></a>Binary comparison using foldl<br />
<div class="outline-text-5" id="text-org79eadd5">
<p>
The problem: input two binary numbers, in bit slice form:
 <b>[(x0,y0), (x1,y1), &#x2026;, (xk,yk)]</b>
Output the result of a comparision: <b>(lt,eq,gt)</b>,
 giving the values of \((x<y, x=y, x>y)\).  Exactly one of the three
 output bits must be 1.
Idea: start from left, assuming the numbers are equal so far:
 <b>(0,1,0)</b>.
Move over the columns from left to right, updating the
 results of the comparision using a building block circuit
 <b>cmp1</b>.
Going from left to right, once we have established either \(<\)
 or \(>\), that result will never change.
If the current result is \(=\) and \(x=y\), it's still \(=\).
If the current result is \(=\) but \(x\) and \(y\) are different,
 the new result becomes \(<\) or \(>\).
</p>

<p>
A bit comparison building block circuit:
</p>


<pre class="example" id="org9c52f91">
cmp1 :: Bit a =&gt; (a,a,a) -&gt; (a,a) -&gt; (a,a,a)
cmp1 (lt,eq,gt) (x,y) =
  (or2 lt (and3 eq (inv x) y),
   and2 eq (inv (xor2 x y)),
   or2 gt (and3 eq x (inv y))
  )
</pre>


<p>
The ripple comparison circuit is defined simply using the pattern:
</p>


<pre class="example" id="org8e6aa30">
rippleCmp :: Bit a =&gt; [(a,a)] -&gt; (a,a,a)
rippleCmp = foldl cmp1 (zero,one,zero)
</pre>
</div>
</li>

<li><a id="orgcba75b3"></a>Fold from the right: foldr<br />
<div class="outline-text-5" id="text-orgcba75b3">
<p>
You can also run a fold across a word from the right to the left.
</p>


<pre class="example" id="org8ae4ccd">
foldr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)
</pre>


<p>
This is symmetric with <b>foldl</b>.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org759d9a5" class="outline-4">
<h4 id="org759d9a5">Circuit generators 2</h4>
<div class="outline-text-4" id="text-org759d9a5">
</div>
<ul class="org-ul">
<li><a id="orgc3bbfb9"></a>lec18 Circuit Generators<br />
<ul class="org-ul">
<li><a id="orgf0114ed"></a>Circuit Generators<br />
<ul class="org-ul">
<li><a id="org30d4796"></a>Abstraction<br />
<div class="outline-text-7" id="text-org30d4796">
<p>
We will generally specify large circuits using a circuit generator,
not by drawing every component individually.
</p>

<ul class="org-ul">
<li>Design patterns (higher order functions)</li>
<li>Special languages for special kinds of circuit (e.g. control
algorithms)</li>
</ul>
</div>
</li>

<li><a id="org003bff3"></a>Design patterns: Circuits as building blocks<br />
<div class="outline-text-7" id="text-org003bff3">
<ul class="org-ul">
<li>Design patterns are \emph{higher order} functions: they take
one or more \emph{circuit specifications} as parameters.</li>
<li>The pattern defines how to connect up these given circuits in
a regular pattern.</li>
<li>A pattern definition looks just like an ordinary circuit
specification, except

<ul class="org-ul">
<li>It uses recursion to decompose groups of signals.</li>
<li>It uses abstract circuits, supplied as parameters, instead
of specific circuits.</li>
<li>Its type may include building block circuits (these
parameters contain an \texttt{->} in their type) and/or size
parameters (with a type like \texttt{Int}).</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org28d3ad1"></a>Map<br />
<ul class="org-ul">
<li><a id="orgb39afba"></a>A circuit with a regular pattern: word inverter<br />
<div class="outline-text-8" id="text-orgb39afba">
<pre class="example" id="orgaec79d5">
winv4 :: Bit a =&gt; [a] -&gt; [a]
winv4 [x0,x1,x2,x3] = [inv x0, inv x1, inv x2, inv x3]
</pre>

<ul class="org-ul">
<li>Definition is simple</li>
<li>But it works only for one word size, and only for inverters</li>
<li>Extending it to larger word size is tedious and error-prone</li>
</ul>
</div>
</li>

<li><a id="org634be53"></a>Map &#x2014; expressing the regular pattern directly<br />
<div class="outline-text-8" id="text-org634be53">
<ul class="org-ul">
<li>Sometimes you have a circuit (it's arbitrary, so call it \(f\))
that takes an input (say it has type \(a\)) and produces an output
(call its type \(b\)).</li>
<li>You need to take a word of signals, and process each one with
the circuit \(f\).  For example, \texttt{inv4} processes each
signal with an \texttt{inv}.</li>
<li>The \texttt{map} pattern describes this in general.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sigma">map :: (a-&gt;b) -&gt; [a] -&gt; [b]
</pre>
</div>

<ul class="org-ul">
<li>The first argument to the pattern is a circuit with type
\texttt{a->b}</li>
<li>The pattern generates a circuit that takes an input word of type
\texttt{[a]} and produces an output word of type \texttt{[b]}.</li>
</ul>
</div>
</li>

<li><a id="orgd1ab043"></a>Example of map<br />
<div class="outline-text-8" id="text-orgd1ab043">
<p>
We can define a word inverter using the pattern that places an
inverter on each input signal, to produce the corresponding output
signals.
</p>

<div class="org-src-container">
<pre class="src src-sigma">winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x
</pre>
</div>

<p>
Technical note: in a defining equation of the form \texttt{f a b c
  = g c}, you can ``factor out'' the rightmost parameter from both
sides, giving a slightly shorter form.
</p>

<div class="org-src-container">
<pre class="src src-sigma">winv :: Bit a =&gt; [a] -&gt; [a]
winv = map inv
</pre>
</div>

<p>
This is attractive because it describes just the pattern.
</p>
</div>
</li>

<li><a id="orgb0dedf7"></a>Word inverter: ys = map inv xs<br />
<div class="outline-text-8" id="text-orgb0dedf7">
</div>
</li>

<li><a id="org06e591b"></a>Definition of map<br />
<div class="outline-text-8" id="text-org06e591b">
<div class="org-src-container">
<pre class="src src-sigma">map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
</pre>
</div>

<ul class="org-ul">
<li>A recursion, based on the word structure of the input.</li>

<li>The base case is an empty input word \texttt{[]}.  In this
case, the output is also empty.</li>

<li>The recursion (or induction) case has an input word
\texttt{x:xs} consisting of an initial bit \texttt{x} followed by
the rest of the word, \texttt{xs}.  The circuit introduces a copy
of the \texttt{f} circuit to process \texttt{x}, and handles the
rest recursively.</li>
</ul>
</div>
</li>

<li><a id="org34605b2"></a>Structure of map recursion<br />
<div class="outline-text-8" id="text-org34605b2">
</div>
</li>

<li><a id="orgf6c0bb0"></a>After the recursion has completed<br />
<div class="outline-text-8" id="text-orgf6c0bb0">
</div>
</li>

<li><a id="org97e2dd6"></a>Extending map to multiple inputs<br />
<div class="outline-text-8" id="text-org97e2dd6">
<p>
The \texttt{map2} pattern is similar to \texttt{map}, but it uses a
circuit that takes two inputs (thus its type is \texttt{a->b->c}).
Note that \texttt{map2} is \emph{not} a bit-slice pattern; it uses
separate words.
</p>

<div class="org-src-container">
<pre class="src src-sigma">map2 :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt; [c]
</pre>
</div>

<p>
We can extend the basic multiplexor to handle words:
</p>

<div class="org-src-container">
<pre class="src src-sigma">mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y
</pre>
</div>
</div>
</li>

<li><a id="org3f40722"></a>Forcing a specific word size<br />
<div class="outline-text-8" id="text-org3f40722">
<p>
The \texttt{mapn} pattern is similar to \texttt{map}, except it
takes a size parameter, and guarantees to produce an output of that
size.
</p>

<div class="org-src-container">
<pre class="src src-sigma">mapn :: (a-&gt;b) -&gt; Int -&gt; [a] -&gt; [b]
</pre>
</div>

<ul class="org-ul">
<li>Registers are defined using \texttt{mapn}, to ensure that the number
of flip flops is defined</li>
<li>Combinational circuits may be defined using \texttt{map}, so
they inherit the word size of their input</li>
</ul>
</div>
</li>
</ul>
</li>

<li><a id="orgbc66bf7"></a>Fold<br />
<div class="outline-text-7" id="text-orgbc66bf7">
<p>
The folding patterns define a linear circuit structure.
</p>

<ul class="org-ul">
<li>There is an input word of type \texttt{[b]}.</li>

<li>The elements of the word are combined using a building block
\texttt{f}.</li>

<li>There is a ``horizontal'' signal of some type (call it
\texttt{a}), which is goes across the word from left to right.</li>

<li>An initial horizontal input, of type \texttt{a} is provided.</li>

<li>The output is the final horizontal output (produced by the
rightmost \texttt{f} circuit).</li>
</ul>

<p>
Folding corresponds to a linear computation from one end of the
word to the other, starting with an initial value a (sometimes
called an accumulator, but this is not to be confused with
accumulator registers!).
</p>
</div>

<ul class="org-ul">
<li><a id="org71a833f"></a>The foldl pattern<br />
<div class="outline-text-8" id="text-org71a833f">
</div>
</li>

<li><a id="org922882f"></a>Recursive definition of foldl pattern<br />
<ul class="org-ul">
<li><a id="orgcd6810a"></a>Fold from the left<br />
<div class="outline-text-9" id="text-orgcd6810a">
<p>
In general, a fold can proceed either direction across the word.  The
\texttt{foldl} pattern describes a \emph{fold from the left}; i.e. the
information flows from left to right across the word.
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldl :: (a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a
</pre>
</div>

<p>
The pattern is defined recursively:
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldl f a [] = a
foldl f a (x:xs) = foldl f (f a x) xs
</pre>
</div>
</div>
</li>
</ul>
</li>

<li><a id="org2df2853"></a>Example of foldl: orw/andw<br />
<div class="outline-text-8" id="text-org2df2853">
<p>
The \texttt{orw} circuit determines whether there is any 1 bit in a
word.
</p>

<div class="org-src-container">
<pre class="src src-sigma">orw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
</pre>
</div>

<p>
The \texttt{andw} circuit determines whether all the bits in a word
are 1.
</p>

<div class="org-src-container">
<pre class="src src-sigma">andw :: Bit a =&gt; [a] -&gt; a
andw = foldl and2 one
</pre>
</div>

<p>
The time required (the path depth) is linear in the word size.
There are also tree-structured patterns that can do these
computations in logarithmic time.
</p>
</div>
</li>

<li><a id="org6440a2a"></a>Efficiency<br />
<div class="outline-text-8" id="text-org6440a2a">
<ul class="org-ul">
<li>The definitions of \texttt{orw} and \texttt{andw} are not
very efficient

<ul class="org-ul">
<li>If a large number of signals are being combined, a tree
structure of logic gates reduces the path depth.  If this
circuit is on the critical path, that will help.</li>
<li>If the technology supplies 3 or 4 input gates, it would
likely be faster to use some of those, rather than just the 2
input gates.</li>
<li>The \texttt{foldl} pattern uses one extra gate to include
the ``default'' value of zero or one.  This is overhead.</li>
</ul></li>

<li>This inefficiency is not a concern, because

<ul class="org-ul">
<li>There are alternative patterns that generate more efficient
circuits</li>
<li>A circuit optimiser can generate optimal results</li>
<li>If the circuit isn't on the critical path, it makes no
difference anyway.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org9cd1705"></a>Example of foldl: binary comparitor<br />
<div class="outline-text-8" id="text-org9cd1705">
<ul class="org-ul">
<li>The problem: input two binary numbers, in bit slice form:
\texttt{[(x0,y0), (x1,y1), ..., (xk,yk)]}</li>
<li>Output the result of a comparision: \texttt{(lt,eq,gt)},
giving the values of \((x<y, x=y, x>y)\).  Exactly one of the three
output bits must be 1.</li>
<li>Idea: start from left, assuming the numbers are equal so far:
\texttt{(0,1,0)}.</li>
<li>Move over the columns from left to right, updating the
results of the comparision using a building block circuit
\texttt{cmp1}.</li>
<li>Going from left to right, once we have established either \(<\)
or \(>\), that result will never change.</li>
<li>If the current result is \(=\) and \(x=y\), it's still \(=\).</li>
<li>If the current result is \(=\) but \(x\) and \(y\) are different,
the new result becomes \(<\) or \(>\).</li>
</ul>
</div>
</li>

<li><a id="org8c33af1"></a>Definition of binary comparitor with foldl<br />
<div class="outline-text-8" id="text-org8c33af1">
<p>
A bit comparison building block circuit:
</p>

<div class="org-src-container">
<pre class="src src-sigma">cmp1 :: Bit a =&gt; (a,a,a) -&gt; (a,a) -&gt; (a,a,a)
cmp1 (lt,eq,gt) (x,y) =
  (or2 lt (and3 eq (inv x) y),
   and2 eq (inv (xor2 x y)),
   or2 gt (and3 eq x (inv y))
  )
</pre>
</div>

<p>
The ripple comparison circuit is defined simply using the pattern:
</p>

<div class="org-src-container">
<pre class="src src-sigma">rippleCmp :: Bit a =&gt; [(a,a)] -&gt; (a,a,a)
rippleCmp = foldl cmp1 (zero,one,zero)
</pre>
</div>
</div>
</li>

<li><a id="orga915c24"></a>Fold from the right<br />
<div class="outline-text-8" id="text-orga915c24">
<p>
You can also run a fold across a word from the right to the left.
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)
</pre>
</div>

<p>
This is symmetric with \texttt{foldl}.
</p>
</div>
</li>
</ul>
</li>

<li><a id="org1cca4ed"></a>The foldr pattern<br />
<div class="outline-text-7" id="text-org1cca4ed">
</div>
</li>

<li><a id="org0325217"></a>Scan<br />
<div class="outline-text-7" id="text-org0325217">
<ul class="org-ul">
<li>A fold calculates a sequence of intermediate values, one for
every bit position.</li>
<li>A more general kind of pattern&#x2014;a \emph{scan}&#x2014;outputs this
word of intermediate values.</li>
<li>For every kind of fold, there is a corresponding scan, and
there are also some more general patterns that are based on scan.</li>
<li>Scans are important because

<ul class="org-ul">
<li>many important computations can be expressed via scans, and</li>
<li>a variety of patterns exist that implement scans efficiently.</li>
</ul></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org0d7d0e8"></a>Scan from the left: the scanl pattern<br />
<div class="outline-text-8" id="text-org0d7d0e8">
<p>
\[ [y_0, y_1, y_2, y_3, y_4] \ =
  \ \textsf{scanl}\ f\ a\ [x_0, x_1, x_2, x_3]
\]
</p>

<p>
\[ \textsf{ys} \ = \ \textsf{scanl}\ f\ a\ \textsf{xs} \]
</p>
</div>
</li>

<li><a id="org8f7505e"></a>Scan from the right<br />
<div class="outline-text-8" id="text-org8f7505e">
<p>
The \texttt{ascanr} pattern yields the word of intermediate results
that would occur during a \texttt{foldr}.  Specifically, it gives
the horizontal \emph{input} to each box in the \texttt{foldr}.
</p>

<div class="org-src-container">
<pre class="src src-sigma">ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; [a]
</pre>
</div>

<p>
The value of the output word can be defined directly in terms of
\texttt{foldr} of portions of the input word.  This is useful for
intuition and for formal mathematical reasoning.
</p>

<div class="org-src-container">
<pre class="src src-sigma">ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; (a,[a])
ascanr f a [] = (a,[])
ascanr f a (x:xs) = (f x a', a':xs')
  where (a',xs') = ascanr f a xs
</pre>
</div>
</div>
</li>

<li><a id="org71b7ca1"></a>Scan from the right: The scanr pattern<br />
<div class="outline-text-8" id="text-org71b7ca1">
<p>
\[ [y_0, y_1, y_2, y_3, y_4] \ =
  \ \textsf{scanr}\ f\ a\ [x_0, x_1, x_2, x_3]
\]
</p>

<p>
\[ \textsf{ys} \ = \ \textsf{scanr}\ f\ a\ \textsf{xs} \]
</p>
</div>
</li>

<li><a id="orge9d7aee"></a>Combining a map with a scan<br />
<div class="outline-text-8" id="text-orge9d7aee">
<p>
Many circuits combine a map with a scan: they output a value in each
bit position that depends on both horizontal input and the value of
the word in that bit position.
</p>

<p>
The \texttt{mscanr} pattern is useful for such cases (and there is
a corresponding \texttt{mscanl}).
</p>

<div class="org-src-container">
<pre class="src src-sigma">mscanr :: (a-&gt;b-&gt;(b,c)) -&gt; b -&gt; [a] -&gt; (b,[c])
mscanr f a [] = (a,[])
mscanr f a (x:xs) = (a'',y:ys)
  where
    (a',ys) = mscanr f a xs
    (a'',y) = f x a'
</pre>
</div>
</div>
</li>

<li><a id="org5625252"></a>Mapping scan from the right: the mscanr pattern<br />
<div class="outline-text-8" id="text-org5625252">
<pre class="example" id="org7f74487">
(a', [y0,y1,y2,y3]) = mscanr f a [x0,x1,x2,x3]
</pre>

<p>
In general, for words of arbitrary size:
</p>
<pre class="example" id="org394b8c3">
(a',ys) = mscanr f a xs
</pre>
</div>
</li>

<li><a id="org3d6e648"></a>Mapping scan from the left: the mscanl pattern<br />
<div class="outline-text-8" id="text-org3d6e648">
<pre class="example" id="org7b4e219">
(a', [y0,y1,y2,y3]) = mscanl f a [x0,x1,x2,x3]
</pre>

<p>
In general, for words of arbitrary size:
</p>
<pre class="example" id="org26f4e2f">
(a',ys) = mscanl f a xs
</pre>
</div>
</li>

<li><a id="orge14741c"></a>Example of mscanr: the ripple carry adder<br />
<div class="outline-text-8" id="text-orge14741c">
<div class="org-src-container">
<pre class="src src-sigma">fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)
</pre>
</div>

<p>
Ripple carry addition
</p>

<div class="org-src-container">
<pre class="src src-sigma">rippleAdd :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd = mscanr fullAdd
</pre>
</div>
</div>
</li>

<li><a id="org592feb9"></a>rippleAdd4<br />
<div class="outline-text-8" id="text-org592feb9">
</div>
</li>

<li><a id="orgdb4a1ed"></a>Order of parameters<br />
<div class="outline-text-8" id="text-orgdb4a1ed">
<ul class="org-ul">
<li>Circuit specifications using patterns can often be simplified
if you pay attention to the order of parameters.</li>
<li>For example, the ripple carry adder specification would be
clunkier if we had defined the full adder as \texttt{fullAddBad
  :: Bit a =&gt; a -&gt; (a,a) -&gt; (a,a)}.</li>
<li>How can you make the definitions work out cleanly?</li>
<li>Often there are choices that seem arbitrary at first, but
later on you realise things would be simpler if the choice had
been different.  This is a good time to go back and clean up your
specifications.</li>
</ul>
</div>
</li>

<li><a id="orgf4aff18"></a>Bidirectional mapping scan<br />
<div class="outline-text-8" id="text-orgf4aff18">
<ul class="org-ul">
<li>A very general pattern is the \texttt{mscan} pattern, which
takes a word, and \emph{two} horizontal values, one moving from
left to right and the other from right to left.  The pattern
combines a \texttt{foldl}, a \texttt{foldr}, and a \texttt{map}.</li>
<li>ALU circuits often use the \texttt{mscan} pattern.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sigma">mscan :: (a-&gt;b-&gt;c-&gt;(b,a,d)) -&gt; a -&gt; b -&gt; [c] -&gt; (b,a,[d])
mscan f a b [] = (b,a,[])
mscan f a b (x:xs) = (b'', a'', y:ys)
  where
    (b'',a',y) = f a b' x
    (b',a'',ys) = mscan f a' b xs
</pre>
</div>
</div>
</li>

<li><a id="org0bd9488"></a>Bidirectional mapping scan: the mscan pattern<br />
<div class="outline-text-8" id="text-org0bd9488">
<p>
\[ (b', a', [y_0, y_1, y_2, y_3]) \ =
  \ \textsl{mscan}\ f\ a\ b\ [x_0, x_1, x_2, x_3]
\]
</p>

<p>
\[ (b', a', \textsl{ys}) \ = \ \textsl{mscan}\ f\ a\ b\ \textsl{xs} \]
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>

<li><a id="org11668bf"></a>latex draft chapter patterns<br />
<ul class="org-ul">
<li><a id="org703ed38"></a>INSERT latex draft chapter patterns<br />
<div class="outline-text-7" id="text-org703ed38">
<p>
\chapter{Design Patterns}
</p>

<p>
Abstraction
</p>

<p>
We will generally specify large circuits using a circuit generator,
not by drawing every component individually.  There are two kinds of
circuit generator.  Design patterns (higher order functions) are the
focus of this chapter.  Special languages for special kinds of circuit
(e.g. control algorithms) are covered later.
</p>

<p>
Design patterns use circuits as building blocks
</p>

<p>
Design patterns are \emph{higher order} functions: they take one or
more \emph{circuit specifications} as parameters.  The pattern defines
how to connect up these given circuits in a regular pattern.  A
pattern definition looks just like an ordinary circuit specification,
except It uses recursion to decompose groups of signals.  It uses
abstract circuits, supplied as parameters, instead of specific
circuits.  Its type may include building block circuits (these
parameters contain an \texttt{->} in their type) and/or size
parameters (with a type like \texttt{Int}).
</p>


<p>
%------------------------------------------------------------------&#x2013;&#x2014;
\section{Map}
</p>

\begin{itemize}
\item Sometimes you have a circuit (it's arbitrary, so call it $f$)
  that takes an input (say it has type $a$) and produces an output
  (call its type $b$).
\item You need to take a word of signals, and process each one with
  the circuit $f$.  For example, \texttt{inv4} processes each
  signal with an \texttt{inv}.
\item The \texttt{map} pattern describes this in general.
\end{itemize}

<div class="org-src-container">
<pre class="src src-sigma">map :: (a-&gt;b) -&gt; [a] -&gt; [b]
</pre>
</div>

\begin{itemize}
\item The first argument to the pattern is a circuit with type
  \texttt{a->b}
\item The pattern then generates a circuits, which takes an input
  word of type \texttt{[a]} and produces an output word of type
  \texttt{[b]}.
\end{itemize}



<p>
%------------------------------------------------------------------&#x2013;&#x2014;
\subsection{Example of map}
</p>

<p>
We can define a word inverter using the pattern that places an
inverter on each input signal, to produce the corresponding output
signals.
</p>

<div class="org-src-container">
<pre class="src src-sigma">winv :: Signal a =&gt; [a] -&gt; [a]
winv x = map inv x
</pre>
</div>

<p>
Technical note: in a defining equation of the form \texttt{f a b c
  = g c}, you can ``factor out'' the rightmost parameter from both
sides, giving a slightly shorter form.
</p>

<div class="org-src-container">
<pre class="src src-sigma">winv :: Signal a =&gt; [a] -&gt; [a]
winv = map inv
</pre>
</div>

<p>
This is attractive because it describes just the pattern, without
mentioning signals explicitly.
</p>

<p>
Word inverter: ys = map inv xs
</p>

<p>
Definition of map
</p>

<div class="org-src-container">
<pre class="src src-sigma">map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
</pre>
</div>


<ul class="org-ul">
<li>A recursion, based on the word structure of the input.</li>
<li>The base case is an empty input word \texttt{[]}.  In this case, the
output is also empty.</li>
<li>The recursion (or induction) case has an input word \texttt{x:xs}
consisting of an initial bit \texttt{x} followed by the rest of the
word, \texttt{xs}.  The circuit introduces a copy of the \texttt{f}
circuit to process \texttt{x}, and handles the rest recursively.</li>
</ul>

<p>
Structure of map recursion
</p>

<p>
After the recursion has completed
</p>

<p>
Extending map to multiple inputs
</p>

<p>
The \texttt{map2} pattern is similar to \texttt{map}, but it uses a
circuit that takes two inputs (thus its type is \texttt{a->b->c}).
Note that \texttt{map2} is \emph{not} a bit-slice pattern; it uses
separate words.
</p>

<div class="org-src-container">
<pre class="src src-sigma">map2 :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt; [c]
</pre>
</div>

<p>
We can extend the basic multiplexor to handle words:
</p>

<div class="org-src-container">
<pre class="src src-sigma">mux1w :: Signal a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
mux1w c x y = map2 (mux1 c) x y
</pre>
</div>

<p>
Forcing a specific word size
</p>

<p>
The \texttt{mapn} pattern is similar to \texttt{map}, except it takes
a size parameter, and guarantees to produce an output of that size.
</p>

<div class="org-src-container">
<pre class="src src-sigma">mapn :: (a-&gt;b) -&gt; Int -&gt; [a] -&gt; [b]
</pre>
</div>

<ul class="org-ul">
<li>Registers are defined using \texttt{mapn}, to ensure that the number
of flip flops is defined</li>
<li>Combinational circuits may be defined using \texttt{map}, so they
inherit the word size of their input</li>
</ul>

<p>
Fold
</p>

<p>
The folding patterns define a linear circuit structure.
</p>

<ul class="org-ul">
<li>There is an input word of type \texttt{[b]}.</li>
<li>The elements of the word are combined using a building block
\texttt{f}.</li>
<li>There is a ``horizontal'' signal of some type (call it \texttt{a}),
which is goes across the word from left to right.</li>
<li>An initial horizontal input, of type \texttt{a} is provided.</li>
<li>The output is the final horizontal output (produced by the rightmost
\texttt{f} circuit).</li>
</ul>

<p>
Folding corresponds to a linear computation from one end of the word
to the other, starting with an initial value a (sometimes called an
accumulator, but this is not to be confused with accumulator
registers!).
</p>

<p>
Fold from the left
</p>

<p>
In general, a fold can proceed either direction across the word.  The
\texttt{foldl} pattern describes a \emph{fold from the left}; i.e. the
information flows from left to right across the word.
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldl :: (a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a
</pre>
</div>

<p>
The pattern is defined recursively:
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldl f a [] = a
foldl f a (x:xs) = foldl f (f a x) xs
</pre>
</div>

<p>
Examples: orw, andw
</p>

<p>
The \texttt{orw} circuit determines whether there is any 1 bit in a  word.
</p>

<div class="org-src-container">
<pre class="src src-sigma">orw :: Signal a =&gt; [a] -&gt; a
orw = foldl or2 zero
</pre>
</div>

<p>
The \texttt{andw} circuit determines whether all the bits in a word
are 1.
</p>

<div class="org-src-container">
<pre class="src src-sigma">andw :: Signal a =&gt; [a] -&gt; a
andw = foldl and2 one
</pre>
</div>

<p>
The time required (the path depth) is linear in the word size.  There
are also tree-structured patterns that can do these computations in
logarithmic time.
</p>

<p>
Efficiency
</p>

<ul class="org-ul">
<li>The definitions of \texttt{orw} and \texttt{andw} are not very
efficient</li>
<li>If a large number of signals are being combined, a tree structure of
logic gates reduces the path depth.  If this circuit is on the
critical path, that will help.</li>
<li>If the technology supplies 3 or 4 input gates, it would likely be
faster to use some of those, rather than just the 2 input gates.</li>
<li>The \texttt{foldl} pattern uses one extra gate to include the
``default'' value of zero or one.  This is overhead.</li>
<li>This inefficiency is not a concern, because
<ul class="org-ul">
<li>There are alternative patterns that generate more efficient
circuits</li>
<li>A circuit optimiser can generate optimal results</li>
<li>If the circuit isn't on the critical path, it makes no difference
anyway.</li>
</ul></li>
</ul>


<p>
Example: binary comparison
</p>

<ul class="org-ul">
<li>The problem: input two binary numbers, in bit slice form:
\texttt{[(x0,y0), (x1,y1), ..., (xk,yk)]}</li>
<li>Output the result of a comparision: \texttt{(lt,eq,gt)}, giving the
values of \((x<y, x=y, x>y)\).  Exactly one of the three output bits
must be 1.</li>
<li>Idea: start from left, assuming the numbers are equal so far:
\texttt{(0,1,0)}.</li>
<li>Move over the columns from left to right, updating the results of
the comparision using a building block circuit \texttt{cmp1}.</li>
<li>Going from left to right, once we have established either \(<\) or
\(>\), that result will never change.</li>
<li>If the current result is \(=\) and \(x=y\), it's still \(=\).</li>
<li>If the current result is \(=\) but \(x\) and \(y\) are different, the new
result becomes \(<\) or \(>\).</li>
</ul>

<p>
A bit comparison building block circuit:
</p>

<div class="org-src-container">
<pre class="src src-sigma">cmp1 :: Signal a =&gt; (a,a,a) -&gt; (a,a) -&gt; (a,a,a)
cmp1 (lt,eq,gt) (x,y) =
  (or2 lt (and3 eq (inv x) y),
   and2 eq (inv (xor2 x y)),
   or2 gt (and3 eq x (inv y))
  )
</pre>
</div>

<p>
The ripple comparison circuit is defined simply using the pattern:
</p>

<div class="org-src-container">
<pre class="src src-sigma">rippleCmp :: Signal a =&gt; [(a,a)] -&gt; (a,a,a)
rippleCmp = foldl cmp1 (zero,one,zero)
</pre>
</div>

<p>
Fold from the right
</p>

<p>
You can also run a fold across a word from the right to the left.
</p>

<div class="org-src-container">
<pre class="src src-sigma">foldr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)
</pre>
</div>

<p>
This is symmetric with \texttt{foldl}.
</p>

<p>
The foldr pattern
</p>

<p>
Scan
</p>

<ul class="org-ul">
<li>A fold calculates a sequence of intermediate values, one for every
bit position.</li>
<li>A more general kind of pattern&#x2014;a \emph{scan}&#x2014;outputs this word
of intermediate values.</li>
<li>For every kind of fold, there is a corresponding scan, and there are
also some more general patterns that are based on scan.</li>
<li>Scans are important because many important computations can be
expressed via scans, and a variety of patterns exist that implement
scans efficiently.</li>
</ul>

<p>
Scan from the left: scanl
</p>

<p>
\[ [y_0, y_1, y_2, y_3, y_4] \ =
   \ \textsf{scanl}\ f\ a\ [x_0, x_1, x_2, x_3]
\]
</p>

<p>
\[ \textsf{ys} \ = \ \textsf{scanl}\ f\ a\ \textsf{xs} \]
</p>

<p>
Scan from the right: scanr
</p>

<p>
The \texttt{ascanr} pattern yields the word of intermediate results
that would occur during a \texttt{foldr}.  Specifically, it gives the
horizontal \emph{input} to each box in the \texttt{foldr}.
</p>

<div class="org-src-container">
<pre class="src src-sigma">ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; [a]
</pre>
</div>

<p>
The value of the output word can be defined directly in terms of
\texttt{foldr} of portions of the input word.  This is useful for
intuition and for formal mathematical reasoning.
</p>

<div class="org-src-container">
<pre class="src src-sigma">ascanr :: (b-&gt;a-&gt;a) -&gt; a -&gt; [b] -&gt; (a,[a])
ascanr f a [] = (a,[])
ascanr f a (x:xs) = (f x a', a':xs')
  where (a',xs') = ascanr f a xs
</pre>
</div>

<p>
\[ [y_0, y_1, y_2, y_3, y_4] \ =
  \ \textsf{scanr}\ f\ a\ [x_0, x_1, x_2, x_3]
\]
</p>

<p>
\[ \textsf{ys} \ = \ \textsf{scanr}\ f\ a\ \textsf{xs} \]
</p>


<p>
Combining a map with a scan
</p>

<p>
Many circuits combine a map with a scan: they output a value in each
bit position that depends on both horizontal input and the value of
the word in that bit position.
</p>

<p>
The \texttt{mscanr} pattern is useful for such cases (and there is a
corresponding \texttt{mscanl}).
</p>

<div class="org-src-container">
<pre class="src src-sigma">mscanr :: (a-&gt;b-&gt;(b,c)) -&gt; b -&gt; [a] -&gt; (b,[c])
mscanr f a [] = (a,[])
mscanr f a (x:xs) = (a'',y:ys)
  where
    (a',ys) = mscanr f a xs
    (a'',y) = f x a'
</pre>
</div>

<p>
Unidirectional mapping scan: mscanl, mscanr
</p>

<p>
\[ (z, [y_0, y_1, y_2, y_3] \ =
   \ \textsf{mscanr}\ f\ a\ [x_0, x_1, x_2, x_3]
 \]
</p>

<p>
\[ (z,\textsf{ys}) \ = \ \textsf{mscanr}\ f\ a\ \textsf{xs} \]
</p>


<p>
\[ (z, [y_0, y_1, y_2, y_3] \ =
   \ \textsf{mscanr}\ f\ a\ [x_0, x_1, x_2, x_3]
 \]
</p>

<p>
\[ (z,\textsf{ys}) \ = \ \textsf{mscanr}\ f\ a\ \textsf{xs} \]
</p>


<p>
Example: the ripple carry adder
</p>

<div class="org-src-container">
<pre class="src src-sigma">fullAdd :: Signal a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)
</pre>
</div>

<p>
Ripple carry addition
</p>

<div class="org-src-container">
<pre class="src src-sigma">rippleAdd :: Signal a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
rippleAdd = mscanr fullAdd
</pre>
</div>

<p>
rippleAdd4
</p>

<p>
Order of parameters
</p>

<ul class="org-ul">
<li>Circuit specifications using patterns can often be simplified if you
pay attention to the order of parameters.</li>
<li id="For example, the ripple carry adder specification would be   clunkier if we had defined the full adder as \texttt{fullAddBad    ">Signal
a =&gt; a -&gt; (a,a) -&gt; (a,a)}.</li>
<li>How can you make the definitions work out cleanly?</li>
<li>Often there are choices that seem arbitrary at first, but later on
you realise things would be simpler if the choice had been
different.  This is a good time to go back and clean up your
specifications.</li>
</ul>

<p>
Bidirectional mapping scan: mscan
</p>

<ul class="org-ul">
<li>A very general pattern is the \texttt{mscan} pattern, which   takes a word, and \emph{two} horizontal values, one moving from   left to right and the other from right to left.  The pattern   combines a \texttt{foldl}, a \texttt{foldr}, and a \texttt{map}.</li>
<li>ALU circuits often use the \texttt{mscan} pattern.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sigma">mscan :: (a-&gt;b-&gt;c-&gt;(b,a,d)) -&gt; a -&gt; b -&gt; [c] -&gt; (b,a,[d])
mscan f a b [] = (b,a,[])
mscan f a b (x:xs) = (b'', a'', y:ys)
  where
    (b'',a',y) = f a b' x
    (b',a'',ys) = mscan f a' b xs
</pre>
</div>

<p>
\[ (b', a', [y_0, y_1, y_2, y_3]) \ =
   \ \textsl{mscanr}\ f\ a\ b\ [x_0, x_1, x_2, x_3]
 \]
</p>

<p>
\[ (b', a', \textsl{ys}) \ = \ \textsl{mscanr}\ f\ a\ b\ \textsl{xs} \]
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org68036f3" class="outline-2">
<h2 id="org68036f3">Combinational simulation</h2>
<div class="outline-text-2" id="text-org68036f3">
<p>
One way to simulate a combinational circuit is to apply it directly to
its inputs.  This works best if the circuit is defined with Bool as
the signal type.   Here is an example:
</p>

<pre class="example" id="org86724b3">
module HalfAddB where
import HDL.Hydra.Core.Lib

-- Demonstrate a circuit with a concrete type Bool, instead of a type
-- class constraint Bit a =&gt;.

halfAddB :: Bool -&gt; Bool -&gt; (Bool,Bool)
halfAddB x y = (and2 x y, xor2 x y)
</pre>
</div>
</div>


<div id="outline-container-org97c8a83" class="outline-2">
<h2 id="org97c8a83">Synchronous sequential simulation</h2>
<div class="outline-text-2" id="text-org97c8a83">
<p>
A sequential circuit may have feedback and state.  A sequential
circuit is <b>synchronous</b> if it uses a clock to ensure that all flip
flops change state simultaneously.
</p>
</div>
</div>


<div id="outline-container-orgb5c60f0" class="outline-2">
<h2 id="orgb5c60f0">Standard library for bits</h2>
<div class="outline-text-2" id="text-orgb5c60f0">
</div>
<div id="outline-container-org4f67c6c" class="outline-3">
<h3 id="org4f67c6c">Constant signals</h3>
<div class="outline-text-3" id="text-org4f67c6c">
<pre class="example" id="orge62a453">
zero                   signal with constant 0 value
one                    signal with constant 1 value
</pre>
</div>
</div>

<div id="outline-container-orgbcc2902" class="outline-3">
<h3 id="orgbcc2902">Logic gates</h3>
<div class="outline-text-3" id="text-orgbcc2902">
<pre class="example" id="orgf01babd">
inv                    inverter
and2, and3, and4       and gate with 2, 3, 4 inputs
nand2, nand3, nand4    and gate with 2, 3, 4 inputs
or2, or3, or4          or gate with 2, 3, 4 inputs
nor2, nor3, nor4       nor gate with 2, 3, 4 inputs
xor2, xor3, xor4       xor gate with 2, 3, 4 inputs
</pre>
</div>
</div>

<div id="outline-container-org39d30e6" class="outline-3">
<h3 id="org39d30e6">Replicating a signal</h3>
<div class="outline-text-3" id="text-org39d30e6">
<p>
Fanout takes a signal and splits it to several outputs.
</p>

<pre class="example" id="orgb1d173e">
fanout2 :: a -&gt; (a,a)
fanout2 x = (x,x)

fanout3 :: a -&gt; (a,a,a)
fanout3 x = (x,x,x)

fanout4 :: a -&gt; (a,a,a,a)
fanout4 x = (x,x,x,x)
</pre>
</div>
</div>

<div id="outline-container-org0a26f3a" class="outline-3">
<h3 id="org0a26f3a">Multiplexers and demultiplexers</h3>
<div class="outline-text-3" id="text-org0a26f3a">
<pre class="example" id="org923c110">
mux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mux1 p a b = x
  where x = or2 (and2 (inv p) a) (and2 p b)

mux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a
mux2 (c,d) p q r s =
  mux1 c  (mux1 d p q)
          (mux1 d r s)

mux3 :: Bit a =&gt; (a,a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a-&gt; a -&gt; a -&gt; a -&gt; a
mux3 (c0,c1,c2) a0 a1 a2 a3 a4 a5 a6 a7 =
  mux1 c0
    (mux1 c1
      (mux1 c2 a0 a1)
      (mux1 c2 a2 a3))
    (mux1 c1
      (mux1 c2 a4 a5)
      (mux1 c2 a6 a7))

mux22 :: Bit a =&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a)
mux22 (p0,p1) (a0,a1) (b0,b1) (c0,c1) (d0,d1) = (x,y)
  where x = mux2 (p0,p1) a0 b0 c0 d0
        y = mux2 (p0,p1) a1 b1 c1 d1
</pre>


<pre class="example" id="org4577869">
mux1 :: Bit a =&gt; a -&gt; a -&gt; a -&gt; a
mux1 p a b = x
  where x = or2 (and2 (inv p) a) (and2 p b)
</pre>


<pre class="example" id="org446e17e">
mux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a
mux2 (c,d) p q r s =
  mux1 c  (mux1 d p q)
          (mux1 d r s)
</pre>



<pre class="example" id="org4bcca22">
mux3 :: Bit a =&gt; (a,a,a) -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a-&gt; a -&gt; a -&gt; a -&gt; a
mux3 (c0,c1,c2) a0 a1 a2 a3 a4 a5 a6 a7 =
  mux1 c0
    (mux1 c1
      (mux1 c2 a0 a1)
      (mux1 c2 a2 a3))
    (mux1 c1
      (mux1 c2 a4 a5)
      (mux1 c2 a6 a7))
</pre>



<pre class="example" id="orgeb5f6eb">
mux22 :: Bit a =&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a) -&gt; (a,a)
mux22 (p0,p1) (a0,a1) (b0,b1) (c0,c1) (d0,d1) = (x,y)
  where x = mux2 (p0,p1) a0 b0 c0 d0
        y = mux2 (p0,p1) a1 b1 c1 d1
</pre>


<p>
A demultiplexer is an important building block circuit which is
related to the multiplexer.  It plays a central role in digital
circuit design, and we will see many applications that require them.
A common application a demultiplexer is to decode binary numbers.  For
example, we will use them later to implement memories (since the
address needs to be decoded), and they are also crucial in a
computer's control unit (where they are used to decode instruction
opcodes).
</p>

<p>
A 1-bit demultiplexer, called <b>demux1</b>, takes a control input <b>c</b> and
a data input <b>x</b>.  It produces two outputs <b>y0</b> and <b>y1</b> &#x2014; so it
provides a good practical example of the use of tuples.
</p>


<pre class="example" id="org2d2c4a4">
(y0,y1) = demux1 c x
</pre>


<p>
The idea of <b>demux1</b> is that we want to send the data input <b>x</b> to one
of the two outputs, and the choice depends on the control input <b>c</b>
&#x2014; thus if <b>c=0</b> then <b>y0=x</b>, but if <b>c=1</b> then <b>y1=x</b>.
But what happens to the output that is <b>not</b> selected by <b>c</b>?
That output has to have a well-defined value too, and we will set it
to the constant 0.  To summarize, the behavior of the <b>demux1</b> is
</p>


<pre class="example" id="org231a235">
y0 = if c==0 then x else 0
y1 = if c==1 then x else 0
</pre>


<pre class="example" id="orgbce8d35">
 c   x   y0   y1
--- --- ---- ----
 0   0    0    0
 0   1    1    0
 1   0    0    0
 1   1    0    1
</pre>

<p>
The implementation is straightforward.  From the truth table, you can
see that the <b>y1</b> has the same truth table as the <b>and2</b> gate, and
<b>y0=1</b> if <b>c=0</b> and <b>x=1</b>.
</p>


<pre class="example" id="orgdf1ee4c">
demux1 :: Bit a =&gt; a -&gt; a -&gt; (a,a)
demux1 c x = (y0,y1)
  where  y0 = and2 (inv c) x
         y1 = and2 c x
</pre>


<p>
It isn't actually necessary to define the names of the outputs; here
is an alternative definition that outputs a tuple of anonymous
signals.  The two circuits are identical; the only difference is in
the way they are described.  One advantage of the first definition is
that it offers the names <b>y0</b> and <b>y1</b> that may be helpful in
discussing how the circuit works, but the definitions yield the same
circuit and the choice between them is a matter of style.
</p>


<pre class="example" id="org798c296">
demux1 :: Bit a =&gt; a -&gt; a -&gt; (a,a)
demux1 c x = (and2 (inv c) x, and2 c x)
</pre>


<p>
There are several ways that a larger circuit could incorporate a
<b>demux1</b>.  If the pair <b>(y0,y1)</b> is being connected to the input of
some other circuit <b>circ</b> that takes a pair, then we could simply
write <b>circ (demux1 c x)</b>.  However, if the larger circuit needs
explicit access to <b>y0</b> or <b>y1</b>, then they should be given names using
an equation.
</p>

<p>
A demux2 circuit takes a two-bit control and produces \(2^{2} = 4\)
outputs.
</p>


<pre class="example" id="org5f5a578">
demux2 :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a,a,a)
demux2 (c0,c1) x = (y0,y1,y2,y3)
  where  (p,q) = demux1 c0 x
         (y0,y1) = demux1 c1 p
         (y2,y3) = demux1 c1 q
</pre>
</div>
</div>

<div id="outline-container-orga991f7c" class="outline-3">
<h3 id="orga991f7c">Bit addition</h3>
<div class="outline-text-3" id="text-orga991f7c">
<p>
When two bits are added together, the result could be 0, 1, or 2.  Two
bits are needed to represent the result, so a bit adder is an example
of a circuit that needs to output several signals.  The circuit that
does this is called a ``half adder'', and its name is <b>halfAdd</b>.
(Later we will discuss the ``full adder'', which adds three bits.)
The half adder can be specified with a truth table:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">x  y</th>
<th scope="col" class="org-right">x+y</th>
<th scope="col" class="org-left">c  s</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0  0</td>
<td class="org-right">0</td>
<td class="org-left">0  0</td>
</tr>

<tr>
<td class="org-left">0  1</td>
<td class="org-right">1</td>
<td class="org-left">0  1</td>
</tr>

<tr>
<td class="org-left">1  0</td>
<td class="org-right">1</td>
<td class="org-left">0  1</td>
</tr>

<tr>
<td class="org-left">1  1</td>
<td class="org-right">2</td>
<td class="org-left">1  0</td>
</tr>
</tbody>
</table>

<p>
Table: Truth table for halfAdd
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x</th>
<th scope="col" class="org-right">y</th>
<th scope="col" class="org-right">x+y</th>
<th scope="col" class="org-right">c</th>
<th scope="col" class="org-right">s</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
From the table, it is clear that the carry function is just <b>and2</b>,
and the sum function is <b>xor2</b>.
</p>


<pre class="example" id="org02f0a29">
halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (c,s)
  where
    c = and2 x y
    s = xor2 x y
</pre>


<p>
If you don't want to give names to the outputs <b>c</b> and <b>s</b>, the
definition can be shortened by putting the expressions for the signals
directly in the output tuple:
</p>


<pre class="example" id="org2bcd425">
halfAdd :: Bit a =&gt; a -&gt; a -&gt; (a,a)
halfAdd x y = (and2 x y, xor2 x y)
</pre>


<p>
The choice between these alternative definitions is a matter of style:
both are correct and both describe the same circuit.  The definition
with anonymous signals is shorter, while the definition with named
outputs uses simpler expressions and gives standard names for talking
about the outputs.
</p>

<p>
There is another bit adder circuit that illustrates how inputs can be
handled using either separate arguments or tuples.  This is the <b>full
adder</b>, which adds three bits.  Full adders are needed to add binary
numbers, because we have to add the carry as well as the two data bits
at each position.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">x  y  z</th>
<th scope="col" class="org-right">x+y+z</th>
<th scope="col" class="org-left">c  s</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0  0  0</td>
<td class="org-right">0</td>
<td class="org-left">0  0</td>
</tr>

<tr>
<td class="org-left">0  0  1</td>
<td class="org-right">1</td>
<td class="org-left">0  1</td>
</tr>

<tr>
<td class="org-left">0  1  0</td>
<td class="org-right">1</td>
<td class="org-left">0  1</td>
</tr>

<tr>
<td class="org-left">0  1  1</td>
<td class="org-right">2</td>
<td class="org-left">1  0</td>
</tr>

<tr>
<td class="org-left">1  0  0</td>
<td class="org-right">1</td>
<td class="org-left">0  1</td>
</tr>

<tr>
<td class="org-left">1  0  1</td>
<td class="org-right">2</td>
<td class="org-left">1  0</td>
</tr>

<tr>
<td class="org-left">1  1  0</td>
<td class="org-right">2</td>
<td class="org-left">1  0</td>
</tr>

<tr>
<td class="org-left">1  1  1</td>
<td class="org-right">3</td>
<td class="org-left">1  1</td>
</tr>
</tbody>
</table>

<p>
Table: Truth table for fullAdd.  The three input bits x, y, z are
added to produce a two-bit result consisting of a carry c and a sum s.
(Note that the input bits do <b>not</b> represent a 3-bit binary number;
they are simply three separate variables to be added.)
</p>

<p>
Since there are two output signals, it is necessary to combine them in
a tuple, so the type will have the form <b>&#x2026; -&gt; (a,a)</b>.  We have a
choice for handling the three input signals.  They could be treated as
separate arguments:
</p>

<pre class="example" id="org7961797">
fullAdd :: Bit a =&gt; a -&gt; a -&gt; a -&gt; (a,a)   -- version 1
</pre>

<p>
Alternatively, the three inputs could be collected into a tuple:
</p>

<pre class="example" id="org50519d0">
fullAdd :: Bit a =&gt; (a,a,a) -&gt; (a,a)   -- version 2
</pre>

<p>
But those are not the only possibilities.  Another approach is to
collect just two of the signals into a tuple, so there would be two
arguments, a tuple and a bit.  This gives two more ways to organize
the inputs:
</p>


<pre class="example" id="orgf9695a9">
fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)   -- version 3
fullAdd :: Bit a =&gt; a -&gt; (a,a) -&gt; (a,a)   -- version 4
</pre>



<p>
At this point, there is little reason to prefer one of these types
over another.  Later, however, when design patterns are introduced, it
will turn out that the design of larger circuits can be simplified if
we choose version (3), so that is the type actually used for the half
adder in the Hydra circuit library.
</p>

<p>
Don't worry about making the ``best'' choice for such decisions.  No
one always can make the best choice among the possible alternatives
while designing a large system.  What happens in the real world is
that systems are designed according to experience, judgment, and
taste.  If it turns out later that the design could be made clearer or
more elegant by changing one of these arbitrary choices, then that can
be done when the system is cleaned up.  The Hydra libraries have going
through this process several times.
</p>

<p>
Now we can define the full adder circuit.  For convenience, the
calculation of the carry and sum results will be performed by
auxiliary circuits, <b>bcarry</b> and <b>bsum</b>.
</p>


<pre class="example" id="org332071c">
fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)
</pre>


<p>
It isn't necessary to name the <b>x</b> and <b>y</b> signals individually.
Notice that the pair <b>(x,y)</b> comes into the circuit, and is then
passed to <b>bcarry</b> and <b>bsum</b>.  The <b>fullAdd</b> circuit itself doesn't
use either <b>x</b> or <b>y</b> directly.  Therefore we could just give a name,
such as <b>xy</b>, to the cluster <b>(x,y)</b>.  This shortens the notation:
</p>


<pre class="example" id="org2bf4070">
fullAdd :: Bit a =&gt; (a,a) -&gt; a -&gt; (a,a)
fullAdd xy c = (bcarry xy c, bsum xy c)
</pre>



<p>
Note that the signals <b>x</b> and <b>y</b> in the previous definition have the
bit signal type <b>a</b>.  This can be stated as <b>x :: a</b> and <b>y :: a</b>.  In
the simplified definition, the argument <b>xy</b> is a pair of bits, so <b>xy
:: (a,a)</b>.
</p>

<p>
To complete the circuit, we need to implement <b>bcarry</b> and <b>bsum</b>.
There are many ways to do this; the following specifications are
reasonable.  Since <b>bsum</b> and <b>bcarry</b> have the same type, we can
declare those types in one statement.  Read this as ``*bsum* and
<b>bcarry</b> both have type &#x2026;''.
</p>


<pre class="example" id="org5308c8d">
bsum, bcarry :: Bit a =&gt; (a,a) -&gt; a -&gt; a
bsum (x,y) c = xor3 x y c
bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)
</pre>
</div>
</div>

<div id="outline-container-orga413cd0" class="outline-3">
<h3 id="orga413cd0">Flip flops and registers</h3>
<div class="outline-text-3" id="text-orga413cd0">
<pre class="example" id="org4ed089e">
dff :: CBit a =&gt; a -&gt; a                  delay flip flop
reg1 :: CBit a =&gt; a -&gt; a -&gt; a     1-bit register
</pre>
</div>
</div>
</div>


<div id="outline-container-org99fdbb5" class="outline-2">
<h2 id="org99fdbb5">Standard library for words</h2>
<div class="outline-text-2" id="text-org99fdbb5">
<pre class="example" id="org1e522fd">
winv w                 invert the bits in a word
mux1w                  use 1-bit control to select between two words
bitslice2 x y          convert pair of words to word of pairs
mux2                   use two bit control to select one of four inputs
</pre>
</div>

<div id="outline-container-org0a004e8" class="outline-3">
<h3 id="org0a004e8">Replicating a bit</h3>
<div class="outline-text-3" id="text-org0a004e8">
<pre class="example" id="orga51beaf">
fanout :: Bit a =&gt; Int -&gt; a -&gt; [a]
fanout k x = take k (repeat x)
</pre>


<p>
Buffered fanout takes a signal and splits it to several outputs, and
inserts a buffer to ensure the outputs are strong enough.
</p>


<pre class="example" id="org1624ee2">
fanoutbuf2 :: Bit a =&gt; a -&gt; (a,a)
fanoutbuf2 x = (y,y)
  where y = buf x

fanoutbuf3 :: Bit a =&gt; a -&gt; (a,a,a)
fanoutbuf3 x = (y,y,y)
  where y = buf x

fanoutbuf4 :: Bit a =&gt; a -&gt; (a,a,a,a)
fanoutbuf4 x = (y,y,y,y)
  where y = buf x
</pre>



<pre class="example" id="org94a74ec">
fanout2 :: a -&gt; (a,a)
fanout2 x = (x,x)

fanout3 :: a -&gt; (a,a,a)
fanout3 x = (x,x,x)

fanout4 :: a -&gt; (a,a,a,a)
fanout4 x = (x,x,x,x)
</pre>


<p>
A wiring pattern that replicates a singleton signal to form a
word. The input x is a signal, which is replicated n times to form a
word w of size n.
</p>

<p>
Usage:
</p>
<pre class="example" id="org1a488a7">
w = fanout n x
</pre>

<p>
General form:
</p>
<pre class="example" id="orgdeea447">
fanout :: Bit a =&gt; Int -&gt; a -&gt; [a]
fanout n b             connect bit b to n outputs, forming a word
</pre>

<p>
Representing a boolean bit as a word: boolword takes a bit x, and
pads it to the left with 0s to form a word.  If the input x is
False (0), the result is the integer 0 (i.e. n 0-bits), and if x is
True (1) the result is the integer 1 (rightmost bit is 1, all
others are 0).
</p>

<p>
Usage:
</p>

<pre class="example" id="org74f50fd">
boolword n b           form an n-bit word, lsb = b, other bits = 0
</pre>

<p>
Definition:
</p>

<pre class="example" id="org52bcaf9">
boolword :: Bit a =&gt; Int -&gt; a -&gt; [a]
boolword n x = fanout (n-1) zero ++ [x]
</pre>
</div>
</div>

<div id="outline-container-orgd6dce8b" class="outline-3">
<h3 id="orgd6dce8b">Rearranging bits in a word</h3>
<div class="outline-text-3" id="text-orgd6dce8b">
</div>
<div id="outline-container-orge7f50c5" class="outline-4">
<h4 id="orge7f50c5">Combinational shifting</h4>
<div class="outline-text-4" id="text-orge7f50c5">
<p>
Shift a word to the right (shr) or to the left (shl).  In both cases,
this is just a wiring pattern.  A 0 is brought in on one side, and the
bit on the other side is just thrown away.
</p>



<pre class="example" id="orgf15a386">
shl :: Bit a =&gt; [a] -&gt; [a]
</pre>


<p>
shl is a wiring pattern that shifts a word to the left.  A zero is
brought in on the right side, and the value on the left is discarded.
This is a circuit generator that works for words of any size.  It is a
wiring pattern; no logic gates are generated.  Similar to shr.
</p>

<p>
Example:
</p>


<pre class="example" id="org9f1e9a0">
shl [a,b,c,d] = [b,c,d,zero]
</pre>


<pre class="example" id="orga226709">
shl [a,b,c,d] = [zero,a,b,c]
</pre>


<p>
shr is a wiring pattern that shifts a word to the right.  A zero is
brought in on the left side, and the value on the right is discarded.
This is a circuit generator that works for words of any size.  It is a
wiring pattern; no logic gates are generated.  Similar to shl.
</p>


<pre class="example" id="org8027c38">
shr :: Bit a =&gt; [a] -&gt; [a]
</pre>



<p>
Definitions:
</p>

<pre class="example" id="org5101d60">
shr x = zero : [x!!i | i &lt;- [0..k-2]]
  where k = length x
shl x = [x!!i | i &lt;- [1..k-1]] ++ [zero]
  where k = length x
</pre>
</div>
</div>

<div id="outline-container-orgafe8cf7" class="outline-4">
<h4 id="orgafe8cf7">Bit slice representation</h4>
<div class="outline-text-4" id="text-orgafe8cf7">
<p>
The bitslice2 wiring pattern takes two words, each of n bits, and
rearranges the wires into a word of n bit-pairs.
</p>

<pre class="example" id="org1c76c76">
bitslice2 :: [a] -&gt; [a] -&gt; [(a,a)]
</pre>

<p>
The unbitslice2 pattern is the inverse of bitslice2: it takes a word
of n bit-pairs, and returns a pair of n-bit words.
</p>

<pre class="example" id="org7738416">
unbitslice2 :: [(a,b)] -&gt; ([a], [b])
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b70869" class="outline-3">
<h3 id="org3b70869">Logic on words</h3>
<div class="outline-text-3" id="text-org3b70869">
<p>
Calculating a bit from a word
</p>


<pre class="example" id="orgbb0e688">
any1                   or the bits in a word: result is 1 if any 1 bit
</pre>


<pre class="example" id="org99bd8cd">
orw :: Bit a -&gt; [a] -&gt; a
andw :: Bit a -&gt; [a] -&gt; a
</pre>


<p>
And/Or over a word: Determine whether there exists a 1 in a word,
or whether all the bits are 0.  A tree fold can do this in log
time, but for simplicity this is just a linear time fold.
</p>


<pre class="example" id="orgd7b82f2">
orw, andw :: Bit a =&gt; [a] -&gt; a
orw = foldl or2 zero
andw = foldl and2 one
</pre>


<p>
Logic on each bit in a word
</p>

<p>
Word inverter: winv takes a word and inverts each of its bits
</p>


<pre class="example" id="org05043a9">
winv :: Bit a =&gt; [a] -&gt; [a]
winv x = map inv x
</pre>
</div>
</div>

<div id="outline-container-org301e5a6" class="outline-3">
<h3 id="org301e5a6">Conditionals and addresses</h3>
<div class="outline-text-3" id="text-org301e5a6">
</div>
<div id="outline-container-org10cd21c" class="outline-4">
<h4 id="org10cd21c">Multiplexers</h4>
<div class="outline-text-4" id="text-org10cd21c">
<pre class="example" id="org39ff38f">
mux1w :: Bit a =&gt; a -&gt; [a] -&gt; [a] -&gt; [a]
</pre>



<pre class="example" id="org6609ada">
z = mux1w c x y
If c=zero, then z=x, but otherwise z=y
</pre>


<p>
A singleton control signal is used to choose between two data words.
If the control is zero the first data word is sent to the output,
otherwise the second data word is sent to the output.  The two input
data words should have the same size, and the output word
automatically has that size as well.  This is a circuit generator that
works for any word size.
</p>



<pre class="example" id="org73a7244">
mux1w c x y = map2 (mux1 c) x y
</pre>



<pre class="example" id="orgfd5c023">
mux2w cc = map4 (mux2 cc)
</pre>
</div>
</div>


<div id="outline-container-orgc5fcf4e" class="outline-4">
<h4 id="orgc5fcf4e">Demultiplexers</h4>
<div class="outline-text-4" id="text-orgc5fcf4e">
<pre class="example" id="org770ddd3">
demux1w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux1w [c0] x =
  let (a0,a1) = demux1 c0 x
  in [a0,a1]
</pre>



<pre class="example" id="org024cc1d">
demux2w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux2w [c0,c1] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux1w [c1] a0
      w1 = demux1w [c1] a1
  in w0++w1

demux3w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux3w [c0,c1,c2] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux2w [c1,c2] a0
      w1 = demux2w [c1,c2] a1
  in w0++w1

demux4w :: Bit a =&gt; [a] -&gt; a -&gt; [a]
demux4w [c0,c1,c2,c3] x =
  let (a0,a1) = demux1 c0 x
      w0 = demux3w [c1,c2,c3] a0
      w1 = demux3w [c1,c2,c3] a1
  in w0++w1
</pre>
</div>
</div>
</div>
<div id="outline-container-orga5d1217" class="outline-3">
<h3 id="orga5d1217">Arithmetic</h3>
<div class="outline-text-3" id="text-orga5d1217">
</div>
<div id="outline-container-orgaef5933" class="outline-4">
<h4 id="orgaef5933">Binary addition</h4>
<div class="outline-text-4" id="text-orgaef5933">
<pre class="example" id="orga0ce90b">
bsum, bcarry :: Bit a =&gt; (a,a) -&gt; a -&gt; a
bsum (x,y) c = xor3 x y c
bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)
</pre>



<pre class="example" id="org0405944">
rippleAdd :: Bit a =&gt; a -&gt; [(a,a)] -&gt; (a,[a])
</pre>


<p>
The ripple carry adder takes a carry input, and two words organised in
bit slice form.  It produces a carry output and a sum word.  This is a
circuit generator, which allows input words of any size.
</p>
</div>
</div>
</div>

<div id="outline-container-org7834291" class="outline-3">
<h3 id="org7834291">Registers</h3>
<div class="outline-text-3" id="text-org7834291">
<pre class="example" id="orgc2d1752">
wlatch :: CBit a =&gt; Int -&gt; [a] -&gt; [a]
</pre>


<p>
Defines a register with output r, containing n bits, and with input x.
At every clock cycle, the register discards its old state and replaces
it with the current value of the input.
</p>


<pre class="example" id="org21d6385">
r = wlatch n x
</pre>

<p>
reg n ld x is an n-bit register with load control ld, data input x
</p>

<pre class="example" id="org9bd8f32">
reg
  :: CBit a =&gt;
  Int             -- ^ k = the word size
  -&gt; a          -- ^ ld = the load control signal
  -&gt; [a]        -- ^ input word of size k
  -&gt; [a]        -- ^ output is the register state

reg k ld x = mapn (reg1 ld) k x
</pre>

<p>
The regfile circuit is a register file with 2<sup>k</sup> registers, each n-bits
wide, load control ld, destination address d,` reads out registers sa
and sb, data input x
</p>

<pre class="example" id="org86b6477">
regfile n k ld d sa sb x 
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: John T. O'Donnell</p>
<p class="date">Created: 2022-09-29 Thu 13:58</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
